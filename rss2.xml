<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Fri, 22 Jan 2021 08:40:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[하루한줄] CVE-2020-15994 : Chrome WebAssembly Engine UAF 취약점</title>
      <link>https://hackyboiz.github.io/2021/01/22/l0ch/2021-01-22/</link>
      <guid>https://hackyboiz.github.io/2021/01/22/l0ch/2021-01-22/</guid>
      <pubDate>Fri, 22 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.br0vvnn.io/pages/blogpost.aspx?id=5&quot;&gt;Exploit</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.br0vvnn.io/pages/blogpost.aspx?id=5">Exploiting CVE-2020-15994 Chrome WebAssembly Engine UAF Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Google Chrome WebAssembly</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Chrome의 V8 WebAssembly 엔진에서 발견된 UAF 취약점에 대한 상세 정보가 공개되었습니다. WebAssembly는 JS의 단점을 보완하기 위해 브라우저에서 저수준 언어로 작성된 코드를 컴파일해 네이티브로 동작할 수 있도록 하는 기술 표준입니다.</p><p>WebAssembly의 <code>AsyncCompileJob</code> 객체는 <code>WebAssembly.instantiateStreaming</code> 함수에서 사용되는 기본 V8 객체이며 WebAssembly의 비동기 컴파일을 지원합니다. </p><p>취약점을 트리거하는 데 사용되는 함수는 다음과 같습니다.</p><p><code>AsyncCompileJob::FinishModule</code> - 컴파일된 WebAssembly 코드를 Javascript 객체로 인스턴스 화함<br><code>AsyncCompileJob::Abort</code> - WebAssembly 코드 다운로드 실패 시 호출되며 모든 컴파일 프로세스를 취소함<br>위 두 함수는 모두 <code>AsyncCompileJob</code> 객체를 해제하는 기능이 있습니다.</p><p><code>WebAssembly.instantiateStreaming</code> 함수를 이용하여 WebAssembly 코드를 컴파일하는 경우 WebAssembly 코드에서 Javascript 함수 및 객체에 접근하기 위한 인터페이스로 <code>importObject</code>를 사용합니다. 이때 <code>importObject</code>에 Getter를 정의하면 <code>InstanceBuilder::SanitizeImports</code> 함수는 Getter 함수를 콜백으로 호출합니다.</p><p>Getter를  <code>AsyncCompileJob::Abort</code> 로 정의해 콜백 함수로 호출하면 <code>AsyncCompileJob::FinishModule</code> 함수 이후 해제된 <code>AsyncCompileJob</code> 객체에 접근할 수 있어 UAF를 트리거할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/chrome/">chrome</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/webassembly/">webassembly</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/22/l0ch/2021-01-22/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-1456 : Unvalidated User Input in MS SharePoint</title>
      <link>https://hackyboiz.github.io/2021/01/21/idioth/2021-01-21/</link>
      <guid>https://hackyboiz.github.io/2021/01/21/idioth/2021-01-21/</guid>
      <pubDate>Thu, 21 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://slashcrypto.org/2021/01/15/CVE-2020-1456/&quot;&gt;INSERT</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://slashcrypto.org/2021/01/15/CVE-2020-1456/">INSERTION OF MALICIOUS LINKS FOR EXECUTION IN PROFILE PICTURE - UNVALIDATED USER INPUT IN MS SHAREPOINT 2019 (CVE-2020-1456)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>2020년 7월 14일 패치 이전 버전<ul><li>Microsoft SharePoint Server 2010 Service Pack 2</li><li>Microsoft SharePoint Server 2019</li><li>Microsoft SharePoint Enterprise Server 2013 Service Pack 1</li><li>Microsoft SharePoint Enterprise Server 2016</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft SharePoint Server에서 유저 프로필 사진에 임의의 링크를 삽입하여 프로필 사진이 삽입된 페이지를 방문하는 사람들을 모두 공격할 수 있는 취약점이 발견되었습니다. SharePoint는 마이크로소프트 오피스 서버 제품군의 웹 애플리케이션 플랫폼으로 기업이나 조직에서 공동 작업, 정보 제공 등의 협업 사이트 구축에 사용됩니다.</p><p>SharePoint의 유저 프로필 설정이 활성화되어 있으면, 사용자는 프로필 사진을 업로드할 수 있습니다. 프로필 사진을 올리고 적용하기 전에 모든 변경 사항을 저장할 수 있습니다. 모든 변경 사항이 저장될 때 POST request로 수행되며 아래와 같이 도메인에 사용자에 대한 변경 사항이 표시됩니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">URL</span>: http://<span class="hljs-number">192.168.0.151</span>/_layouts/<span class="hljs-number">15</span>/EditProfile.aspx?UserSettingsProvider=<span class="hljs-number">234</span>bf<span class="hljs-number">0</span>ed-<span class="hljs-number">70</span>db-<span class="hljs-number">4158</span>-a<span class="hljs-number">332</span>-<span class="hljs-number">4</span>dfd<span class="hljs-number">683</span>b<span class="hljs-number">4148</span>&amp;ReturnUrl=http%<span class="hljs-number">3</span>a%<span class="hljs-number">2</span>f%<span class="hljs-number">2</span>f<span class="hljs-number">192.168.0.151</span>%<span class="hljs-number">2</span>fPerson.aspx%<span class="hljs-number">3</span>faccountname%<span class="hljs-number">3</span>d%<span class="hljs-number">3</span>C span%<span class="hljs-number">20</span>style=%<span class="hljs-number">22</span>background-color:%<span class="hljs-number">20</span>#fcbd<span class="hljs-number">00</span>%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Epoint%<span class="hljs-number">3</span>C/span%<span class="hljs-number">3</span>E%<span class="hljs-number">255</span>C%<span class="hljs-number">3</span>Cspan%<span class="hljs-number">20</span>style=%<span class="hljs-number">22</span>background-color:%<span class="hljs-number">20</span>#fcbd<span class="hljs-number">00</span>%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Eshareuser%<span class="hljs-number">3</span>C/span%<span class="hljs-number">3</span>E&amp;changephoto=<span class="hljs-number">1</span></code></pre><p>POST request에는 URL 인코딩 된 형태로 업로드된 프로필 사진의 경로를 포함한 파라미터 <code>ct100$PlaceHolderMain$ProfileEditorEditPricturURL</code>가 포함되어 있습니다.</p><pre><code class="hljs angelscript">URL 인코딩 된 파라미터와 값ctl00%<span class="hljs-number">24</span>PlaceHolderMain%<span class="hljs-number">24</span>ProfileEditorEditPictureURL=http%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F192<span class="hljs-number">.168</span><span class="hljs-number">.0</span><span class="hljs-number">.151</span>%<span class="hljs-number">3</span>A80%<span class="hljs-number">2</span>FUser%<span class="hljs-number">2520</span>Photos%<span class="hljs-number">2</span>FProfilbilder%<span class="hljs-number">2</span>Fpoint_shareuser_Mthumb.jpg수정된 파라미터 값ctl00$PlaceHolderMain$ProfileEditorEditPictureURL=http:<span class="hljs-comment">//123.itsec.de/random.png</span></code></pre><p>POST request를 수정하여 URL 경로를 수정하면 로컬 파일의 경로 대신 수정한 URL 경로가 HTML 이미지 태그의 <code>src</code> 파라미터에 삽입됩니다. 그러면 해당 프로필 사진이 삽입된 페이지를 방문하는 모든 사용자는 백그라운드에서 해당 링크가 열립니다. 해당 취약점을 통해 Denial of Service, Tracking, Internal path disclosure, Obfuscate attacks, Reputation damage 등의 공격을 수행할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/xss/">xss</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/sharepoint/">sharepoint</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/21/idioth/2021-01-21/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] FreakOut : from three CVEs to IRC botnet</title>
      <link>https://hackyboiz.github.io/2021/01/20/fabu1ous/2021-01-20/</link>
      <guid>https://hackyboiz.github.io/2021/01/20/fabu1ous/2021-01-20/</guid>
      <pubDate>Wed, 20 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://research.checkpoint.com/2021/freakout-leveraging-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.checkpoint.com/2021/freakout-leveraging-newest-vulnerabilities-for-creating-a-botnet/">Leveraging Newest Vulnerabilities for creating a Botnet</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>아래 세 프로그램 중 하나라도 사용하고 있는 시스템</p><ul><li><p>TerraMaster TOS &lt; 4.2.06</p></li><li><p>Zend Framework &gt; 3.0.0</p></li><li><p>Liferay Portal &lt; 7.2.1 CE GA2</p></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Check Point는 FreakOut이라는 공격과 공격에 사용되는 악성 프로그램 <code>out.py</code>에 대한 정보를 공개했습니다. FreakOut은 아래 세 가지 CVE를 사용해 타겟 시스템에 <code> out.py</code>라는 악성 파이썬 스크립트를 설치하고 실행합니다.</p><ul><li><p>CVE-2020-28188</p><p>TerraMaster TOS(TerraMaster NAS 서버 관리용 운영체제)에서 발견된 RCE 취약점입니다. <code>/include/makecvs.php</code>의 <code>event</code>파라미터의 검증 미흡으로 OS commend injection이 가능합니다.</p></li><li><p>CVE-2021-3007</p><p>Zend Framework(PHP로 만들어진 웹앱 혹은 서비스를 위한 package)에서 발견된 RCE 취약점입니다. <code>__destruct</code> 메소드와 관련된 객체를 컨트롤할 수 있다면 deserializtion 취약점을 통한 원격 코드 실행까지 이어질 수 있습니다. FreakOut은 <code>callback</code>파라미터 값을 통해 해당 취약점을 악용합니다.</p></li><li><p>CVE-2020-7961</p><p>Liferay Portal(Java로 작성된 웹앱 플랫폼)에서 발견된 RCE 취약점입니다. JSONWS(Json web service)에 존재하는 untrusted data에 대한 Java unmarshalling 취약점을 악용해 원격 코드 실행을 할 수 있습니다.</p></li></ul><p>타겟 시스템에 설치된 <code>out.py</code>는 설치될 때마다 다른 방식으로 난독화됩니다. <code>out.py</code>에 감염된 시스템은 IRC를 통해 원격으로 조작할 수 있는 봇넷에 추가되고 아래 2가지 행위에 사용됩니다.</p><ol><li>추가 감염을 위한 공격서버</li><li>코인 마이닝 서버</li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/botnet/">botnet</category>
      
      <category domain="https://hackyboiz.github.io/tags/irc/">irc</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/20/fabu1ous/2021-01-20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Windows 커널 하나의 함수에서 발견된 5가지 취약점</title>
      <link>https://hackyboiz.github.io/2021/01/19/l0ch/2021-01-19/</link>
      <guid>https://hackyboiz.github.io/2021/01/19/l0ch/2021-01-19/</guid>
      <pubDate>Tue, 19 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.br0vvnn.io/pages/blogpost.aspx?id=4&quot;&gt;A Serie</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.br0vvnn.io/pages/blogpost.aspx?id=4">A Series of Windows Kernel Bugs in a Single Function</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows kernel</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows 커널 함수 중 ETW 구성 요소의 함수인 <code>EtwpNotifyGuid</code> 에 5개 이상의 취약점이 발견되었습니다.</p><p>현재까지 발견된 취약점 중 상세 정보가 공개된 취약점 목록은 다음과 같습니다.</p><ul><li>CVE-2020-1033</li><li><a href="https://hackyboiz.github.io/2020/10/26/idioth/cve-2020-1034/">CVE-2020-1034</a></li><li>CVE-2021-1662</li><li>CVE-2021-1682</li></ul><p>이중 최근에 공개된 취약점은 CVE-2021-1662와 CVE-2021-1668입니다.</p><p>CVE-2021-1662는 잘못된 범위 검증으로 인한 권한 상승 취약점으로,  <code>EtwpNotifyGuid</code> 함수에서 <code>input_buffer_length</code> 가 0x90이고 <code>v10</code>이 0x40이면 범위 검사를 통과해 <code>EtwpValidateTraceControlFilterDescriptors</code> 함수에서 OOB 액세스가 가능합니다.</p><p>CVE-2021-1682 또한 잘못된 범위 검증으로 인한 힙 버퍼 오버플로우 취약점입니다. <code>EtwpNotifyGuid</code> 함수는 <code>EtwpAllocDataBlock</code> 함수를 사용해 입력 버퍼를 복사하고 오프셋 0x50에 액세스 합니다. 버퍼 크기를 검사할 때 0x48보다 큰지는 확인하지만 0x50보다 작은 지를 확인하지 않아 0x50보다 작은 버퍼를 할당하면 오프셋 0x50에 액세스 할 때 다음 풀의 헤더를 덮어쓸 수 있어 이를 악용해 권한 상승이 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/19/l0ch/2021-01-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-1394 : Windows LockScreen Escalation of Privilege</title>
      <link>https://hackyboiz.github.io/2021/01/18/idioth/2021-01-18/</link>
      <guid>https://hackyboiz.github.io/2021/01/18/idioth/2021-01-18/</guid>
      <pubDate>Mon, 18 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://secret.club/2021/01/15/bitlocker-bypass.html&quot;&gt;Bit</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://secret.club/2021/01/15/bitlocker-bypass.html">BitLocker Lockscreen bypass</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows BitLocker Lockscreen 우회를 통한 권한 상승 취약점에 대한 세부 사항이 공개되었습니다. BitLocker는 Windows에서 지원하는 디스크 암호화 기능으로 볼륨 전체에 암호화를 제공하여 자료를 보호하도록 설계된 기능입니다. 하지만 다음과 같은 방법으로 관리자 계정을 추가하여 BitLocker를 우회할 수 있습니다.</p><ol><li>로그인 화면에서 “암호를 잊어버렸습니다.”를 선택합니다.</li><li>잠금 우회 후 이동식 드라이브의 자동 실행을 활성화합니다.</li><li>exe 파일과 junction folder가 있는 USB를 삽입합니다.</li><li>실행 파일이 실행되면 USB를 제거한 후 다시 삽입하고 메인 화면으로 돌아갑니다.</li><li>내레이터가 시작되면 설치된 DLL 페이로드가 실행됩니다.</li></ol><p>위의 작업을 수행하기 위해 LockScreen을 우회하는 방법은 다음과 같습니다.</p><ol><li>“암호/PIN을 잊어버렸습니다.”를 선택합니다. </li><li>화면을 볼 수 없으므로 내레이터를 사용하여 탐색을 진행합니다.</li><li>shift 키를 5번 연속으로 누르면, 설정 창을 여는 링크가 있는 창이 뜹니다.</li><li>링크를 클릭해도 시작된 설정 창은 볼 수 없으므로 링크를 1초에 2번 정도 계속 클릭합니다.</li><li>화면에 focus box가 나타나면 해당 창은 설정 창이므로 CapsLock + 왼쪽 화살표를 통해 홈으로 이동합니다.</li><li>CapsLock + 방향키를 통해 장치 - 자동 실행 - 이동식 드라이브 - 폴더를 열어 파일 보기(파일 탐색기)를 선택합니다.</li></ol><p>이후 USB 연결 후 내레이터가 창이 떴다고 했을 때 Exploit.exe 파일을 실행하면 암호를 사용하지 않고 실행이 가능합니다.</p><p>USB가 마운트 될 때 BitLocker는 시스템 볼륨 정보에 <code>ClientRecoveryPasswordRotation</code>이라는 디렉터리를 생성하고 <code>Authenticated Users: (F), SYSTEM: (I) (OI) (CI) (F)</code> 권한을 부여합니다. 디렉터리 생성 작업을 리다이렉트 하기 위해 USB를 사용하여 <code>\System Volume Information</code>을 <code>\RCP Control</code>로 향하는 마운트 포인트로 만듭니다. 그 후 <code>\RPC Control\ClientRecoveryPasswordRoation</code>에 <code>\??\C:\Windows\system32\Narrator.exe.local</code>에 대한 심볼릭 링크를 생성합니다. USB를 다시 삽입하면, <code>C:\Windows\System32\Narrator.exe.locl</code> 폴더는 하위 디렉터리를 생성할 수 있는 권한으로 생성됩니다. 이 하위 디렉터리에 DLL 페이로드를 넣은 후 내레이터가 시작되면, DLL 페이로드가 실행됩니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/lockscreen/">lockscreen</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/18/idioth/2021-01-18/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] R.I.P ROP: CET Internals in Windows 20H1</title>
      <link>https://hackyboiz.github.io/2021/01/17/l0ch/cet-on-windows/</link>
      <guid>https://hackyboiz.github.io/2021/01/17/l0ch/cet-on-windows/</guid>
      <pubDate>Sun, 17 Jan 2021 06:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요 L0ch입니다! 지난번 Windows Patch Diffing에 이어 이번엔 번역글로 돌아왔습니다.&lt;/p&gt;
&lt;p&gt;오늘 번역글의 주제는 인텔이 도입한 새로운 미티게이션인 CET입니다. CET는 이전에 우리 막내인 Fabu1ous의 &lt;a </description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요 L0ch입니다! 지난번 Windows Patch Diffing에 이어 이번엔 번역글로 돌아왔습니다.</p><p>오늘 번역글의 주제는 인텔이 도입한 새로운 미티게이션인 CET입니다. CET는 이전에 우리 막내인 Fabu1ous의 <a href="https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/">x64 stack alignment</a> 글의 마지막에 잠깐 언급되기도 했었죠? 인텔에선 이미 차세대 모바일 플랫폼인 Tiger Lake에 이 기능을 내장했으니 곧 상용화가 머지않았네요.</p><p>첫 번역글이라 오역과 오타가 난무할 수 있습니다.. ㅠㅠ 발견하신다면 가차 없이 지적해주시면 감사하겠습니다.</p><blockquote><p> 원문 글 : <a href="https://windows-internals.com/cet-on-windows/">R.I.P ROP: CET Internals in Windows 20H1</a> </p></blockquote><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><p>최근 Windows 10의 19H1(Version 1903) 릴리즈 버전에 매우 흥미로운 일이 발생했다. 인텔 <a href="https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf">CET(Control-flow Enforcement Technology)</a> 구현이 수년간의 논의 끝에 시작된 것이다.</p><p>이러한 CET 적용은 모든 버전의 Windows 릴리즈에 추가되고 있으며, 작년(2020) 릴리스인 20H1 (버전 2004)은 Intel Tiger Lake CPU에서 릴리즈 될 CET의 user mode shadow stack 기능에 대한 지원을 완료했다.</p><p>인텔 CET는 익스플로잇에서 일반적으로 사용되는 두 가지 유형의 제어 흐름 무결성 위반인 forward-edge 위반 (indirect CALL 및 JMP)과 backward-edge 위반 (RET)을 해결하는 하드웨어 기반 mitigation이다.</p><p>forward-edge 구현은 새롭지 않지만 (기본적으로 Microsoft의 <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">Control Flow Guard</a>와 유사한 형태의 <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">clang-cfi</a>이기 때문이다.) backward-edge 구현은 ISA의 근본적인 변화에 의존한다. Shadow Stack 은 CALL 명령어에 의해 스택에 푸시된 반환 주소를 복제하며, RET 명령어 실행 시 스택 및 섀도우 스택 값을 모두 확인하고 불일치 시 INT #21 (제어 흐름 보호 오류)를 생성한다.</p><p>운영 체제 및 컴파일러는 CALL과 RET 이외의 제어 흐름 시퀀스(예 : 예외 해제 및 <a href="https://en.cppreference.com/w/cpp/utility/program/longjmp">longjmp</a>)를 지원해야 하기 때문에 시스템 수준에서 필요한 동작과 일치하도록 <code>Shadow Stack Pointer(SSP)</code> 를 조작해야 하며, 이 조작 자체가 잠재적인 우회가 되지 않도록 검증해야 한다. 이 게시물에서는 Windows가 이를 달성하는 방법에 대해 설명한다.</p><p>Windows가 스레드에 대한 shadow stack을 조작하고 유효성을 검사하는 방법에 대해 자세히 알아보기 전에 먼저 두 가지를 이해해야 한다. 첫 번째는 SSP의 실제 위치 및 권한이고 두 번째는 SSP스레드 간 콘텍스트 전환 시 저장/복원하는 데 사용되는 메커니즘과 필요한 경우 (예 : 예외 해제 중)  SSP 수정이 수행되는 방법이다.</p><p>이러한 메커니즘을 설명하려면 <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX(Advanced Vector eXtensions)</a> 명령을 지원하기 위해 Intel에서 도입하고 Windows 7부터 Microsoft가 지원한 Intel CPU 기능을 알아봐야 한다. 또한 이 기능을 사용하기 위해 기존 CONTEXT구조를 문서화되지 않은 CONTEXT_EX구조로 재구성하고 이를 처리하기 위한 native API를 추가하는 것에 대해서도 이야기해야 한다!</p><p>마지막으로 Windows의 CET 기능에 대한 추가적인 요구사항을 다루기 위해 일부 컴파일러 및 PE 파일 포맷의 내부와 새로운 프로세스 정보 클래스를 살펴봐야 한다. 이 글의 목차가 이러한 기능에 대한 전체적인 내용을 탐색하는 데 도움이되기를 바란다. 또한 <a href="https://github.com/yardenshafir/cet-research">관련 GitHub 저장소</a>를 기반으로 함수 이름을 클릭하면 새로 도입된 다양한 함수에 대한 주석이 달린 소스 코드를 사용할 수 있다.</p><h1 id="XState-내부"><a href="#XState-내부" class="headerlink" title="XState 내부"></a>XState 내부</h1><p>x86-x64 아키텍처 클래스 프로세서는 범용 레지스터(RAX, RCX), 제어 레지스터 (RIP, RSP…), 부동 소수점 레지스터 (XMM, YMM, ZMM)와 일부 제어, 디버그 및 테스트 레지스터 등 대부분의 보안 연구자들에게 익숙한 레지스터 세트로 구성되었다. 그러나 더 많은 프로세서 기능이 추가됨에 따라 새 레지스터 및 이러한 기능과 관련된 특정 프로세서 상태를 정의해야 했다. 그리고 이러한 기능 중 많은 부분이 스레드 내부에서 사용하므로 콘텍스트 전환 중에 저장하고 복원해야 한다.</p><p>이에 대한 해결책으로 인텔은 다양한 프로세서 상태를 <code>상태 마스크</code>의 비트와 연결하고 <code>XSAVE</code> 영역에서 요청된 상태를 읽고 쓰기 위한 <code>XSAVE</code> 및 <code>XRSTOR</code>와 같은 명령어를 도입하는 <code>XState(eXtended State)</code> <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developers-manual.pdf">표준</a>을 정의했다. 이 영역은 각 스레드에 대한 CET 레지스터 저장소의 중요한 부분이지만 대부분의 사람들은 기존 부동 소수점, AVX 및 <a href="https://software.intel.com/en-us/articles/introduction-to-intel-memory-protection-extensions">메모리 보호 확장(Memory Protection eXtensions, MPX)</a> 기능에 초점을 두었기 때문에 XSAVE 지원을 대부분 무시하고 있다. 기능 및 메모리 레이아웃에 대한 개요는 독자에게 도움이 될 것이다.</p><h2 id="XSAVE-영역"><a href="#XSAVE-영역" class="headerlink" title="XSAVE 영역"></a>XSAVE 영역</h2><p>앞서 언급했듯이 XSAVE 영역은 원래 Intel에서 프로세서에 추가 한 AVX와 같은 새로운 부동 소수점 기능 중 일부를 저장하고 이전에 <code>FXSTOR</code> 및 <code>FXRSTR</code> 명령을 통해 저장되는 기존 x86 FPU 및 SSE 상태를 통합하는 데 사용되었다. 이 처음 두 개의 레거시 상태는 <code>레거시 XSAVE 영역</code>의 일부로 정의되었으며 추가 프로세서 레지스터 (예 : AVX)는 <code>확장된 XSAVE 영역</code>에 추가되었다. 그 사이에 <code>XSAVE 영역 헤더</code> 는 <code>XSTATE_BV</code>라는 상태 마스크를 통해 어떤 확장 기능이 있는지 설명하는 데 사용된다.</p><p>동시에 XSAVE 기능의 일부로 운영체제에서 지원하는 상태를 정의하는 새로운 <code>XCR0(eXtended Control Register)</code>가 추가되었으며 XCR0을 구성하기 위해 <code>XGETBV</code> 및 <code>XSETBV</code> 명령이 추가되었다. (이후에 추가될 <code>XCR</code>도 마찬가지이다.) 예를 들어 운영체제는 x87 FPU 및 SSE에 대한 기능 상태 비트를 포함하지 않도록, 즉 레거시 <code>FXSTOR</code> 명령을 사용하여 수동으로 저장하고 확장된 기능의 상태만 XSAVE 영역에 저장하도록 XCR0을 프로그래밍해 선택할 수 있다.</p><p><code>PKRU(Protection Key Register User State)</code>를 추가한  <a href="https://www.kernel.org/doc/html/latest/core-api/protection-keys.html">MPK(Memory Protection Key)</a>와 같은 고급 레지스터 세트 및 기능의 수가 증가함에 따라 최신 프로세서는 <code>XSAVES</code> 및 <code>XRSRTORS</code>를 사용하는 CPL0 코드로만 수정할 수 있는 슈퍼바이저 상태와 압축 및 최적화 버전 (<code>XSAVEC</code> / <code>XSAVEOPT</code>)으로 구분해 인텔만의 방식으로 복잡하게 만들었다. 슈퍼바이저 전용 상태를 정의하기 위해 <code>IA32_XSS</code>라는 새로운 <code>MSR(Model Specific Register)</code>이 추가되었다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/1.png"></p><blockquote><p>optimized XSAVE 영역 vs not optimized XSAVE 영역<br>(VX 및 CET_U가 노트 활성화되고 IPT 및 PKRU가 활성화되었지만 마지막 콘텍스트 전환 이후에 사용되지 않은 스레드)</p></blockquote><p><code>Optimized XSAVE</code> 메커니즘은 마지막 콘텍스트 스위치 (있는 경우) 이후 다른 스레드에 의해 실제로 수정된 프로세서 상태만 XSAVE영역에 기록할 수 있게 해 주며 내부 프로세서 레지스터는 <code>XINUSE</code>이 정보를 추적할 수 있게 해 준다. <code>XSAVEOPT</code>를 사용할 때 <code>XSTATE_BV</code> 마스크는 요청된 모든 상태가 아니라 실제로 저장된 상태에 해당하는 비트만 포함된다.</p><p>반면 <code>Compacted XSAVE</code> 메커니즘은 기존 XState 디자인의 결함을 수정했다. <code>AVX512</code> 및 <a href="https://software.intel.com/content/www/us/en/develop/blogs/processor-tracing.html">IPT(Intel Processor Trace)</a>와 같은 더 많은 확장 기능이 추가됨에 따라 이러한 기능을 사용하지 않으면 큰 XSAVE영역을 할당하고 0으로 기록해야 한다. <code>Optimized XSAVE</code>는 이러한 낭비를 피할 수 있지만 여전히 사용되지 않는 확장 기능은 기본 XSAVE 영역 버퍼로부터 큰 오프셋에 있음을 의미한다.</p><p><code>XSAVEC</code>를 사용하면 현재 스레드에 의해 실제로 활성화된 XState 기능을 저장하기 위한 공간만 사용하고 저장된 각 상태를 순차적으로 메모리에 배치함으로써 문제를 해결할 수 있다. (CPUID를 통해 <code>정렬 마스크</code>의 일부로 제공되는 고정 64-byte 정렬을 사용할 수 있다.)</p><p>이전에 표시된 XSAVE 영역 헤더는 두 번째 상태 마스크인 <code>XCOMP_BV</code>로 확장되어 요청된 상태 비트 중 어느 것이 비교 영역에 있을 수 있는지 나타낸다. <code>XSTATE_BV</code>와 달리 이 마스크는 <code>XINUSE</code>의 일부가 아닌 상태 비트를 생략하지 않아 압축될 수 있는 모든 가능한 비트를 포함하므로 <code>XSTATE_BV</code>를 통해 실제로 어떤 상태 영역이 있는지 확인해야 한다. 마지막으로, 압축된 명령어가 사용될 때 비트 63은 항상 <code>XCOMP_BV</code>에서 XSAVE 영역에 대한 지시자로 설정된다.</p><p>따라서 압축된 포맷인지에 따라 XSAVE 영역의 내부 레이아웃과 크기가 결정된다. 압축된 포맷은 스레드에서 사용하는 프로세서 기능에 대해서만 XSAVE 영역의 메모리를 할당하고, 압축되지 않은 포맷은 프로세서가 지원하는 모든 프로세서 기능에 대해 메모리를 할당하고 스레드에서 사용하는 기능만 사용한다. 아래 다이어그램은 동일한 스레드에 대해 XSAVE 영역이 어떻게 보이는지, 각각의 포맷을 사용할 때의 예를 보여준다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/2.png"></p><blockquote><p>Compacted XSAVE vs not Compacted XSAVE AVX 및 CET_U가 활성화되지 않은 스레드, 이러한 기능을 지원하는 프로세서에서 실행됨</p></blockquote><p>요약하자면,  <code>XSAVE</code>와 <code>XRSTOR</code> 명령어 집합은 다음과 같은 조합과 함께 사용된다.</p><ol><li>OS가 XCR0을 지원할 때 설정되는 상태 비트 (<code>XSETBV</code> 명령어를 사용하여 설정)</li><li><code>XSAVE</code> 명령을 사용할 때 호출자가 EDX : EAX에 저장하는 상태 비트 (인텔에서는 이를 <code>instruction mask</code>라고 함)</li><li>권한이 없는 명령어를 사용하는 경우 <code>IA32_XSS</code>에 설정되지 않은 상태 비트</li><li><code>XINUSE</code>에 설정된 상태 비트인 <code>최적화된 XSAVE</code>를 지원하는 프로세서에서 마지막 전환 이후 현재 스레드에서 사용된 실제 XState 관련 레지스터를 추적하는 내부 레지스터</li></ol><p>이러한 비트가 함께 마스킹되면 <code>XSAVE</code> 명령에 의해 <code>XSTATE_BV</code> 필드의 XSAVE 영역의 헤더에 최종 상태 비트가 기록된다. <code>Compacted XSAVE</code>를 사용하는 경우 <code>XINUSE</code>를 생략한 결과 상태 비트가  <code>XCOMP_BV</code> 필드에 XSAVE 영역의 헤더에 기록된다. 아래 다이어그램은 결과 마스크를 보여준다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/3.png"></p><h2 id="XState-구성"><a href="#XState-구성" class="headerlink" title="XState 구성"></a>XState 구성</h2><p>각 프로세서에는 자체적인 XState 활성화 기능, 예상되는 크기, 기능 및 메커니즘 세트를 가지고 있어 Intel은 운영 체제가 XState를 처리할 때 쿼리 해야 하는 다양한 CPUID 클래스를 통해 정보를 노출한다. Windows는 부팅 시 이러한 쿼리를 수행하고 <code>XSTATE_CONFIGURATION</code> 아래에 표시된 구조에 정보를 저장한다. (Winnt.h에 문서화됨)</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSTATE_CONFIGURATION</span></span><span class="hljs-class">&#123;</span>    ULONG64 EnabledFeatures;    ULONG64 EnabledVolatileFeatures;    ULONG Size;    <span class="hljs-keyword">union</span>    &#123;        ULONG ControlFlags;        <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">        &#123;</span>            ULONG OptimizedSave:<span class="hljs-number">1</span>;            ULONG CompactionEnabled:<span class="hljs-number">1</span>;        &#125;;    &#125;;    XSTATE_FEATURE Features[MAXIMUM_XSTATE_FEATURES];    ULONG64 EnabledSupervisorFeatures;    ULONG64 AlignedFeatures;    ULONG AllFeatureSize;    ULONG AllFeatures[MAXIMUM_XSTATE_FEATURES];    ULONG64 EnabledUserVisibleSupervisorFeatures;&#125; XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;</code></pre><p>이 데이터들을 보관한 후 커널은 <code>KUSER_SHARED_DATA</code> 구조체에 저장한다. 이 구조체는 <code>SharedUserData</code> 변수를 통해 액세스 할 수 있으며 모든 Windows 플랫폼의 <code>0x7FFE0000</code> 주소에 존재한다.</p><p>Optimized, Compacted XSAVE를 모두 지원하고 x87 FPU(0), SSE(1), AVX(2) 및 MPX(3, 4) 기능 비트를 지원하는 테스트 <code>19H1</code> 시스템의 출력을 예로 들 수 있다.</p><pre><code class="hljs c">dx ((nt!_KUSER_SHARED_DATA*)<span class="hljs-number">0x7ffe0000</span>)-&gt;XState    [+<span class="hljs-number">0x000</span>] EnabledFeatures  : <span class="hljs-number">0x1f</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x008</span>] EnabledVolatileFeatures : <span class="hljs-number">0xf</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x010</span>] Size             : <span class="hljs-number">0x3c0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x014</span>] ControlFlags     : <span class="hljs-number">0x3</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x014</span> ( <span class="hljs-number">0</span>: <span class="hljs-number">0</span>)] OptimizedSave    : <span class="hljs-number">0x1</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x014</span> ( <span class="hljs-number">1</span>: <span class="hljs-number">1</span>)] CompactionEnabled : <span class="hljs-number">0x1</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x018</span>] Features         [Type: _XSTATE_FEATURE [<span class="hljs-number">64</span>]]    [+<span class="hljs-number">0x218</span>] EnabledSupervisorFeatures : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x220</span>] AlignedFeatures  : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x228</span>] AllFeatureSize   : <span class="hljs-number">0x3c0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x22c</span>] AllFeatures      [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> [<span class="hljs-number">64</span>]]    [+<span class="hljs-number">0x330</span>] EnabledUserVisibleSupervisorFeatures : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]</code></pre><p>Features 배열에서 다음 5가지 기능의 크기와 오프셋을 확인할 수 있다.</p><pre><code class="hljs c">dx -r2 (((nt!_KUSER_SHARED_DATA*)<span class="hljs-number">0x7ffe0000</span>)-&gt;XState)-&gt;Features.Take(<span class="hljs-number">5</span>)    [<span class="hljs-number">0</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0xa0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">1</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0xa0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x100</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">2</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x240</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x100</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">3</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x340</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x40</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">4</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x380</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x40</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]</code></pre><p>이 크기를 합하면 위의 <code>FeatureSize</code> 필드에 표시된 값인 <code>0x3C0</code>이 된다. 그러나 이 시스템은 <code>Compacted XSAVE</code> 기능을 지원하므로 여기에 표시된 오프셋은 관련이 없으며 모든 기능의 크기를 포함하지만 오프셋은 포함하지 않는 커널에만 유용하게 사용 가능하다.(<code>XCOMP_BV</code>에서 사용되는 압축 마스크를 기반으로 결정되기 때문)</p><h2 id="XState-정책"><a href="#XState-정책" class="headerlink" title="XState 정책"></a>XState 정책</h2><p>프로세서가 XState을 지원하지만 다양한 하드웨어 오류 때문에 특정 프로세서가 이 기능을 제대로 지원하지 못하는 경우가 종종 발생한다. 이 문제를 처리하기 위해 Windows는 일반적으로  라고 하는 하드웨어 정책 드라이버인 <code>HwPolicy.sys</code> 의 리소스 섹션에 저장된 XState 정책을 사용한다.</p><p>Intel x86 아키텍처는 여러 프로세서 벤더 중 하나이므로 커널은 XState 정책을 구문 분석하고 현재 프로세서의 벤더 문자열 및 마이크로코드 버전뿐만 아니라 시그니처, 기능 및 확장 기능을 비교하고 (즉, CPUID 01h 쿼리의 RAX, RDX 및 RCX), 정책에서 일치하는 항목을 찾는다.</p><p>이 작업은 부팅 시에 <code>KiInitializeXSave</code>가 호출하는 <code>KiIntersectFeaturesWithPolicy</code> 함수에서 수행된다. 이 함수는 <code>KiLoadPolicyFromImage</code> 를 호출하여 적절한 XState 정책을 로드하고 <code>KiGetProcessorInformation</code>을 호출하여 CPU의 데이터를 가져온 다음 XState 구성에서 현재 활성화된 각 기능 비트의 유효성을 <code>KiIsXSaveFeatureAllowed</code> 호출을 통해 확인한다.</p><p>이러한 기능은 <code>HwPolicy.sys</code> 드라이버의 리소스 101에서 작동하며 구조는 다음과 같다.</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSAVE_POLICY</span></span><span class="hljs-class">&#123;</span>    ULONG Version;    ULONG Size;    ULONG Flags;    ULONG MaxSaveAreaLength;    ULONGLONG FeatureBitmask;    ULONG NumberOfFeatures;    XSAVE_FEATURE Features[<span class="hljs-number">1</span>];&#125; XSAVE_POLICY, *PXSAVE_POLICY;</code></pre><p>예를 들어,  <code>19H1</code> 시스템에서 리소스 해커로 추출한 내용은 다음과 같다.</p><pre><code class="hljs c">dx @$policy = (_XSAVE_POLICY*)<span class="hljs-number">0x253d0e90000</span>[+<span class="hljs-number">0x000</span>] Version       : <span class="hljs-number">0x3</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x004</span>] Size          : <span class="hljs-number">0x2fd8</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x008</span>] Flags         : <span class="hljs-number">0x9</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x00c</span>] MaxSaveAreaLength : <span class="hljs-number">0x2000</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x010</span>] FeatureBitmask   : <span class="hljs-number">0x7fffffffffffffff</span> [Type: <span class="hljs-keyword">unsigned</span> __int64][+<span class="hljs-number">0x018</span>] NumberOfFeatures : <span class="hljs-number">0x3f</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x020</span>] Features      [Type: _XSAVE_FEATURE [<span class="hljs-number">1</span>]]</code></pre><p>각 <code>XSAVE_FEATURE</code>에 대해 각각 CPU 공급 업체 문자열이 있는 <code>XSAVE_VENDOR</code> 구조의 배열을 포함하는 <code>XSAVE_VENDORS</code> 구조에 대한 오프셋과 (지금은 각각 “GenuineIntel”, “AuthenticAMD” 또는 “CentaurHauls”) <code>XSAVE_CPU_ERRATA</code> 구조에 대한 오프셋을 확인할 수 있다. 예를 들어, <code>19H1</code> 테스트 시스템에는 기능 0에 대한 다음 정보가 존재한다.</p><pre><code class="hljs c">dx -r4 @$vendor = (XSAVE_VENDORS*)((<span class="hljs-keyword">int</span>)@$policy-&gt;Features[<span class="hljs-number">0</span>].Vendors + <span class="hljs-number">0x253d0e90000</span>)[+<span class="hljs-number">0x000</span>] NumberOfVendors  : <span class="hljs-number">0x3</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x008</span>] Vendor        [Type: _XSAVE_VENDOR [<span class="hljs-number">1</span>]]    [<span class="hljs-number">0</span>]           [Type: _XSAVE_VENDOR]        [+<span class="hljs-number">0x000</span>] VendorId      [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> [<span class="hljs-number">3</span>]]            [<span class="hljs-number">0</span>]           : <span class="hljs-number">0x756e6547</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]            [<span class="hljs-number">1</span>]           : <span class="hljs-number">0x49656e69</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]            [<span class="hljs-number">2</span>]           : <span class="hljs-number">0x6c65746e</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x010</span>] SupportedCpu  [Type: _XSAVE_SUPPORTED_CPU][+<span class="hljs-number">0x000</span>] CpuInfo       [Type: XSAVE_CPU_INFO][+<span class="hljs-number">0x020</span>] CpuErrata     : <span class="hljs-number">0x4c0</span> [Type: XSAVE_CPU_ERRATA *][+<span class="hljs-number">0x020</span>] Unused        : <span class="hljs-number">0x4c0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]</code></pre><p>마지막으로, 각 <code>XSAVE_CPU_ERRATA</code> 구조체는 지정된 XState 지원에 대한 오류 정보와 일치하는 프로세서 정보 데이터를 포함한다. 예를 들어, 테스트 시스템에서 위의 오프셋에서 첫 번째 에라타는 다음과 같다.</p><pre><code class="hljs c">dx -r3 @$errata = (XSAVE_CPU_ERRATA*)((<span class="hljs-keyword">int</span>)@$vendor-&gt;Vendor[<span class="hljs-number">0</span>].SupportedCpu.CpuErrata + <span class="hljs-number">0x253d0e90000</span>)    [+<span class="hljs-number">0x000</span>] NumberOfErrata   : <span class="hljs-number">0x1</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x008</span>] Errata           [Type: XSAVE_CPU_INFO [<span class="hljs-number">1</span>]]        [<span class="hljs-number">0</span>]              [Type: XSAVE_CPU_INFO]            [+<span class="hljs-number">0x000</span>] Processor        : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>]            [+<span class="hljs-number">0x002</span>] Family           : <span class="hljs-number">0x6</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x004</span>] Model            : <span class="hljs-number">0xf</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x006</span>] Stepping         : <span class="hljs-number">0xb</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x008</span>] ExtendedModel    : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x00c</span>] ExtendedFamily   : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]            [+<span class="hljs-number">0x010</span>] MicrocodeVersion : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]            [+<span class="hljs-number">0x018</span>] Reserved         : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]</code></pre><p>모든 XState 기능에 대한 시스템의 하드웨어 정책 덤프 툴은 <a href="https://github.com/yardenshafir/cet-research/tree/master/Xpolicy">여기</a>에서 사용할 수 있다. 지금은 전체 정책(위에 표시된 것)에 하나의 에라타만 나타난다.</p><p>마지막으로 다음 옵션 로더 명령줄 옵션(및 각 BCD 설정)을 사용하여 XState 기능을 추가로 커스터마이징이 가능하다.</p><ol><li><code>XSAVEPOLICY = n</code> 로드 옵션은 <code>xsavepolicy</code> BCD 옵션을 통해 설정되며 <code>KeXSavePolicyId</code>를 설정하여 로드할 XState 정책을 나타낸다.</li><li><code>XSAVEREMOVEFEATURE = n</code>로드 옵션은 <code>xsaveremovefeature</code> BCD옵션을 통해 설정되며 <code>KeTestRemovedFeatureMask</code> 를 설정한다. 이는 나중에 <code>KiInitializeXSave</code>에 의해 구문 분석되고 지정된 상태 비트를 제거한다. 상태 0 (x87 FPU) 및 상태 1 (SSE)은 이 방법으로 제거할 수 없다.</li><li><code>XSAVEDISABLE</code> 로드 옵션은 <code>xsavedisable</code> BCD 옵션을 통해 설정되어 <code>KeTestDisableXsave</code>를 설정하고 <code>KiInitializeXSave</code>가 모든 XState 구성 데이터를 0으로 설정하여 전체 XState 기능을 비활성화한다.</li></ol><h2 id="CET-XSAVE-영역-포맷"><a href="#CET-XSAVE-영역-포맷" class="headerlink" title="CET XSAVE 영역 포맷"></a>CET XSAVE 영역 포맷</h2><p>CET 구현의 일환으로 Intel은 <code>XSTATE_CET_U(11)</code>와 <code>XSTATE_CET_S(12)</code>라고 하는 두 개의 새로운 비트를 사용자 및 슈퍼바이저 상태에 각각 대응하도록 정의했다. 첫 번째 상태는 <code>XSAVE_CET_U_FORMAT</code>으로 문서화된 16바이트 데이터 구조로, <code>IA32_U_CET</code> MSR(<code>Shadow Stack Enable</code> 플래그가 구성된 경우) 및 <code>IA32_PL3_SSPMSR</code> (Privile 3 수준)을 포함한다. 아직 MSDN 정의가 없는 두 번째 방법은 <code>IA32_PL0/1/2_SSP</code> MSR을 포함한다.</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSAVE_CET_U_FORMAT</span></span><span class="hljs-class">&#123;</span>    ULONG64 Ia32CetUMsr;    ULONG64 Ia32Pl3SspMsr;&#125; XSAVE_CET_U_FORMAT, *PXSAVE_CET_U_FORMAT;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSAVE_CET_S_FORMAT</span></span><span class="hljs-class">&#123;</span>    ULONG64 Ia32Pl0SspMsr;    ULONG64 Ia32Pl1SspMsr;    ULONG64 Ia32Pl2SspMsr;&#125; XSAVE_CET_S_FORMAT, *PXSAVE_CET_S_FORMAT;</code></pre><p>필드 이름에서 알 수 있듯이 CET 관련 레지스터는 실제로 각 MSR에 저장된 값이며, 일반적으로 Ring 0의 RDMSR 및 WRMSR 권한이 있는 명령을 통해서만 액세스 할 수 있다. 그러나 프로세서 전역 데이터를 저장하는 대부분의 MSR과 달리 CET는 스레드 단위로 활성화할 수 있으며 Shadow stack pointer도 스레드 단위로 사용할 수 있다. 이러한 이유로 CET 관련 데이터는 운영 체제가 스레드 스위치를 올바르게 처리할 수 있도록 XState 기능의 일부로 구현되어야 한다.</p><p>CET 레지스터는 기본적으로 커널 코드로만 수정 가능한 MSR이기 때문에 <code>CPL3 XSAVE/XRSTOR</code> 명령을 통해 접근할 수 없으며 각각의 상태 비트는 <code>IA32_XSS</code> MSR에서 항상 1로 설정된다. 그러나 운영체제가 유저 모드의 코드가 SSP를 수정하는 것을 완전히 차단할 수는 없다. 유저 모드의 코드는 예외 처리, unwinding, jmp/longjmp 또는 Windows의 <code>Fiber</code> 메커니즘과 같은 특정 기능을 사용해 SSP를 업데이트할 수 있다.</p><p>따라서 Windows가 CS 및 DR7과 같은 특정 보호된 CPU 레지스터를 업데이트하는 메커니즘으로 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext</a>를 제공하는 것처럼 운영 체제는 스레드가 시스템 호출을 통해 XSate에서 CET 상태를 수정할 수 있는 방법을 제공해야 한다. 따라서 다음 섹션에서는 XState 관련 정보를 지원하기 위해 현대의 Windows 버전에서 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_context">CONTEXT</a> 구조가 CONTEXT_EX 구조로 어떻게 발전했는지, 그리고 예외 관련 시나리오에 대해 CET 관련 처리를 추가하는 동시에 손상된 CONTEXT를 통한 악의적인 제어 흐름 공격을 방지하는 방법에 대해서 알아본다.</p><h1 id="CONTEXT-EX-내부"><a href="#CONTEXT-EX-내부" class="headerlink" title="CONTEXT_EX 내부"></a>CONTEXT_EX 내부</h1><p>콘텍스트 스위치를 할 때 저장해야 하는 레지스터의 수가 점점 늘어나고, 이를 지원하기 위해 새로운 버전의 Windows는 레거시 CONTEXT 구조 외에도 CONTEXT_EX 구조를 도입했다. CONTEXT_EX는 레거시 CONTEXT가 고정 크기인 반면 XSAVE는 스레드, 프로세서 및 시스템 구성 정책에 따라 동적으로 크기가 조정되는 프로세서 상태 구조가 필요하기 때문에 도입되었다.</p><h2 id="CONTEXT-EX-구조"><a href="#CONTEXT-EX-구조" class="headerlink" title="CONTEXT_EX 구조"></a>CONTEXT_EX 구조</h2><p>CONTEXT_EX는 현재 커널 및 유저 모드 예외 처리 기능 전체에서 사용되지만 CONTEXT_EX 구조의 대부분은 문서화되지 않았다. Windows 7 헤더 파일 및 일부 intel의 reference code에 존재하는 일부 정보가 실수로 공개되지 않도록 했음을 알 수 있다. 다음 코드의 주석을 보고 이해할 수 있는 것이 있으면 알려주었으면 한다.</p><pre><code class="hljs c"><span class="hljs-comment">//</span><span class="hljs-comment">// 이 구조체는 CONTEXT_EX의 단일 청크 크기와 오프셋(CONTEXT_EX 구조 시작부터)을 지정한다.</span><span class="hljs-comment">// N.B. 오프셋은 음수일 수 있다.</span><span class="hljs-comment">//</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONTEXT_CHUNK</span></span><span class="hljs-class">&#123;</span>    LONG Offset;    DWORD Length;&#125; CONTEXT_CHUNK, *PCONTEXT_CHUNK;<span class="hljs-comment">// CONTEXT_EX 구조체는 는 CONTEXT 구조체의 확장이다. </span><span class="hljs-comment">// 콘텍스트 레코드를 프로세서 상태의 일부를 포함하는 분리된 가변크기 버퍼(청크) 세트로 </span><span class="hljs-comment">// 정의한다. 현재 두 개의 버퍼(청크)만 정의된다:</span><span class="hljs-comment">//</span><span class="hljs-comment">// - 기존 CONTEXT 구조를 저장하는 레거시</span><span class="hljs-comment">// - XSAVE 저장 영역 버퍼를 저장하는 XState</span><span class="hljs-comment">// XSAVE_AREA_HEADER, i.e. without the first 512 bytes.</span><span class="hljs-comment">//</span><span class="hljs-comment">// PCONTEXT 포인터를 PCONTEXT_EX 포인터로 변환하는 몇 가지 가정이 있다.</span><span class="hljs-comment">//</span><span class="hljs-comment">// 1. PCONTEXT 포인터와 함께 작동하는 API는 CONTEXT_EX가 CONTEXT 구조 바로 뒤에 저장된다고 가정</span><span class="hljs-comment">//    또한 CONTEXT_EX는 해당 CONTEXT_XXX 플래그가 CONTEXT.ContextFlags에 설정된 경우에만 존재한다고 가정</span><span class="hljs-comment">//</span><span class="hljs-comment">// 2. CONTEXT_EX 구조가 있으면 레거시가 항상 존재</span><span class="hljs-comment">//</span><span class="hljs-comment">// 3. CONTEXT.ContextFlags는 존재하는 청크를 정의</span><span class="hljs-comment">//    즉 CONTEXT_XSTATE가 설정된 경우 CONTEXT_EX.XState가 유효하다.</span><span class="hljs-comment">//</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONTEXT_EX</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// 오프셋이 가장 작은 청크에서 시작하는 구조체의 총 크기</span>    <span class="hljs-comment">// N.B. 오프셋은 음수일 수 있다.</span>    <span class="hljs-comment">//</span>    CONTEXT_CHUNK All;    <span class="hljs-comment">// </span>    <span class="hljs-comment">// 기존의 CONTEXT 구조 wrapper</span>    <span class="hljs-comment">// N.B. 청크의 크기는 sizeof(CONTEXT) 보다 작을 수 있다.</span>    <span class="hljs-comment">// (CONTEXT_EXTENDED_REGISTERS가 x86에 설정되지 않은 경우).    </span><span class="hljs-comment">// CONTEXT_CHUNK Legacy;</span>    <span class="hljs-comment">//</span>  <span class="hljs-comment">// CONTEXT_XSTATE : 확장된 프로세서 상태 청크. 상태 저장은 동일한 형식 </span>  <span class="hljs-comment">// XSAVE 작업은 처음 512 바이트를 제외하고 XSAVE_AREA_HEADER에서 시작한다. </span><span class="hljs-comment">// FP 및 SSE 상태에 해당하는 하위 2 비트는 0이어야 한다.</span>    <span class="hljs-comment">// CONTEXT_CHUNK XState;</span>&#125; CONTEXT_EX, *PCONTEXT_EX;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONTEXT_EX_LENGTH ALIGN_UP_BY(sizeof(CONTEXT_EX), STACK_ALIGN)</span><span class="hljs-comment">//</span><span class="hljs-comment">// 이 매크로를 사용해 콘텍스트 청크를 더 쉽게 조작 가능</span><span class="hljs-comment">//</span></code></pre><p>따라서 이 헤더로 CONTEXT_EX 구조의 레이아웃을 이해하고 시각화할 수 있을 때까지 여러 차례 시도를 했고 다음 다이어그램이 도움이 될 수 있다고 느꼈다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/4.png"></p><p>다이어그램에서 CONTEXT_EX 구조는 항상 CONTEXT 구조의 끝에 있으며 레거시 및 XState라는 <code>CONTEXT_CHUNK</code> 유형의 3개 필드가 있다. 이들은 오프셋과 데이터의 크기를 정의하고 적절한 데이터 포인터를 검색하기 위한 다양한 <code>RTL_</code> 매크로가 존재한다.</p><p>Legacy 필드는 기존 CONTEXT 구조의 시작을 참조한다. (<code>CONTEXT_EXTENDED_REGISTERS</code>가 제공되지 않으면 x86에서 크기가 더 작을 수 있음) <code>All</code> 필드는 기존 CONTEXT 구조의 시작을 참조하지만 Length는 CONTEXT_EX와 XSAVE 영역에 필요한 패딩/정렬 공간을 포함하여 모든 데이터의 크기를 나타낸다. 마지막으로 <code>XState</code> 필드는 <code>XSAVE_AREA_HEADER</code> 구조 (상태 비트가 활성화되어 데이터가 있는 상태 마스크를 정의함)와 전체 XSAVE 영역의 크기를 참조한다. 이 레이아웃으로 인해 All 및 Legacy에는 음수 오프셋이 적용된다는 점에 유의해야 한다.</p><p>기능이 매우 복잡하기 때문에 <code>Ntdll.dll</code>은 CONTEXT_EX에 저장된 다양한 데이터의 빌드, 읽기, 복사 및 조작을 단순화하기 위해 다양한 API를 export 한다. (이러한 API 중 일부는 <code>Ntoskrn.exe</code> 에서 내부적으로 사용되지만 export 되지는 않는다.) 또한 <code>KernelBase.dll</code>은 이러한 기능을 내부적으로 사용하는 문서화된 Win32 함수를 export 한다.</p><h2 id="CONTEXT-EX-초기화"><a href="#CONTEXT-EX-초기화" class="headerlink" title="CONTEXT_EX 초기화"></a>CONTEXT_EX 초기화</h2><p>먼저 호출자는 CONTEXT_EX를 저장하기 위해 할당할 메모리 크기를 파악해야 하는데, 이는 다음 API를 사용하여 수행할 수 있다.</p><pre><code class="hljs c">NTSYSAPIULONGNTAPIRtlGetExtendedContextLength (    _In_ ULONG ContextFlags,    _Out_ PULONG ContextLength);</code></pre><p>호출자는 저장할 레지스터를 지정하기 위해 적절한 <code>CONTEXT_XXX</code> 플래그를 제공해야 한다. 그런 다음이 API는 <code>SharedUserData.XState.EnabledFeatures</code> 및 <code>SharedUserData.XState.EnabledUserVisibleSupervisorFeatures</code> 를 읽고 모든 비트를 통합해 아래의 확장 함수로 전달한다.</p><pre><code class="hljs c">NTSYSAPIULONGNTAPIRtlGetExtendedContextLength2 (    _In_ ULONG ContextFlags,    _Out_ PULONG ContextLength,    _In_ ULONG64 XStateCompactionMask);</code></pre><p>이 최신 API를 사용하면 공유 사용자 데이터의 XState 구성에서 모든 활성화된 기능을 가져오는 대신 실제로 저장할 XState 상태를 수동으로 지정할 수 있다. 이로 인해 CONTNENT_EX 구조의 크기가 작아져 모든 XState 데이터를 저장할 공간이 충분하지 않게 되므로 이 CONTNT_EX를 나중에 사용하면 지정된 마스크 외부에서 XState Bits를 사용하지 않아야 한다.</p><p>다음으로 호출자는 CONTEXT_EX에 메모리를 할당하고 (대부분의 경우 Windows는 예외 경로에서 메모리 할당 실패를 방지하기 위해 <code>alloca</code>를 사용한다.) 다음 두 API 중 하나를 사용한다.</p><pre><code class="hljs c">NTSYSAPIULONGNTAPIRtlInitializeExtendedContext (    _Out_ PVOID Context,    _In_ ULONG ContextFlags,    _Out_ PCONTEXT_EX* ContextEx);NTSYSAPIULONGNTAPIRtlInitializeExtendedContext2 (    _Out_ PVOID Context,    _In_ ULONG ContextFlags,    _Out_ PCONTEXT_EX* ContextEx,    _In_ ULONG64 XStateCompactionMask);</code></pre><p>이전과 마찬가지로 최신 API에서는 압축된 형식으로 저장할 XState 상태를 수동으로 지정할 수 있다. 지정하지 않으면 사용 가능한 모든 기능 (<code>SharedUserData</code> 기반)이 있는 것으로 간주된다.  호출자는 <code>RtlGetExtendedContextLength(2)</code>에 대한 호출과 동일한 <code>ContextFlags</code>를 지정해 콘텍스트 구조가 올바른 크기로 할당되었는지 확인해야 한다. 이후 호출자는 입력 CONTEXT 버퍼를 따라갈 것으로 예상되는 CONTEXT_EX 구조의 포인터를 받는다.</p><p>CONTEXT_EX가 존재하면 호출자는 먼저 레거시 CONTEXT 구조를 가져올 수 있다. (크기에 대한 가정 없이). 다음 API로 수행할 수 있다.</p><pre><code class="hljs c">NTSYSAPIPCONTEXTNTAPIRtlLocateLegacyContext (    _In_ PCONTEXT_EX ContextEx,    _Out_opt_ PULONG Length,);</code></pre><p>그러나 이전에 언급했듯이 이들은 Windows의 NT 계층에 의해 노출되는 문서화되지 않은 내부 API다. 일반적인 Win32 응용 프로그램은 다음 함수를 사용하여 XState 호환 CONTEXT 구조의 사용을 단순화한다.</p><pre><code class="hljs c">WINBASEAPIBOOLWINAPIInitializeContext (    _Out_writes_bytes_opt_(*ContextLength) PVOID Context,    _In_ DWORD ContextFlags,    _Out_ PCONTEXT_EX Context,    _Inout_ PDWORD ContextFlags);WINBASEAPIBOOLWINAPIInitializeContext2 (    _Out_writes_bytes_opt_(*ContextLength) PVOID Context,    _In_ DWORD ContextFlags,    _Out_ PCONTEXT_EX Context,    _Inout_ PDWORD ContextFlags,    _In_ ULONG64 XStateCompactionMask);</code></pre><p>이 두 API는 문서화되지 않은 API와 비슷하게 작동한다. 호출자가 Buffer 및 Context 매개 변수로 처음 NULL을 전달하면 함수는 <code>ContextLength</code>에 필요한 길이를 반환하며 호출자는 메모리에 할당한다. 두 번째 시도에서 호출자는 할당된 포인터를 Buffer에 전달하고 기본 CONTEXT_EX 구조에 대한 정보 없이 Context의 CONTEXT 구조에 대한 포인터를 받는다.</p><h2 id="CONTEXT-EX에서-XState-기능-마스크-제어"><a href="#CONTEXT-EX에서-XState-기능-마스크-제어" class="headerlink" title="CONTEXT_EX에서 XState 기능 마스크 제어"></a>CONTEXT_EX에서 XState 기능 마스크 제어</h2><p>CONTEXT_EX의 <code>XSAVE_AREA_HEADER</code>의 Mask 필드에 포함된 <code>XSTATE_BV</code> (확장 기능 마스크)에 액세스 하기 위해 시스템은  XState 마스크를 수정하기 위한 API와 함께 CONTEXT_EX에서 어떤 XState 기능이 활성화되어 있는지 쉽게 확인할 수 있도록 두 개의 API를 export 한다.</p><p>그러나 Windows는 XSAVE 영역에 x87 FPU (0) 및 SSE (1) 상태를 저장하지 않고 대신 <code>FXSAVE</code> 명령을 사용한다. 즉, XSAVE 영역에 레거시 영역이 포함되지 않고 즉시 <code>XSAVE_AREA_HEADER</code>로 시작된다. 이로 인해 Get API는 항상 하위 2 비트를 마스킹한다. 또한 Set API는 지정된 기능이 XState 구성의 <code>EnabledFeatures</code>에 있는지 확인한다.</p><p><code>InitializeContext2</code>(또는 내부 네이티브 APIs)에서 하드 코딩된 압축 마스크가 지정된 경우 Set API를 사용하여 기존 상태 비트를 생략해서는 안된다. (새 비트를 추가하면 CONTEXT_EX에 초기화되지 않은 추가 상태 데이터가 포함되므로 이 데이터 없이 이미 사전 할당되었을 것이다.)</p><pre><code class="hljs c">NTSYSAPIULONG64NTAPIRtlGetExtendedFeaturesMask (    _In_ PCONTEXT_EX ContextEx);NTSYSAPIULONG64NTAPIRtlSetExtendedFeaturesMask (    _In_ PCONTEXT_EX ContextEx,    _In_ ULONG64 FeatureMask);</code></pre><p>위 API의 문서화된 형식은 다음과 같다.</p><pre><code class="hljs c">WINBASEAPIBOOLWINAPIGetXStateFeaturesMask (    _In_ PCONTEXT Context    _Out_ PDWORD64 FeatureMask);NTSYSAPIULONG64NTAPISetXStateFeaturesMask (    _In_ PCONTEXT Context,    _In_ DWORD64 FeatureMask);</code></pre><h2 id="CONTEXT-EX에서-XState-기능-찾기"><a href="#CONTEXT-EX에서-XState-기능-찾기" class="headerlink" title="CONTEXT_EX에서 XState 기능 찾기"></a>CONTEXT_EX에서 XState 기능 찾기</h2><p>CONTEXT_EX 구조의 복잡성과 XState 기능이 압축되거나 압축되지 않은 형태로 존재할 수 있고 존재 여부도 앞서 설명한 다양한 상태 마스크에 의존한다는 사실 (특히 최적화된 XSAVE가 지원되는 경우)로 인해, 호출자는 CONTEXT_EX 내의 XSAVE 영역에서 관련 상태 데이터에 대한 포인터를 쉽고 빠르게 얻기 위한 라이브러리 함수가 필요하다.</p><p>현재 다음과 같은 두 가지 함수가 존재한다. <code>RtlLocateExtendedFeature</code>는 <code>RtlLocateExtendedFeature2</code>의 wrapper이며 구성 매개 변수로 <code>SharedUserData.XState</code>에 대한 포인터를 제공한다. 두 함수 모두 export 할 때 호출자가 선택한 경우 후자의 API에서 자체 사용자 지정 XState 구성을 수동으로 지정할 수도 있다.</p><pre><code class="hljs c">NTSYSAPIPVOIDNTAPIRtlLocateExtendedFeature (    _In_ CONTEXT_EX ContextEx,    _In_ ULONG FeatureId,    _Out_opt_ PULONG Length);NTSYSAPIPVOIDNTAPIRtlLocateExtendedFeature2 (    _In_ CONTEXT_EX ContextEx,    _In_ ULONG FeatureId,    _In_ PXSTATE_CONFIGURATION Configuration,    _Out_opt_ PULONG Length);</code></pre><p>두 함수 모두 CONTEXT_EX 구조와 요청된 기능의 ID를 수신하고 기능이 XSAVE 영역에 저장된 위치에 대한 포인터를 반환하기 위해 XState 구성 데이터를 구문 분석한다. 지정된 기능에 대한 실제 값을 확인하거나 반환하지 않으며 이는 호출자에게 달려 있다.</p><p>포인터를 찾기 위해 <code>RtlLocateExtendedFeature2</code>는 다음을 수행한다:</p><ul><li>기능 ID가 2 이상 (x87 FPU 및 SSE 상태는 Windows의 XSAVE를 통해 저장되지 않으므로) 및 64 (가능한 가장 높은 XState 기능 비트) 미만인지 확인한다.</li><li>CONTEXT_EX + <code>CONTEXT_EX.XState.Offset</code>에서 <code>XSAVE_AREA_HEADER</code>를 가져온다.</li><li><code>Configuration</code>-&gt; <code>ControlFlags.CompactionEnabled</code> 플래그에서 압축을 사용하는지 여부를 알 수 있다.</li><li>압축되지 않은 형식을 사용하는 경우 :<ul><li><code>Configuration</code>-&gt; <code>Features[n].Offset</code> 및 <code>.Size</code>를 읽고 XSAVE 영역에서 요청된 기능의 오프셋 및 크기를 저장한다.</li></ul></li><li>압축된 형식을 사용하는 경우 :<ul><li><code>XSAVE_AREA_HEADER</code> (<code>XCOMP_BV</code>에 해당)에서 <code>CompactionMask</code>를 읽고 요청된 기능이 포함되어 있는지 확인한다.</li><li><code>Configuration</code>-&gt; <code>AllFeatures</code>를 읽고 상태 비트가 요청된 기능 ID 앞에 오는 모든 활성화된 상태의 크기를 저장하고 이러한 크기를 더하여 요청된 형식의 오프셋을 계산한 뒤 각 이전 상태 영역의 시작 부분을 64byte로 정렬한다. 해당 비트가 <code>Configuration</code>-&gt; <code>AlignedFeatures</code>에 설정된 경우 마지막으로 필요한 경우 지정된 기능 ID에 대한 영역의 시작을 정렬한다.</li><li><code>Configuration.AllFeatures[n]</code>에서 요청된 기능의 크기를 읽는다.</li></ul></li><li>위에서 계산된 오프셋을 기반으로 XSAVE 영역에서 기능을 찾고 선택적으로 출력 길이 변수의 해당 크기와 함께 해당 크기에 대한 포인터를 반환한다.</li></ul><p>즉, 압축되지 않은 형식으로 특정 기능의 주소를 찾으려면 <code>SharedUserData</code>에서 프로세서에서 지원하는 기능을 확인하는 것으로 충분하다. 그러나 압축된 형식에서는 <code>SharedUserData</code>의 오프셋에 의존할 수 없으므로 스레드에서 활성화된 기능을 확인하고 이전 기능의 모든 크기를 기반으로 오프셋을 계산해야 한다.</p><p>일반적인 Win32 응용 프로그램에서는 내부적으로 위의 기본 API를 호출하지만 일부 사전 처리가 있는 다른 API가 사용되기도 한다. 상태 비트 0과 1은 CONTEXT_EX에서 XSAVE 영역의 일부로 저장되지 않으므로 Win32 API는 적절한 레거시 CONTEXT 필드 (즉, <code>XSTATE_LEGACY_FLOATING_POINT</code>의 경우 FltSave, <code>XSTATE_LEGACY_SSE</code>의 경우 Xmm0)에서 이러한 두 기능 비트를 가져와 처리한다.</p><pre><code class="hljs c">WINBASEAPIPVOIDWINAPILocateXStateFeature (    _In_ CONTEXT_EX Context,    _In_ DWORD FeatureId,    _Out_opt_ PDWORD Length);</code></pre><h2 id="예제-사용과-출력"><a href="#예제-사용과-출력" class="headerlink" title="예제 사용과 출력"></a>예제 사용과 출력</h2><p>CONTEXT_EX 데이터 구조와 결합된 경우 XState 내부를 이해하기 위해 간단한 <a href="https://github.com/yardenshafir/cet-research/tree/master/Xpolicy">테스트 프로그램</a>을 작성했다. 이 유틸리티는 일부 API 사용과 관련된 다양한 오프셋, 크기 및 동작을 보여준다. 다음은 AVX, MPX 및 Intel PT가 있는 시스템에서 프로그램 (AVX 레지스터 사용)의 출력이다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/5.png"></p><p>무엇보다도 레거시 CONTEXT가 음수인 오프셋에 있는 경우 예상대로 시스템이 x87 FPU 상태(1) 및 GSE 상태(2)를 지원하더라도 <code>XSAVEBV</code>에는 이러한 비트가 포함되어 있지 않으므로 레거시 콘텍스트 영역에 저장된다. (따라서 관련 상태 데이터의 음수 오프셋에 유의해야 함) <code>0x40</code> 바이트 크기인 XSAVE 헤더 (오프셋 <code>0x30</code>에서 시작) 다음에 AVX 상태(2)는 오프셋 <code>0x70</code>에서 시작한다.</p><h1 id="CONTEXT-EX-유효성-검사"><a href="#CONTEXT-EX-유효성-검사" class="headerlink" title="CONTEXT_EX 유효성 검사"></a>CONTEXT_EX 유효성 검사</h1><p>유저 모드 API는 결국 커널에 의해 처리되고 XSAVE 영역의 권한 있는 부분 (즉, CET 상태 데이터)을 수정하는 CONTEXT_EX를 구성할 수 있으므로 Windows는 CONTEXT_EX를 허용하는 API를 통한 바람직하지 않은 수정을 방지해야 한다. 예를 들어 :</p><ul><li><code>NtContinue</code> : 예외 후 재개하는 데 사용되며 longjmp CRT 기능을 처리하고 스택 해제를 수행한다.</li><li><code>NtRaiseException</code> : 기존 스레드에 예외를 삽입하는 데 사용됨</li><li><code>NtQueueUserApc</code> : 기존 스레드의 실행 흐름을 가로채는 데 사용됨</li><li><code>NtSetContextThread</code> : 기존 스레드의 프로세서 레지스터 / 상태를 수정하는 데 사용됨</li></ul><p>이러한 시스템 호출로 인해 커널이 <code>IA32_PL3_SSP</code> 또는 <code>IA32_CET_U</code> MSR을 수정하고 RIP를 조작할 수 있으므로 Windows는 전달된 CONTEXT_EX가 CET 보증을 위반하지 않는지 확인해야 한다.</p><p><code>19H1</code>에 SSP를 검증하고 <code>20H1</code>에 RIP 검증을 추가하는 방법을 곧 다룰 예정이다. 하지만 먼저 <code>NtContinue</code>의 오용 가능성을 줄이기 위해 작은 리팩터링을 수행해야 했다. 바로 <code>NtContinueEx</code> 함수의 도입이다.</p><h2 id="NtContinueEX-및-KCONTINUE-ARGUMENT"><a href="#NtContinueEX-및-KCONTINUE-ARGUMENT" class="headerlink" title="NtContinueEX 및 KCONTINUE_ARGUMENT"></a>NtContinueEX 및 KCONTINUE_ARGUMENT</h2><p>위에서 설명한 대로 <code>NtContinue</code>의 기능은 여러 상황에서 사용되며, CET가 프로세서 상태에 대한 임의 변경을 허용하는 API에서 기존 상태를 복원할 수 있으려면 인터페이스에 더 세밀한 제어가 추가되어야 했다. 이 작업은 <code>KCONTINUE_TYPE</code>이라는 새 enumeration의 생성을 통해 수행되었으며, <code>KCONTINUE_ARGUMENT</code> 데이터 구조에 현재 <code>NtContinue</code>에서 <code>NtContinueEx</code>로 향상된 버전으로 전달되어야 한다.</p><p>이 데이터 구조에는  <code>ContinueFlags</code> 필드가 추가되었다. 이 필드는  <code>NtContinue</code>의 원래 <code>TestAlert</code> 인수를 <code>CONTINUE_FLAG_RAISE_ALERT (0x1)</code> 플래그로 대체하는 동시에 새로운 TrapFrame으로 APC를 직접 전달하는<code>CONTINUE_FLAG_BYPASS_CONTEXT_COPY (0x2)</code> 플래그도 도입되었다. 이것은 CONTEXT 레코드 포인터가 사용자 스택의 특정 위치에 있는지 확인하여 이전에 구현된 최적화로, 함수가 사용자 모드 APC 전달의 일부로 사용되고 있다고 가정할 수 있다.  이 동작을 원하는 호출자는 <code>ContinueFlags</code>에서 플래그를 명시적으로 설정해야 한다.</p><p>이전 인터페이스는 레거시로 계속 지원되지만 내부적으로는 입력 매개 변수를 <code>KCONTINUE_ARGUMENT</code>가 아닌 <code>BOOLEAN TestAlert</code> 매개 변수로 인식하는 <code>NtContinueEx</code>를 호출한다. 이러한 경우는 새 인터페이스에서 <code>KCONTINUE_UNWIND</code>로 처리된다.</p><p>위 리팩터링의 일부로 다음 네 가지 가능한 유형이 있다.</p><ul><li><code>KCONTINUE_UNWIND</code> – 예외에서 해제할 때 사용되는 <code>RtlRestoreContext</code> 및 <code>LdrInitializeThunk</code>와 같은 <code>NtContinue</code>의 레거시 호출자가 사용</li><li><code>KCONTINUE_RESUME</code> – <code>NtContinueEx</code>를 다시 호출하기 전에 <code>KiUserApcDispatcher</code>가 실행할 유저 모드 스택에 <code>KCONTINUE_ARGUMENT</code> 구조를 빌드할 때 <code>KiInitializeUserApc</code>가 사용</li><li><code>KCONTINUE_LONGJUMP</code> – 예외 레코드의 예외 코드가 <code>STATUS_LONGJUMP</code> 인 경우 <code>RtlRestoreContext</code>에서 호출하는 <code>RtlContinueLongJump</code>에서 사용됨</li><li><code>KCONTINUE_SET</code> – <code>NtContinueEx</code>에 직접 전달되지 않고 <code>NtSetContextThread</code> API에 대한 응답으로 <code>PspGetSetContextInternal</code> 내에서 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>을 호출할 때 사용됨</li></ul><h2 id="SSP-Shadow-Stack-Pointer-유효성-검사"><a href="#SSP-Shadow-Stack-Pointer-유효성-검사" class="headerlink" title="SSP(Shadow Stack Pointer) 유효성 검사"></a>SSP(Shadow Stack Pointer) 유효성 검사</h2><p>앞서 언급했듯이 예외 해제, APC, longjmp 등과 같이 유저 모드 코드가 SSP를 변경해야 하는 경우가 있다. 그러나 운영 체제는 CET 우회 방지를 위해 SSP에 요청된 새 값을 검증해야 한다. 이는 <code>19H1</code>에서 새로운 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextXStateCetU.c">KeVerifyContextXStateCetU</a> 함수에 의해 구현되었다. 이 함수는 콘텍스트가 수정되는 스레드와 스레드의 새 콘텍스트를 수신하고 다음을 수행한다.</p><ul><li>CONTEXT_EX에 XState 데이터가 포함되어 있지 않거나 XState 데이터에 CET 레지스터가 포함되지 않은 경우 (<code>XSTATE_CET_U</code> 상태 비트로 <code>RtlLocateExtendedFeature2</code>를 호출하여 확인) 유효성 검사가 필요하지 않다.</li><li>대상 스레드에서 CET가 활성화된 경우 :<ul><li>호출자가 <code>XSAVEBV</code>에서 <code>XSTATE_MASK_CET_U</code>를 마스킹하여 이 스레드에서 CET를 비활성화하는지 확인한다. 이 경우 함수는 상태 비트를 다시 활성화하고 <code>MSR_IA32_CET_SHSTK_EN</code> (CET의 섀도우 스택 기능을 활성화하는 플래그)을 <code>Ia32CetUMsr</code>에 설정하고 현재 섀도우 스택을 <code>Ia32Pl3SspMsr</code>로 설정한다.</li><li>반면에 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextXStateCetUEnabled.c">KiVerifyContextXStateCetUEnabled</a>를 호출하면 CET 섀도우 스택이 활성화되었는지, (<code>MSR_IA32_CET_SHSTK_EN</code> 활성화 여부) 새 SSP가 8byte로 정렬되었는지, 현재 SSP 값과 섀도우 스택 영역의 VAD 끝 사이에 있는지 확인한다. 스택이 거꾸로 성장하기 때문에 영역의 “끝”이 실제로 스택의 시작 주소이다. 따라서 스레드에 대한 새 콘텍스트를 설정할 때 모든 SSP 값은 스레드에서 지금까지 사용된 섀도우 스택 내에 있는 한 유효하다. 또한 스레드가 섀도우 스택 내부로 이동할 수 있는 범위에는 제한이 없다.</li></ul></li><li>CET가 대상 스레드에서 비활성화되고 호출자가 CONTEXT_EX의 <code>XSAVEBV</code>에 <code>XSTATE_CET_U</code> 마스크를 포함하여 활성화를 시도하는 경우 두 MSR 값이 모두 0으로 설정되도록 허용한다. (섀도우 스택 X, SSP X)</li></ul><p>위 유효성 검사에 실패하면 <code>STATUS_SET_CONTEXT_DENIED</code>가 반환되고 성공하면 <code>STATUS_SUCCESS</code>가 반환된다.</p><p>CET를 활성화하면 기존 Windows 8.1에서 CFG와 함께 구현된 Check Stack Extents도 암시적으로 활성화된다. 이것은 KPROCESS의 <code>ProcessFlags</code> 필드에 있는 <code>CheckStackExtents</code> 비트를 통해 확인할 수 있다. 즉, 대상 SSP가 유효성을 검사할 때마다 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextRecord.c">KeVerifyContextRecord</a> 또한 호출되고 대상 RSP가 현재 스레드의 TEB 사용자 스택 제한 (또는 이것이 WOW64 프로세스인 경우 TEB32의 사용자 스택 제한)의 일부인지 확인한다. <code>RtlGuardIsValidStackPointer</code> (및 <code>RtlGuardIsValidWow64StackPointer</code>)에 의해 구현된 이러한 검사는 이전에 <a href="https://medium.com/tenable-techblog/api-series-setthreadcontext-d08c9f84458d">Tenable</a> 및 <a href="https://blog.ensilo.com/atombombing-cfg-protected-processes">enSilo</a>의 연구원에 의해 문서화되었다.</p><h2 id="RIP-Instruction-Pointer-유효성-검사"><a href="#RIP-Instruction-Pointer-유효성-검사" class="headerlink" title="RIP(Instruction Pointer) 유효성 검사"></a>RIP(Instruction Pointer) 유효성 검사</h2><p><code>19030</code> 빌드 버전에 Intel CET를 사용하는 또 다른 기능인 호출자가 프로세스에 대해 설정하려는 새 RIP가 유효한지 확인하는 기능이 추가되었다. SSP 유효성 검사와 마찬가지로 이는 스레드에 대해 CET이 활성화된 경우에만 적용된다. 그러나 RIP 유효성 검사는 기본적으로 활성화되어 있지 않으며 프로세스에 대해 활성화되어야 한다. (EPROCESS의 <code>MitigationFlags2Values</code> 필드에 있는 <code>UserCetSetContextIpValidation</code> 비트로 표시됨).</p><p>즉, 현재 빌드의 경우 <code>CreateProcess</code>를 호출하고 <code>PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</code> 속성을 사용할 때 <code>PROCESS_CREATION_MITIGATION_POLICY2_CET_USER_SHADOW_STACKS_ALWAYS_ON</code> 플래그가 활성화되면 옵션이 설정되는 것으로 보인다. (CET는 프로세스 생성 시에만 활성화될 수 있으므로 <code>ProcessUserShadowStackPolicy</code> 값으로 <code>SetProcessMitgationPolicy</code> API를 호출하는 것은 유효하지 않다.)</p><p>그러나 흥미롭게도 새로운 mitigation 옵션인 <code>PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION (32)</code> 이 mitigation map에 추가되었다. 문서화되지 않은 이 mitigation을 토글 하면 <code>MitigationFlags2Values</code> 필드에서 <code>AuditUserCetSetContextIpValidation</code> 비트를 활성화한다. 또한 이것은 이제 32 번째 mitigation 옵션 (각각 DEFERRED / OFF / ON / RESERVED에 대해 4 비트를 차지함)이므로 132개의 mitigation 비트가 필요하며 <code>PS_MITIGATION_OPTIONS_MAP</code>는 Map 필드의 3개의 64 비트 배열 요소로 확장되었다.  (<code>PS_SYSTEM_DLL_INIT_BLOCK</code>의 크기에 대한 후속 효과가 있음)</p><p>새로운 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a> 함수는 스레드의 콘텍스트가 변경될 때마다 호출된다. 스레드에 대해 CET 및 RIP mitigation이 모두 활성화되어 있는지 확인하고 콘텍스트 매개 변수에 <code>CONTEXT_CONTROL</code> 플래그가 설정되어 있는지 확인한다. 즉, 이 새 콘텍스트에 의해 RIP가 변경됨을 의미한다. 모든 검사가 통과되면 내부 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextIpForUserCet.c">KiVerifyContextIpForUserCet</a> 함수를 호출한다. 이 함수의 목적은 대상 RIP가 유효한 값이고 익스플로잇이 임의 코드를 실행하는 데 사용하는 값이 아닌지 확인하는 것이다.</p><p>먼저 대상 RIP 주소가 커널 주소가 아니며 매핑되어서는 안 되는 하위 0x10000 바이트의 주소가 아닌지 확인한다. 그런 다음 대상 RIP가 유저 모드의 이전 주소인 경우를 허용하기 위해서 해당 기본 트랩 프레임을 검색하고 대상 RIP가 해당 트랩 프레임의 RIP인지 확인한다. 일반적으로 스레드에 대해 <code>NtSetThreadContext</code>가 처음 호출되고 RIP가 스레드의 초기 시작 주소로 설정될 때 발생하지만 일반적이지 않은 다른 경우에도 발생할 수 있다.</p><p>이 함수는 <code>KCONTINUE_TYPE</code>을 수신하고 해당 값에 따라 다양한 방식으로 대상 RIP를 처리한다. 대부분의 경우 섀도우 스택을 반복하고 대상 RIP를 검색하는데, 찾지 못하면 예외가 발생하며 예외 핸들러에 도달할 때까지 계속 실행된다. 예외 핸들러는 제공된 <code>KCONTINUE_TYPE</code>이 <code>KCONTINUE_UNWIND</code>인지 확인하고 <code>KCONTINUE_UNWIND</code> 플래그와 함께 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/RtlVerifyUserUnwindTarget.c">RtlVerifyUserUnwindTarget</a>을 호출하는지 확인한다. 이 기능은 다음 섹션에서 설명하는 더 복잡한 검사를 사용하여 RIP를 다시 확인한다.</p><p>다른 경우에는 <code>STATUS_SET_CONTEXT_DENIED</code>를 반환하여 EPROCESS에 <code>AuditUserCetSetContextIpValidation</code> 플래그가 설정된 경우 실패 검사를 위해 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>이 <code>KiLogUserCetSetContextIpValidationAudit</code>함수를 호출한다. 이 검사(auditing)는 일반적인 프로세스 mitigation ETW 채널을 통해 수행되는 대신 WER (Windows 오류보고) 서비스를 통해 빠른 실패 예외를 직접 발생시키는 방식으로 수행된다. (<code>FAST_FAIL_SET_CONTEXT_DENIED</code>로 설정된 정보로 <code>0xC000409</code> 예외를 전송). WER 스팸을 방지하기 위해 <code>AuditUserCetSetContextIpValidationLogged</code>라는 또 다른 EPROCESS 비트가 사용된다.</p><p>스레드가 종료되고 현재 섀도우 스택 주소가 페이지로 정렬된 경우 함수가 대상 RIP를 찾기 전에 섀도우 스택에 대한 루프를 중지하는 경우가 있다. 즉, 스레드를 종료할 때 함수는 최우선적으로 섀도우 스택의 현재 페이지에서만 대상 RIP를 확인한다. 해당 페이지에서 대상 RIP를 찾지 못하면 <code>STATUS_THREAD_IS_TERMINATING</code>을 반환한다.</p><p>함수는 <code>KCONTINUE_TYPE</code> 이 <code>KCONTINUE_LONGJUMP</code> 인 경우 대상 RIP가 섀도우 스택에 대해 검증되지 않지만 대신 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/RtlVerifyUserUnwindTarget.c">RtlVerifyUserUnwindTarget</a>이 <code>KCONTINUE_LONGJUMP</code> 플래그와 함께 호출되어 PE Image Load Configuration Directory의 <code>longjmp</code> 테이블에서 RIP를 확인한다. 이 글의 다음 섹션에서 이 표와 검사에 대해 설명한다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/6.png"></p><p><a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>은 다음 두 함수 중 하나에 의해 호출된다.</p><ul><li><code>PspGetSetContextInternal</code> – <code>NtSetContextThread API</code>에 대한 응답으로 호출된다</li><li><a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextRecord.c">KiVerifyContextRecord</a> – <code>NtContinueEx</code>, <code>NtRaiseException</code> 및 일부 경우 <code>NtSetContextThread</code> API에 대한 응답으로 호출된다. <a href="%3Chttps://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>을 호출하기 전에 (수신된 <code>ContinueArgument</code>가 NULL이 아닌 경우에만)이 함수는 호출자가 CS 레지스터를 수정하려고 하는지, 새 값이 유효한 값인지를 확인한다. WOW64가 아닌 프로세스는 피코 프로세스이며, 이 경우 CS를 <code>KGDT64_R3_CODE</code> 또는 <code>KGDT64_R3_CMCODE</code>로 설정할 수 있다. 다른 값은 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextRecord.c">KiVerifyContextRecord</a>가 새 CS 값을 <code>KGDT64_R3_CODE</code>로 강제한다. <code>KiVerifyContextRecord</code>는 <code>KiContinuePreviousModeUser</code> 또는 <code>KeVerifyContextRecord</code>에 의해 호출되며 두 번째의 경우, 함수는 RSP가 프로세스 스택 (native 또는 wow64) 중 하나에 있고 64 비트 프로세스가 CS를 <code>KGDT64_R3_CODE</code>로만 설정하는지 확인한다.</li></ul><p><code>KeVerifyContextIpForUserCet</code>을 호출하여 대상 RIP의 유효성을 검사하는 모든 경로는 먼저 <code>KeVerifyContextXStateCetU</code>를 호출하여 대상 SSP의 유효성을 검사하고 SSP가 유효할 때만 RIP 검사를 수행한다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/7.png"></p><h1 id="예외-해제-및-longjmp-유효성-검사"><a href="#예외-해제-및-longjmp-유효성-검사" class="headerlink" title="예외 해제 및 longjmp 유효성 검사"></a>예외 해제 및 longjmp 유효성 검사</h1><p>위에서 설명한 대로 <code>KCONTEXT_SET</code> 및 <code>KCONTEXT_RESUME</code>에 대한 처리는 대상 RIP가 섀도우 스택의 일부인지 확인하는 것과 관련이 있지만 <code>KCONTEXT_UNWIND</code> 및 <code>KCONTEXT_LONGJMP</code> 경우에는 <code>RtlVerifyUserUnwindTarget</code>을 통한 확장된 유효성 검사가 필요하다. 이 두 번째 유효성 검사를 위해서는 PE 파일 형식 (및 컴파일러 지원)을 변경해야 하며 JIT 컴파일러 지원을 위해 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/NtSetInformationProcess.c">NtSetInformationProcess</a>에 추가된 새로운 OS 수준의 정보 클래스가 포함되어 있다.</p><p>CFG (Control Flow Guard) 지원으로 인해 이미 추가된 PE 파일 내부의 <code>Image Load Configuration Directory</code>에는 현재 설정된 <code>jmp/longjmp</code> 쌍의 일부로 사용되는 분기 유효 대상에 대한 정보가 포함되어 있으며, 이 정보를 컴파일러가 식별해 링커에 전달하도록 되어 있다. CET를 사용하면 이 기존 데이터가 재사용되지만 연속 예외 핸들러 지원을 위해 또 다른 테이블과 크기가 추가된다. Visual Studio 2017은 <code>longjmp</code> 테이블을 생성하지만 Visual Studio 2019부터 위와 같은 정보가 포함된 테이블을 생성한다.</p><p>이 마지막 섹션에서는 이러한 테이블의 형식과 커널이 마지막 두 가지 유형의 <code>KCONTINUE_TYPE</code> 제어 흐름을 검증하는 방법을 살펴보겠다.</p><h2 id="PE-메타-데이터-테이블"><a href="#PE-메타-데이터-테이블" class="headerlink" title="PE 메타 데이터 테이블"></a>PE 메타 데이터 테이블</h2><p>Windows 10은 Control Flow Guard 이미지에 있는 표준 GFIDS 테이블 외에도  RVA가 저장되는 <code>.gljmp</code>라는 PE Image Load Configuration의 <code>Guard Long Jump Target Table</code> 필드에 저장된 PE 섹션의 Long Jump Target Table을 포함하여 longjump 대상의 유효성 검사에 대한 지원을 추가했다.</p><p><code>setjmp</code>에 대한 호출이 코드에서 수행될 때마다 반환 주소 (longjmp가 분기되는 위치)의 RVA가 이 테이블에 추가된다. 이 테이블의 존재 여부는 Image Load Configuration Directory의 <code>GuardFlags</code>에 있는 <code>IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT</code> 플래그에 의해 결정되며 <code>GuardLongJumpTargetCount</code> 필드에 표시된 만큼의 항목을 포함한다.</p><p>각 항목은 4 바이트 RVA와 n 바이트의 메타 데이터이다. 여기서 n은 <code>(GuardFlags &amp; IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) &gt;&gt; IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT</code>의 결과에서 가져온다. 이 테이블의 경우 메타 데이터가 정의되지 않았으므로 메타 데이터 바이트는 항상 0이 될 것으로 예상된다. 이 계산은 <code>GFIDS</code> 테이블 (<code>export suppression</code>가 활성화된 경우 잠재적으로 메타 데이터가 있음)에 사용된 계산과 동일하기 때문에 하나 이상의 CFG 대상을 억제하면 1 바이트의 빈 메타데이터가 Long Jump Target Target Table의 모든 항목에 추가된다.</p><p>예를 들어 다음은 두 개의 <code>longjmp</code> 대상이 있는 PE 파일이다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/8.png"></p><p>이 이미지도 CFG 내보내기 억제를 사용하므로 <code>GuardFlags</code>의 상위 니블 (<code>IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK</code>에 해당)에 있는 값 1에 유의하자. 이는 아래에서 볼 수 있는 Long Jump Target Table에 1 바이트의 추가 메타 데이터가 있음을 알려준다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/9.png"></p><p><code>Windows 10 20H1</code>에서 이러한 유형의 메타 데이터는 연속 대상에 대한 예외 핸들러가 바이너리의 제어 흐름의 일부로 존재하는 경우에 포함된다. 두 개의 새로운 필드 <code>GuardEHContinuationTable</code> 및 <code>GuardEHContinuationCount</code>가 Image Load Configuration Directory 끝에 추가되고 <code>IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT</code> 플래그가 <code>GuardFlags</code>에 포함된다. 이 테이블의 레이아웃은 <code>GuardFlags</code>의 상위 니블을 기반으로 한 메타 데이터 바이트 추가를 포함하여 Long Jump Target Table에 대해 표시된 것과 동일하다.</p><p>안타깝게도 Visual Studio 2019 버전에서도 이 데이터를 생성하지 않으므로 현재 예제를 보여줄 수 없다. 이 분석은 나중에 설명하는 유효성 검사 코드와 20H1 SDK의 <code>Ntimage.h</code> 헤더 파일을 리버스 엔지니어링 한 기반으로 한다.</p><h2 id="사용자-반전-기능-테이블"><a href="#사용자-반전-기능-테이블" class="headerlink" title="사용자 반전 기능 테이블"></a>사용자 반전 기능 테이블</h2><p>이제 longjmp 대상 또는 연속 대상에 대한 예외 핸들러로 분기하기 위해 제어 흐름 변경이 발생할 수 있음을 알고 있으므로 CONTEXT_EX에 있는 RIP 주소를 기반으로 이 두 테이블을 어떻게 얻을 수 있을까? NtContinueEx 전화? 이런 작업은 특정 프로그램 실행에서 자주 발생할 수 있으므로 커널은 이 문제를 해결하기 위한 효율적인 방법이 필요하다.</p><p><code>Inverted Function Table</code>의 개념에 이미 익숙할 것이다. 이러한 테이블은 <code>Ntdll.dll (LdrpInvertedFunctionTable)</code> 에서 유저 모드 예외 처리 중 해제 opcode 및 예외 데이터를 찾는 데 사용된다. (<code>.pdata</code> 섹션을 찾아서) <code>Ntoskrnl.exe (PsInvertedFunctionTable)</code>에 또 다른 테이블이 있으며 커널 모드 예외 처리 및 PatchGuard 검사의 일부에 사용된다.</p><p>간단히 말해 <code>Inverted Function Table</code>은 로드된 모든 유저/커널 모듈 크기와 가상 주소별로 정렬된 PE 예외 디렉터리에 대한 포인터를 포함하는 배열이다. 이 배열을 검색하는 것이 PE 헤더를 구문 분석한 뒤 로드된 모듈 연결 목록을 검색하는 것보다 훨씬 빠르기 때문에 역함수 테이블의 binary search는 로그(n) 조회에서만 해당 모듈의 가상 주소를 빠르게 찾는다. 현재 Microsoft의 명성을 얻고 있는 Ken Johnson과 Matt Miller는 이전에 Uninformed Magazine에 <a href="http://uninformed.org/index.cgi?v=8&a=2&p=20">커널 모드 후킹 기술</a>에 대한 기사의 일부로 개요를 게시했다.</p><p>그러나 이전에는 <code>Ntdll.dll</code>은 테이블에서 유저 모드 예외만, <code>Ntoskrnl.exe</code>는 커널 모드 예외만 검사했다. <code>20H1</code>의 변경 사항은 커널도 사용자 테이블을 검사해야 한다는 것이다. <code>longjmp</code> 및 예외 연속을 처리하는 데 필요한 새로운 로직을 지원하기 위해 새로운 <code>RtlpLookupUserFunctionTableInverted</code> 함수가 추가되어 <code>KeUserInvertedFunctionTable</code> 변수를 스캔하고 <code>Ntdll.dll</code>에서 현재 내보낸 <code>LdrpInvertedFunctionTable</code> 심볼에 매핑된다.</p><p>이것은 흥미로운 포렌식 기능으로, 커널에서 PEB의 로더 데이터를 구문 분석하거나 VAD를 열거할 필요 없이 현재 프로세스 내에 로드된 유저 모드 모듈을 쉽게 찾을 수 있다. 예를 들어 다음은 <code>Csrss.exe</code>에서 현재 로드된 이미지를 보는 방법이다.</p><pre><code class="hljs c">dx @$cursession.Processes.Where(p =&gt; p.Name == <span class="hljs-string">&quot;csrss.exe&quot;</span>).First().SwitchTo()dx -r0 @$table = *(nt!_INVERTED_FUNCTION_TABLE**)&amp;nt!KeUserInvertedFunctionTabledx -g @$table-&gt;TableEntry.Take(@$table-&gt;CurrentSize)</code></pre><p>즉, 원격에서도 특히 <code>unwind opcode</code> 가없는 x86 시스템에서는 이미지가 예외 디렉터리를 포함되지 않을 가능성이 있으며, <code>.pdata</code>는 <code>/SAFESEH</code>를 사용하고 적어도 하나의 예외 핸들러가 있는 경우에만 생성된다.</p><p>이러한 상황에서는 <code>RtlpLookupUserFunctionTableInverted</code>가 실패할 수 있으며 대신 <code>MmGetImageBase</code>를 사용해야 한다. 이것은 입력 RIP에 해당하는 영역을 매핑하는 VAD를 조회하고 이미지 VAD 인 경우 해당 영역의 기본 주소와 크기 (모듈의 크기와 일치해야 함)를 반환한다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/10.png"></p><h2 id="연속된-대상에-대한-동적-예외-핸들러"><a href="#연속된-대상에-대한-동적-예외-핸들러" class="headerlink" title="연속된 대상에 대한 동적 예외 핸들러"></a>연속된 대상에 대한 동적 예외 핸들러</h2><p><code>KCONTINUE_UNWIND</code> 요청을 처리하는데 마지막 장애물이 하나 있다. 정규 프로세스에는 코드의 <code>__try /__except /__finally</code> 절을 기반으로 하는 연속된 대상에 대한 정적 예외 핸들러가 있지만 Windows에서는 JIT 엔진이 실행 가능한 코드를 동적으로 즉시 생성할 수 있을 뿐만 아니라 <code>RtlAddFunctionTable</code> API 등을 통해 런타임에 예외 핸들러를 등록하고 opcode를 해제할 수 있다. 이러한 예외 핸들러는 이전에는 사용자 모드 stack walking 및 예외 해제에만 필요했지만 이제는 연속 핸들러가 커널이 RIP에 대해 잠재적으로 유효한 값으로 처리해야 하는 제어 흐름 대상이 된다. <code>RtlpFindDynamicEHContinuationTarget</code>이 처리하는 것이 마지막 가능성이다.</p><p>CET 지원 및 <code>NtContinueEx</code> 도입의 일부로 EPROCESS 구조는 <code>DynamicEHContinuationTargetsLock</code> 및 <code>DynamicEHContinuationTargetsTree</code>라는 두 개의 새로운 필드로 향상되었다. 첫 번째는 <code>EX_PUSH_LOCK</code>이고 두 번째는 모든 유효한 예외 핸들러 주소를 포함하는 <code>RTL_RB_TREE</code>이다. 이 트리는 <code>PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION</code> 유형의 데이터 구조와 함께 새로운 프로세스 정보 클래스 인 <code>ProcessDynamicEHContinuationTargets</code>를 사용하여 <code>NtSetInformationProcess</code>에 대한 호출을 통해 관리된다. 더 쉽게 이해하려면 이러한 구조 및 플래그에 대한 아래 정의를 참조하면 된다.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DYNAMIC_EH_CONTINUATION_TARGET_ADD          0x01</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED    0x02</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PROCESS_DYNAMIC_EH_CONTINUATION_TARGET</span></span><span class="hljs-class">&#123;</span>     ULONG_PTR TargetAddress;    ULONGLONG Flags;&#125; PROCESS_DYNAMIC_EH_CONTINUATION_TARGET, *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION</span></span><span class="hljs-class">&#123;</span>    USHORT NumberOfTargets;    USHORT Reserved;    ULONG Reserved2;    PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET* Targets;&#125; PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION, *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;</code></pre><p><code>PspProcessDynamicEHContinuationTargets</code> 함수가 이 데이터를 반복하기 위해 호출되며, 이 시점에서 <code>RtlAddDynamicEHContinuationTarget</code>은 대상 주소를 저장하는 데이터 구조를 할당하고 <code>ETL_RB_TREE_BPROCESS.NODE</code>에 <code>RTL_RB_NODE</code> 링크를 연결하는 <code>DYNAMIC_EH_CONTINUATION_TARGET_ADD</code> 플래그 세트를 포함하는 항목에 대해 호출되며 반대로 플래그가 없으면 대상을 조회하고 실제로 존재하는 경우 제거되고 노드가 해제된다. 각 항목이 처리될 때 <code>DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED</code> 플래그가 원래 입력 버퍼에 OR 처리되므로 호출자는 어떤 항목이 작동하고 작동하지 않았는지 알 수 있다.</p><p>가능한 모든 ROP 가젯이 단순히 ‘동적 연속 목표’로 추가될 수 있으므로이 기능의 존재는 CET/CFG와 유사한 기능의 보편적인 우회로 보인다. 그러나 Microsoft는 브라우저와 Flash에 대한 <code>out-of-process JIT</code> 컴파일만 공식적으로 지원하므로 이 API는 원격 프로세스에서만 작동한다는 점에 유의해야 한다. 따라서 현재 프로세스에서 호출하면 항상 <code>STATUS_ACCESS_DENIED</code>로 실패한다.</p><h2 id="타겟-검증"><a href="#타겟-검증" class="headerlink" title="타겟 검증"></a>타겟 검증</h2><p>이 모든 지식을 통합하면 <code>RtlVerifyUserUnwindTarget</code> 함수를 설명하기 쉬워진다.</p><ol><li>CONTEXT_EX 구조에서 대상 RIP와 연관된 로드된 PE 모듈을 조회한다. 먼저 <code>RtlpLookupUserFunctionTableInverted</code>를 사용하고 실패하면 대신 <code>MmGetImageBase</code>를 사용하여 모듈이 4GB 미만인지 확인한다.</li><li>모듈이 발견되면 <code>LdrImageDirectoryEntryToLoadConfig</code> 함수를 호출하여 Image Load Configuration Directory를 가져온다. 그런 다음 Long Jump 또는 연속 대상에 대한 동적 예외 핸들러 테이블을 포함할 수 있을 만큼 충분히 큰지와 <code>guardflags</code>에 <code>IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT</code> 또는 <code>IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT</code>가 포함되어 있는지 확인한다. 디렉터리가 없거나 너무 작은 경우 혹은 일치하는 테이블이 없는 경우 호환성을 위해 <code>STATUS_SUCCESS</code>를 반환한다.</li><li>Image Load Configuration Directory에서 <code>GuardLongJumpTargetTable</code> 또는 <code>GuardEHContinuationTable</code>을 가져오고 <code>GuardLongJumpTargetCount</code> 또는 <code>GuardEHContinuationCount</code>의 유효성을 검사한다. 항목이 40억 개 이상이면 <code>STATUS_INTEGER_OVERFLOW</code>를 반환한다. 0 개 이상의 항목이 있는 경우 테이블을 통해 bsearch_s (대조자로 <code>RtlpTarget Compare</code> 를 전달)를 사용하여 binary search를 통해 RVA로 변환한 후 대상 RIP를 찾는다. 발견되면 <code>STATUS_SUCCESS</code>를 반환합니다.</li><li>대상 RIP를 찾을 수 없거나 (또는 테이블에 시작할 항목이 0인 경우) 처음부터 대상 RIP에서 로드된 모듈이 발견되지 않은 경우 <code>STATUS_SET_CONTEXT_DENIED</code>를 반환해  <code>longjmp</code> 유효성을 검증한다.(<code>KCONTINUE_LONGJUMP</code>)</li><li>예외 해제 유효성 검사 (<code>KCONTINUE_UNWIND</code>)의 경우 <code>RtlpFindDynamicEHContinuationTarget</code>을 호출하여 등록된 연속 대상에 대한 동적 예외 핸들러인지 확인한다. 맞으면 <code>STATUS_SUCCESS</code>를 반환하고, 그렇지 않으면 <code>STATUS_SET_CONTEXT_DENIED</code>를 반환한다.</li></ol><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>CET의 구현과 관련 mitigation은 ROP 및 기타 제어 흐름 하이재킹 기술의 사용을 방지하기 위한 주요 단계이다. 제어 흐름 무결성은 분명 복잡한 주제이며, 향후 추가적인 mitigation이 추가됨에 따라 더욱 복잡해질 것이다. 추가적인 호환성 문제와 일회성 시나리오로 인해 특정 처리를 필요로 하는 사례가 점점 더 많이 발견될 수 있다. 그러나 완화 기술, 특히 많은 새로운 기능을 포함하는 기술의 발전단계에는 문제가 발생하기 마련이고, 우리는 이 분야에서 더 많은 연구가 이루어짐에 따라 미래에 흥미로운 것들이 발견될 것이라고 확신한다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rop/">rop</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/cet/">cet</category>
      
      <category domain="https://hackyboiz.github.io/tags/mitigation/">mitigation</category>
      
      <category domain="https://hackyboiz.github.io/tags/translation/">translation</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/17/l0ch/cet-on-windows/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-26233: Git CLI RCE</title>
      <link>https://hackyboiz.github.io/2021/01/16/fabu1ous/2021-01-16/</link>
      <guid>https://hackyboiz.github.io/2021/01/16/fabu1ous/2021-01-16/</guid>
      <pubDate>Sat, 16 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.blazeinfosec.com/attack-of-the-clones-2-git-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.blazeinfosec.com/attack-of-the-clones-2-git-command-client-remote-code-execution-strikes-back/">https://blog.blazeinfosec.com/attack-of-the-clones-2-git-command-client-remote-code-execution-strikes-back/</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Git Credential Manager core &lt; 2.0.289</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>악성 repository를 fork 한 피해자의 시스템에 임의의 실행파일을 실행시킬 수 있는 CVE-2020-26233에 대한 세부 정보가 공개되었습니다. 유사한 취약점으로 <a href="https://hackyboiz.github.io/2020/11/06/l0ch/2020-11-06/">CVE-2020-27955</a>가 있습니다.</p><p>git clone은 기본적으로 top-level 디렉터리를 clone 한 후 새로운 git 프로세스를 생성해 재귀적으로 submodule들을 clone 합니다. 만약 repository의 root디렉터리 안에 git.exe라는 이름의 실행파일이 있다면 Git Credential Manager core가 configuration을 읽는 과정에서 해당 파일을 실행하게 됩니다.</p><p>이런 취약점이 발생하는 이유는 다음과 같습니다. 만약 git.exe를 실행하라는 명령어를 받으면 Windows는 우선적으로 현재 디렉터리에 git.exe 실행파일이 있는지 확인하고, 없을 때만 %PATH% 환경 변수를 순회하면서 git.exe를 찾아 실행합니다. </p><p>PoC는 아래와 같습니다.</p><ol><li>새로운 Repository생성, 혹은 기존 Repository에 파일 추가할 수 있는 권한 획득</li><li>windows 실행파일의 파일명을 git.exe로 수정해 업로드</li><li>임의의 사용자가 Repository를 fork 하기를 기다림</li><li>RCE 성공</li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/git/">git</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/16/fabu1ous/2021-01-16/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Google master token 탈취를 통한 구글 계정 접근</title>
      <link>https://hackyboiz.github.io/2021/01/15/l0ch/2021-01-15/</link>
      <guid>https://hackyboiz.github.io/2021/01/15/l0ch/2021-01-15/</guid>
      <pubDate>Fri, 15 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.usejournal.com/how-i-stole-the-data-in-milli</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.usejournal.com/how-i-stole-the-data-in-millions-of-peoples-google-accounts-aa1b72dcc075">How I stole the data in millions of people’s Google accounts</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android/iOS<br>Google accounts</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>피싱 앱에서 해커가 Google의 계정과 패스워드를 탈취하는 방법은 일반적으로 앱에서 <code>Google 계정으로 가입</code> 버튼을 통해 해커가 제작한 로그인 페이지에 계정과 패스워드를 입력하도록 유도하는 방법입니다.</p><p>Google은 이전에 로그인한 지역과 거리가 먼 지역에서 로그인 시도가 있을 경우 이를 차단하는 위치 기반 로그인 차단 기능이 있어 해커가 계정과 패스워드를 알아도 피해자의 계정에 접근할 수 없습니다. 그러나 안드로이드 기기의 구글 계정 관리 토큰인 Google master token을 탈취하면 이러한 계정 보호를 우회할 수 있습니다. master token은 사용자가 암호나 2단계 로그인 설정을 변경하지 않는 이상 만료되지 않고 위치 검사의 대상이 아니기 때문에 위치 기반 로그인 차단이 작동하지 않습니다. </p><p>피해자가 해커의 악성 앱을 설치하고 구글 계정으로 가입하도록 유도하면 구글 로그인 페이지를 통해 피해자 계정의 master token을 가져올 수 있고 해커는 이 master token으로 대부분의 구글 서비스에 접근이 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/google-credential/">google credential</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/15/l0ch/2021-01-15/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1648: CVE-2020-0986 패치 우회 및 arbitrary address read</title>
      <link>https://hackyboiz.github.io/2021/01/14/idioth/2021-01-14/</link>
      <guid>https://hackyboiz.github.io/2021/01/14/idioth/2021-01-14/</guid>
      <pubDate>Thu, 14 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://whereisk0shl.top/post/the_story_of_cve_2021_1648&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://whereisk0shl.top/post/the_story_of_cve_2021_1648">THE STORY OF CVE-2021-1648</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows splwow64</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2021년 1월 patch tuesday에서 <a href="https://hackyboiz.github.io/2020/12/31/idioth/2020-12-31/">CVE-2020-0986</a> 패치를 우회하는 splwow64 서비스 취약점을 패치했습니다.  CVE-2020-0986이 패치된 후 splwow64와 gdi32full에는 두 가지 검사가 추가되었습니다.</p><ol><li>프린터 핸들 검사 함수 <code>FindDriverForCookie</code>와 <code>FindPrinterHandle</code> 추가</li><li>포인터 유효성 검사를 위한 함수 <code>UMPDStringPointerFromOffset</code>과 <code>UMPDPointerFromOffset</code> 추가</li></ol><p>1번의 함수들은 전역 변수에 어떤 프린터 드라이버 핸들이 저장되었는지 확인합니다. 그중 <code>0x6A</code> 커맨드를 호출하면 함수 <code>bAddPrinterHandle</code>가 전역 변수 <code>qword_1800EABA0</code>에 저장된 드라이버 힙에 프린트 핸들을 추가하여 전역 변수에 프린터 핸들 값을 조작해 <code>0x6D</code>에서 호출하는 <code>FindDriverForCookie</code>와 <code>FindPrinterHandle</code>을 우회할 수 있습니다. 또한 <code>0x6D</code>에서 <code>memcpy</code>를 호출할 때 source address를 확인하지 않고 복사를 진행하여 arbitrary address read가 가능합니다.</p><p>2번 함수들은 잘못된 범위 검사로 인해 우회가 가능합니다. splwow64는 x86에 대한 호환성으로 인해 항상 32비트 힙을 할당합니다. 하지만 두 함수들은 offset과 portview+offset이 <code>0x7fffffff</code>보다 작은지만 검사합니다. splwow64에서 힙은 낮은 주소에 할당되므로(ex. <code>0x7d7c70</code>) 검사를 우회할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/splwow64/">splwow64</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-read/">arbitrary read</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/14/idioth/2021-01-14/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-16875: RCE in MS Office 365</title>
      <link>https://hackyboiz.github.io/2021/01/13/fabu1ous/2021-01-13/</link>
      <guid>https://hackyboiz.github.io/2021/01/13/fabu1ous/2021-01-13/</guid>
      <pubDate>Wed, 13 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://srcincite.io/blog/2021/01/12/making-clouds-rain-r</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://srcincite.io/blog/2021/01/12/making-clouds-rain-rce-in-office-365.html">https://srcincite.io/blog/2021/01/12/making-clouds-rain-rce-in-office-365.html</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Exchange server released Before 09/08/2020</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft office 365 Exchange server에서 발견된 CVE-2020-16875의 write-up이 공개되었습니다. <code>New-DlpPolicy</code> cmdlet의 validation 작업을 하는  <code>NewDlpPolicy.InternalValidate()</code> 함수에서 유저로부터 받은 TemplateData를  pipeline에 추가한 후 Powershell command로 실행하기 때문에 code injection취약점이 존재합니다. 이를 악용할 경우 SYSTEM권한으로 원격 코드 실행을 할 수 있습니다.</p><p> <code>NewDlpPolicy.InternalValidate()</code>가 호출하는 <code>DlpPolicyTemplateMetaData.ValidateCmdletParameters()</code> 함수는 다음과 같이 패치되었습니다. </p><ol><li>Inline command 사용을 막기 위한 검사 수행</li><li>validate 하려는 command 문자열이  <code>New-TransportRule</code>로 시작하는지 검사</li><li>validate 하려는 command 문자열이 <code>-DlpPolicy</code>을 담고 있는지 검사</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.1#:~:text=A%20cmdlet%20is%20a%20lightweight,them%20programmatically%20through%20PowerShell%20APIs">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.1#:~:text=A%20cmdlet%20is%20a%20lightweight,them%20programmatically%20through%20PowerShell%20APIs</a>.</p><p><a href="https://docs.microsoft.com/en-us/powershell/module/exchange/new-dlppolicy?view=exchange-ps">https://docs.microsoft.com/en-us/powershell/module/exchange/new-dlppolicy?view=exchange-ps</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/office-365/">office 365</category>
      
      <category domain="https://hackyboiz.github.io/tags/exchange/">exchange</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/13/fabu1ous/2021-01-13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-9971 : macOS/iOS XPC 서비스 관리 앱에서 발견된 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/01/12/l0ch/2021-01-12/</link>
      <guid>https://hackyboiz.github.io/2021/01/12/l0ch/2021-01-12/</guid>
      <pubDate>Tue, 12 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://xlab.tencent.com/en/2021/01/11/cve-2020-9971-abus</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://xlab.tencent.com/en/2021/01/11/cve-2020-9971-abusing-xpc-service-to-elevate-privilege/">CVE-2020-9971 Abusing XPC Service mechanism to elevate privilege in macOS/iOS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>macOS &lt; Big Sur<br>iOS  &lt; 13.5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>launchd는 macOS에서 <code>inetd</code>, <code>xinted</code>를 대체하는 서비스 관리 데몬입니다.<br>이러한 <code>launchd</code> 애플리케이션에서 프로세스 간 통신 프로토콜을 제공하는 XPC 서비스를 관리할 때 권한 상승이 가능한 취약점의 세부 정보가 공개되었습니다.</p><p><code>launchd</code>는 <code>launchd process domain</code> 을 통해 XPC 서비스를 지정된 프로세스로 제한할 수 있으며 프로세스 도메인은 소유자 프로세스만 수정이 가능합니다. 그러나 Big Sur 이전의 <code>launchd</code>에서 프로세스 도메인에 XPC를 추가할 때 호출자 pid와 프로세스 도메인의 소유자 pid를 확인하지 않아 프로세스가 다른 임의의 프로세스에 XPC 서비스를 추가할 수 있습니다.</p><p>해당 취약점을 악용하면 해커의 프로세스(애플리케이션)가 루트 권한으로 실행되는 프로세스의 도메인에 임의의 사용자 지정 XPC 서비스를 추가할 수 있고, 추가된 XPC 서비스가 루트 권한으로 실행됩니다.</p><p>iOS 또한 macOS와 동일한 <code>launchd</code> 로직을 사용하고 있으며 iOS 13.5 이전 버전에 같은 취약점이 존재합니다. 애플은 호출자 pid가 대상 프로세스 도메인의 소유자인지 확인하는 코드를 추가해 해당 취약점을 패치했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/ios/">ios</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/apple/">apple</category>
      
      <category domain="https://hackyboiz.github.io/tags/macos/">macos</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/12/l0ch/2021-01-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] 유엔환경계획(UNEP) 10만명 이상 직원 기록 접근</title>
      <link>https://hackyboiz.github.io/2021/01/11/idioth/2021-01-11/</link>
      <guid>https://hackyboiz.github.io/2021/01/11/idioth/2021-01-11/</guid>
      <pubDate>Mon, 11 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://johnjhacking.com/blog/unep-breach/&quot;&gt;UNEP Breached</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://johnjhacking.com/blog/unep-breach/">UNEP Breached, 100K+ Employee Records Accessed</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>ilo.org</li><li>unep.org</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>유엔에서 Git Credentials이 노출된 endpoint를 통해 직원들의 기록 및 프로젝트, 보고서 등의 정보에 접근할 수 있는 취약점이 발견되었습니다. ilo.org의 하위 도메인에 노출된 .git content가 존재합니다. <a href="https://github.com/arthaud/git-dumper">git-dumper</a>를 사용하여 프로젝트 폴더를 덤프할 수 있고 코드에 노출된 자격 증명으로 mysql 데이터베이스와 survey management platform에 접근할 수 있습니다.</p><p><img src="/2021/01/11/idioth/2021-01-11/image0.png"></p><p>또한 unep.org에서  <code>.git-credentials</code>가 노출된 서브 도메인이 존재합니다. GitHub credentials를 통해 private project에 접근할 수 있고 데이터베이스 및 각종 애플리케이션 정보에 접근할 수 있습니다.</p><p><img src="/2021/01/11/idioth/2021-01-11/image1.png"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/git-dump/">git dump</category>
      
      <category domain="https://hackyboiz.github.io/tags/git-credential/">git credential</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/11/idioth/2021-01-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] MeMFuck: 유저 모드 후킹 우회</title>
      <link>https://hackyboiz.github.io/2021/01/10/idioth/memfuck/</link>
      <guid>https://hackyboiz.github.io/2021/01/10/idioth/memfuck/</guid>
      <pubDate>Sun, 10 Jan 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;원문 글 : &lt;a href=&quot;https://winternl.com/memfuck/&quot;&gt;MemFuck: Bypassing User-Mode Hooks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;서문&quot;&gt;&lt;a href=</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>원문 글 : <a href="https://winternl.com/memfuck/">MemFuck: Bypassing User-Mode Hooks</a></p></blockquote><h2 id="서문"><a href="#서문" class="headerlink" title="서문"></a>서문</h2><p>동적 악성코드 분석은 많은 AV/EDR/MDS에서 악성 프로그램을 탐지하는데 자주 사용하는 방식이다. 동적 분석은 정적 분석과 달리 실행 과정에서 만들어진 윈도우 API 호출을 캡처하고 분석하며 정적 분석보다 탐지율이 높다. system call을 캡처하는  많은 기술이 있지만 가장 많이 사용하는 것은 user-level hook이다. 이러한 hook은 악성 기능을 분석하기 위해 함수 호출을 가로챈다. 임의 실행 파일에서 API 호출의 시퀀스는 다음과 같다.</p><pre><code class="hljs ebnf"><span class="hljs-attribute">OpenProcess</span><span class="hljs-attribute">VirtualAllocEx</span><span class="hljs-attribute">WriteProcessMemory</span><span class="hljs-attribute">CreateRemoteThreadEx</span><span class="hljs-attribute">QueueUserAPC</span><span class="hljs-attribute">NtAlertResumeThread</span></code></pre><p>안티 바이러스들은 호출이나 그 조합을 기반으로 악성 행위를 정의한다. 안티 바이러스의 입장에서 특정한 호출 조합은 코드 인젝션이며 대부분 악의적이거나 원하지 않는 행동으로 판단된다.</p><p>user-mode hook은 안티 바이러스와 NGAV, EDR, sandbox, anti-cheat, DRM 등을 포함한 많은 보안 제품과 툴에서 사용된다. user-mode hook은 구현하기 쉽고, 안정적이고, 간단하며 성능 오버헤드가 적다.</p><p>대부분 user-land hook은 inline hook이며 control flow를 custom handler로 리다이렉트 시키기 위한 대상 함수 rewrite를 포함한다. 핸들러의 내부에서 파라미터들은 보존되고 요청된 함수를 실행하거나 분석할지 결정할 수 있다. 이것들은 잘 문서화되어 있으므로 이러한 개념에 익숙할 것이라고 가정할 것이다.</p><h2 id="32-bit-Hooks"><a href="#32-bit-Hooks" class="headerlink" title="32-bit Hooks"></a>32-bit Hooks</h2><p><img src="/2021/01/10/idioth/memfuck/image0.png"></p><p>32비트 user-land hook이 포함된다. 32비트 유저 모드 보안 제품은 대부분 가능한 깊은 위치에서 hook 하며 ntdll에 대부분의 의심스러운 함수들(NtQueueApcThread 등)이 존재한다. 해결 방법은 system call을 사용하여 원하는 기능을 직접적으로 호출하는 것이다. Ring3 후킹으로 모든 보안 제품을 우회할 수 있다.</p><p>필자는 5년 동안 32비트 윈도우를 접한 경우가 하나도 없으므로 일반적인 경우인 WoW64에서 동작하는 32비트 응용 프로그램에 대해 살펴볼 것이다.</p><h2 id="WoW64에서의-32비트-후킹"><a href="#WoW64에서의-32비트-후킹" class="headerlink" title="WoW64에서의 32비트 후킹"></a>WoW64에서의 32비트 후킹</h2><p><img src="/2021/01/10/idioth/memfuck/image1.png"></p><p>가장 흔한 악성코드의 인스턴스는 Wow64에서 동작하는 32비트 프로그램이다(64비트 머신에서 동작). NGAV와 EDR은 이러한 시나리오에서의 hook 구현이 미흡하다. 대부분 보안 제품은 x86 유저 모드 영역에서만 hook을 한다. user-mode hook을 활용하는 안티바이러스는 WoW64 layer에 hook을 위치하는 것이 좋지만 모든 업체가 그것을 구현하지는 않는다. <a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">Sophos 우회에 관한 MDSec의 게시글</a>을 보아라.</p><p>많은 보안 제품들이 32비트 프로세스에서 WoW64 실행을 모니터링하지 않는다는 사실은 오랫동안 알려져 있었고 <a href="https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/">악성코드 제작자</a>와 <a href="https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/">red-team</a>에 의해 공격당했다. 필자가 분석한 악성코드 중에 얼마나 많은 것들이 이를 악용한 <a href="https://github.com/rwfpl/rewolf-wow64ext">rewolf’s wow64ext</a>를 포함하는지 말할 수 없다.</p><h2 id="요약-기존-기술"><a href="#요약-기존-기술" class="headerlink" title="요약 : 기존 기술"></a>요약 : 기존 기술</h2><ul><li>단순히 함수의 Ntdll 버전을 호출하는 것</li><li><a href="https://web.archive.org/web/20190407064851/https://blog.ensilo.com/globeimposter-ransomware-technical">함수의 Wow64 버전을 호출하는 것</a></li><li><a href="https://cdn2.hubspot.net/hubfs/487909/ENSILO%20WHITEPAPER%20ENTER%20THE%20DARK%20GATE.pdf">직접 Syscall 호출</a></li><li>원본 thunk 추적 (<a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">FireWalker</a>)</li><li><a href="https://blog.malwarebytes.com/threat-analysis/2018/03/hancitor-fileless-attack-with-a-copy-trick/">보조 DLL 매핑</a></li><li>Code splicing (byte stealing)</li></ul><p>모두 잘 작동하고 좋지만 64비트 버전의 ntdll에 위치한 hook에서 동작하지 않을 수 있다. 필자의 관찰에서 이러한 레벨의 hook은 어떤 public 코드로도 본 적이 없고 어떤 안티바이러스도 구현하지 않았다. 몇 가지 존재할 것이라고 확신하지만 보지 못했다.</p><h2 id="MemFuck에-들어가며"><a href="#MemFuck에-들어가며" class="headerlink" title="MemFuck에 들어가며"></a>MemFuck에 들어가며</h2><p>Memfuck은 오직 PoC이며 production code와 유사하지 않다. 즉 필자는 유저 영역에서 가능한 강력한 anti-analysis 기술이라고 생각한다.</p><p>MemFuck은 다른 anti-analysis 방법으로 실험을 시작했다. 본질적으로 가능한 한 비어있는 프로세스를 생성하길 원했으므로 DLL이나 쉘 코드의 수정 없이 보안 제품을 attach 할 수 없었다. 필자는 2008년에 이 <a href="https://gynvael.coldwind.pl/?id=93">게시글</a>을 발견했는데 매우 흥미로웠다. 물론 32비트 윈도우 XP에서 많은 변화가 있었으므로 많은 코드가 호환되지 않지만 대부분의 개념이 존재한다.</p><p><img src="/2021/01/10/idioth/memfuck/image2.png"></p><p>무엇이 ntdll을 필요로 하는가? 모든 결과는 특정한 DLL에 의존하므로 이를 망쳐버리면 어떠한 일이 일어날까</p><h2 id="Unmap-Everything"><a href="#Unmap-Everything" class="headerlink" title="Unmap Everything"></a>Unmap Everything</h2><p>MemFuck은 32비트 주소 영역에서 가능한 모든 것을 unmap 하는 것에 의해 시작된다. 물론 PEB/PEB64, TEB/TEB64와 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">KUSER_SHARED_DATA</a> (작년에 마침내 문서화되었다) 같이 해제가 불가능한 것들도 있다. 이에 대해 몇 가지 방법이 있지만 가능한 귀찮지 않은 방법을 선택하고 싶었다. 우리는 모든 것에 NtUnmapViewOfSection을 호출하는 x86 쉘 코드를 할당할 수 있지만 그렇게 ntdll을 unmap 하면 무슨 일이 일어날까? Ntdll은 자기 자신을 unmap 할 수 없으므로 이 방법은 동작하지 않는다. 다음 단계에서 필자는 code segment switching(Heaven’s Gate)을 통해 직접 syscall 호출을 시험해보았다. 32비트 주소 영역에서 64비트 syscall 실행은 충분히 가능하지만 이 방법은 몇 가지 이유로 이상적이지 않았다.</p><ul><li>32비트 주소 영역에서 코드가 매핑되고 실행되므로 분석하기 쉬울 것이다.</li><li>64비트 주소 영역은 여전히 손상되어 있지 않다.</li><li>이 기술은 user-mode hook을 우회하기 효과적이지만 이미 문서화되어 있다.</li></ul><p>전부는 아니지만 대부분 Ring3 hook을 활용하는 AV/EDR 업체들은 하나의 일반적인 가정을 한다고 생각한다. WoW64 위에서 실행하는 32비트 프로세스는 4GB로 제한된 주소 아래에서 사용자 정의된 코드를 가진다. 따라서 매핑되지 않은 코드를 더 많이 배치하고 기능을 계속할 수 있는 이 제한 이상의 메모리를 할당해보자. Alex Ionescu에 따르면 <a href="https://twitter.com/aionescu/status/677599528409677824?lang=en">이것은 가능하지 않다</a>. 그러나 Petr Benes와 얘기한 후 그는 최근 버전의 윈도우10에서 이러한 제한이 해제되었다고 생각한다. 윈도우10 Build 19041.508에서 테스트했다.</p><p>64비트 버전의 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">NtAllocateVirtualMemory</a> 호출하기 위해 <a href="https://github.com/rwfpl/rewolf-wow64ext">rewolf’s wow64ext</a>를 사용했다. 필자가 처음 호출을 시도했을 때 혼란스러운 결과를 봤다. BaseAddress 요청이 Null이면 운영체제가 메모리 할당할 위치를 결정한다. 물론 윈도우는 우리가 있어서는 안 되는 곳에 메모리를 할당하는 것을 원하지 않으며 64비트 호출은 32비트 주소 영역에 잘 할당된 메모리를 반환한다. ZeroBit 플래그를 망치는 것은 어떨까? 필자는 ZeroBit 플래그를 조작해서 가능한 높은 주소에 request 하는 방법을 설명하는 <a href="https://stackoverflow.com/questions/50429365/what-is-the-most-reliable-portable-way-to-allocate-memory-at-low-addresses-on">stackoverflow 게시글</a>을 찾았다. 다시 필자는 ZeroBit 플래그를 조작하여 64비트 NtAllocateVirtual request에 MEM_TOP_DOWN 플래그를 추가해보았다. 메모리가 살짝 높긴 하지만 32비트 주소를 만났다. 이 지점에서 매개변수를 조작하는 아이디어를 얻었다. 우리가 원하는 주소를 요청하자! 필자는 BaseAddress를 64비트 주소(많은 메모리와 3개의 DLL)로 설정했고 놀랍게도 그 주소에 할당됐다.</p><p><img src="/2021/01/10/idioth/memfuck/image3.png"></p><p>물론 여기서 우리가 첫 번째로 해야 할 것은 여기에 쉘 코드를 써서 어떠한 행동이 일어나는지 보는 것이다. <a href="https://github.com/jackullrich/ShellcodeStdio">ShellcodeStdio</a>를 사용해서 빠르고 쉽게 64비트 쉘 코드를 작성했다. 이 쉘 코드는 64비트 공간에 할당되고 쓰이며 기본적으로 32비트 유저 모드의 모든 것에 unmap을 시도한다.</p><p>첫 번째 시도에 대한 수도 코드는 아래와 같다.</p><pre><code class="hljs cpp">DEFINE_FUNC_PTR(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, NtUnmapViewOfSection);DEFINE_FUNC_PTR(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, NtProtectVirtualMemory);<span class="hljs-keyword">for</span> (DWORD m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">0x80000000</span>; m += <span class="hljs-number">0x1000</span>)    &#123;      PVOID ptrToProtect = (PVOID)m;      ULONG dwBytesToProtect = <span class="hljs-number">1</span>;      ULONG dwOldProt = <span class="hljs-number">0</span>;      NtProtectVirtualMemory((HANDLE)<span class="hljs-number">-1</span>, &amp;ptrToProtect, &amp;dwBytesToProtect, PAGE_READWRITE, &amp;dwOldProt);      NtUnmapViewOfSection((HANDLE)<span class="hljs-number">-1</span>, (PVOID)m);    &#125;</code></pre><p><img src="/2021/01/10/idioth/memfuck/image4.png"></p><p>프로세스가 엉망이다. 그러나 여전히 코드는 실행되고 있으며 잘 동작하고 있다. anti-analysis을 하기에 상당히 좋은 환경이다. 32비트 주소 영역의 완전한 제어를 갖고 우리가 원하는 것을 확실히 로드하고 언로드 할 수 있다. OllyDbg와 x64dbg 같은 많은 디버거들은 여기서 크래시가 나서 분석을 계속하기 위해 Windbg를 사용했다.</p><h2 id="An-Interstring-Intermission"><a href="#An-Interstring-Intermission" class="headerlink" title="An Interstring Intermission"></a>An Interstring Intermission</h2><p>프로세스의 32비트 주소 영역을 완전히 지워버리면서 코드는 의도대로 실행하고 동작하도록 하는 목표에 거의 성공했었다. 여기에는 공격적인 결과와 방어적인 결과가 같이 있다. 아마 이 기간 동안 가장 흥미로운 사실 중 하나는 <a href="https://docs.microsoft.com/en-us/windows/win32/winprog64/exception-handling-under-wow64">MSDN 페이지</a>를 발견했을 때이다.</p><blockquote><p>WOW64는 x86 예외에 대한 전송으로 native x64, ia64 또는 ARM64 예외를 사용한다. 따라서 WOW64에서 동작하는 32비트 응용 프로그램에서 포착되지 않은 예외는 native 64비트 예외처럼 동작한다.</p></blockquote><p>4GB 경계 위의 주소에 64비트 쉘 코드를 쓸 수 있는데, 64비트 공간에 64비트 벡터 예외 처리기(Vectored Exception Handler)를 설치하며 32비트 예외에 의해 트리거 되고 Control Flow가 64bit VEH에 의해 리다이렉션 된다.</p><p><img src="/2021/01/10/idioth/memfuck/image5.png"></p><p>32비트 ntdll이 로드되어 제대로 됐음을 확신했다. 모든 것이 unmap 된 예외를 트리거하는 것은 쉽지만 처리할 WoW64 레이어로 전환할 코드가 없다. 하지만 이 아이디어에는 많은 흥미로운 잠재력이 있다.</p><h2 id="Ntdll-No-More"><a href="#Ntdll-No-More" class="headerlink" title="Ntdll No More"></a>Ntdll No More</h2><p>더 이상 어떤 목적을 위해서든 ntdll에 의존하지 않는다는 원래 개념으로 돌아가서 WoW64 계층에 남은 3개의 dll을 unmapping 하는 일이 남았다. WoW64는 대부분 시스템에서 거의 동일하다.(WoW64.dll, wow64win.dll, ntdll.dll)</p><p><img src="/2021/01/10/idioth/memfuck/image6.png"></p><p>32비트 코드로 돌아가지 않을 것이라고 생각하니 더 이상 필요하지 않은 이 dll들을 unmap 하자.</p><pre><code class="hljs cpp">DWORD64 addrWoW64 = <span class="hljs-number">0</span>;  DWORD64 addrWoW64Win = <span class="hljs-number">0</span>;  DWORD64 addrNtdll = <span class="hljs-number">0</span>;  PPEB peb64 = getPEB();  LIST_ENTRY* first = peb64-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink;  LIST_ENTRY* ptr = first;  <span class="hljs-keyword">int</span> cntr = <span class="hljs-number">0</span>;  <span class="hljs-keyword">do</span> &#123;    LDR_DATA_TABLE_ENTRY* dte = getDataTableEntry(ptr);    ptr = ptr-&gt;Flink;    <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">1</span>) &#123;      addrNtdll = (DWORD64)dte-&gt;DllBase;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">2</span>) &#123;      addrWoW64 = (DWORD64)dte-&gt;DllBase;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">3</span>) &#123;      addrWoW64Win = (DWORD64)dte-&gt;DllBase;    &#125;    cntr++;  &#125; <span class="hljs-keyword">while</span> (ptr != first);  NtUnmapViewOfSection(<span class="hljs-number">-1</span>, addrWoW64);  NtUnmapViewOfSection(<span class="hljs-number">-1</span>, addrWoW64Win);</code></pre><p><img src="/2021/01/10/idioth/memfuck/image7.png"></p><p>32비트 주소 공간에 더 이상 hook은 존재하지 않으며 WoW64 dll(Wow64SystemServiceEx 등)에 있는 것도 다 사라졌다. 남은 일은 ntdll을 unmap 하는 것이다. 다시 한번 부모 모듈에서 NtUnmapViewOfSection을 호출하는 문제가 생겼다. 직접 system call을 하자.</p><p>64비트 MSVC 컴파일러가 inline assembly를 제공하지 않으므로 function ordering, 내부 코드 배치 제한으로 인해 system call stub에 새로운 메모리 영역을 할당하기로 결정했다. 윈도우 10 64비트의 Syscall stub은 아래와 같다.</p><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r10</span>, <span class="hljs-built_in">rcx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, xxh<span class="hljs-keyword">syscall</span><span class="hljs-keyword">retn</span></code></pre><p>NtdllVirtualMemory를 호출하고 DWORD by DWORD로 코드를 작성해라. 그리고 typedef prototype을 할당하면 Nt* 함수를 쉽게 호출할 수 있다.</p><pre><code class="hljs cpp">DWORD dwCode1 = <span class="hljs-number">0xb8d18b4c</span>;  DWORD dwCode2 = <span class="hljs-number">0x0000002a</span>; <span class="hljs-comment">// syscall code for NtUnmapViewOfSection</span>  DWORD dwCode3 = <span class="hljs-number">0x90c3050f</span>;  <span class="hljs-comment">// mov r10, rcx ; 0x4c 0x8b 0xd1</span>  <span class="hljs-comment">// mov eax, xxh ; 0xb8 xx 00 00 00</span>  <span class="hljs-comment">// syscall ; 0x0f 0x05</span>  <span class="hljs-comment">// retn ; 0xc3</span>  *(DWORD*)syscallbase = dwCode1;  *((DWORD*)syscallbase + <span class="hljs-number">1</span>) = dwCode2;  *((DWORD*)syscallbase + <span class="hljs-number">2</span>) = dwCode3;  p_SysUnmapViewOfSection sysUnmap = (p_SysUnmapViewOfSection)syscallbase;</code></pre><p>마지막으로 64비트 ntdll에 대해 NtUnmapViewOfSection의 직접적인 system call 후에 프로세스에는 아무것도 없다. 안티 바이러스가 시도하고 hook 하는 user-mode에 남은 것이 없다. 주입된 DLL이 unmap 된지는 오래됐다.</p><p><img src="/2021/01/10/idioth/memfuck/image8.png"></p><p>여기부터 Rtl* 함수 사용 없이 syscall을 통해 직접 code injection이나 detected code를 실행하는 것이다. 이것을 하면서 WoW64에 관해 많은 것을 배웠고, 한계점과 특이점, 32비트와 64비트 VEH 같은 새로운 탐구 영역을 얻었다.</p><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p><a href="https://github.com/jackullrich/memfuck">Github 주소</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/memfuck/">memfuck</category>
      
      <category domain="https://hackyboiz.github.io/tags/hook/">hook</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/10/idioth/memfuck/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] PsExec 0-day LPE non-official patch</title>
      <link>https://hackyboiz.github.io/2021/01/09/fabu1ous/2021-01-09/</link>
      <guid>https://hackyboiz.github.io/2021/01/09/fabu1ous/2021-01-09/</guid>
      <pubDate>Sat, 09 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.0patch.com/2021/01/local-privilege-escalatio</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.0patch.com/2021/01/local-privilege-escalation-0day-in.html">LPE 0day in PsExec</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows xp ~ Windows 10</p><p>PsExec v1.72</p><p>PsExec v2.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PsExec를 사용하는 시스템에서 System 권한을 획득할 수 있는 전형적인 named pipe hijacking <a href="https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/">취약점</a>이 패치되었습니다. 해커는 PsExec가 기존에 존재하는 named pipe를 재사용할 때 권한 설정을 변경하지 않는다는 점을 악용해 System권한을 갖는 named pipe를 사용할 수 있게 되고 System 권한으로 임의의 프로세스를 생성할 수 있습니다.</p><p>0Patch는 이 취약점에 대한 패치를 공개하고 무료로 배포하고 있습니다. PsExec 서비스는 원격 request를 받아 처리하는 thread를 생성할 때 <code>CreateNamedPipe()</code>를 호출합니다. 0Patch가 공개한 패치에선 <code>CreateNamedPipe()</code>가 호출되기 전 <code>FILE_FLAG_FIRST_PIPE_INSTANCE</code> 플레그 값을 사용해 <code>CreateNamedPipe()</code>를 한 번 더 호출하는 것으로 동일한 이름의 named pipe가 존재하는지 확인합니다. 만약 동일한 이름의 named pipe가 이미 존재하면 Psexesvc.exe를 종료합니다.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a></p><p><a href="https://github.com/tenable/poc/blob/master/Microsoft/Sysinternals/PsExecEscalate.cpp">https://github.com/tenable/poc/blob/master/Microsoft/Sysinternals/PsExecEscalate.cpp</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/named-pipe/">named pipe</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/09/fabu1ous/2021-01-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-29669 : WIFI SD Hub Privilege Escalation Plugin</title>
      <link>https://hackyboiz.github.io/2021/01/08/l0ch/2021-01-08/</link>
      <guid>https://hackyboiz.github.io/2021/01/08/l0ch/2021-01-08/</guid>
      <pubDate>Fri, 08 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/code-byter/CVE-2020-29669&quot;&gt;https://git</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/code-byter/CVE-2020-29669">https://github.com/code-byter/CVE-2020-29669</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Macally WIFISD2-2A82 Travel Router (펌웨어 버전 : 2.000.010)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>무선 미디어 공유가 가능한 WIFI SD 허브인 Macally WIFISD2-2A82 제품에서 root로 권한 상승이 가능한 취약점이 공개되었습니다.</p><p>취약점의 세부 공격 단계는 아래와 같습니다.</p><ol><li>해커는 웹 인터페이스에서 게스트 계정으로 로그인합니다.</li><li>패스워드 재설정 페이지에서 admin의 패스워드로 설정할 값을 입력합니다.</li><li>BurpSuite로 해당 요청에서 <code>name</code> 필드값을 admin으로 변경해 요청하면 admin의 패스워드가 재설정됩니다.</li><li>telnet을 통해 admin과 재설정한 패스워드를 입력해 접속하면 <code>/etc/passwd</code> 의 root를 포함한 모든 계정의 패스워드 해시를 유출할 수 있습니다.</li></ol><p>해당 취약점을 악용하면 패스워드 해시를 크래킹해 root 쉘에 접근할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/router/">router</category>
      
      <category domain="https://hackyboiz.github.io/tags/wifi-sd/">wifi sd</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/08/l0ch/2021-01-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] SoftMaker Office TextMaker에서 발견된 세 가지 취약점</title>
      <link>https://hackyboiz.github.io/2021/01/07/idioth/2021-01-07/</link>
      <guid>https://hackyboiz.github.io/2021/01/07/idioth/2021-01-07/</guid>
      <pubDate>Thu, 07 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.talosintelligence.com/2021/01/vuln-spotlight</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.talosintelligence.com/2021/01/vuln-spotlight-softmaker-office-textmaker-jan-2021.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+feedburner/Talos+(Talos%E2%84%A2+Blog)">Vulnerability Spotlight: Multiple vulnerabilities in SoftMaker Office TextMaker</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>SoftMaker Software GmbH SoftMaker Office TextMaker 2021, revision 1014</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SoftMaker Software GmbH는 오피스 소프트웨어를 개발하는 독일 소프트웨어 회사입니다. 플래그십 제품인 SoftMaker Office는 워드, 스프레드 시트, 프레젠테이션, 스크립트 등등의 기능을 지원합니다. 이 Office 제품군인 TextMaker의 document parsing 기능에서 세 가지 취약점이 발견되었습니다.</p><p><strong>CVE-2020-13544: Sign-extension</strong></p><p>document parser가 record를 parsing 할 때 index table record를 16bit unsigned 값으로 사용하지만 루프 문에서 index를 비교할 때 16bit signed 값으로 사용하여 index table record에 지정된 크기보다 많은 횟수를 반복할 수 있습니다. 따라서 index를 통해 heap 할당 범위 밖에 접근할 수 있습니다.</p><p><strong>CVE-2020-13545: Integer conversion</strong></p><p>document parser가 record를 스캔하고 읽어 올 때 파일 스트림의 현재 위치에서 record에서 사용하는 바이트 크기를 나타내는 32bit integer를 읽어옵니다. 버퍼를 할당할 때 signed multiplication을 사용하지만 버퍼의 끝을 계산할 때 unsigned multiplication을 사용하여 heap 할당 범위 밖의 주소에 접근할 수 있습니다.</p><p><strong>CVE-2020-13546: Integer overflow</strong></p><p>document parser가 record를 parsing 할 때 파일에서 32비트 값을 읽어 <code>0x23c</code>를 곱합니다. 피연산자는 최대 10비트이므로 overflow 되어 32비트로 잘려서 heap에 할당됩니다. 하지만 곱셈 하기 전의 값을 스택에 저장하고 사용하여 할당된 범위 밖에 값이 써지게 됩니다.</p><p>세 가지 취약점 모두 취약점을 트리거하기 위해 해커는 타깃이 문서를 열도록 유도해야 합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/integer-overflow/">integer overflow</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/sign-extension/">sign extension</category>
      
      <category domain="https://hackyboiz.github.io/tags/integer-conversion/">integer conversion</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/07/idioth/2021-01-07/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-35717: RCE through XSS</title>
      <link>https://hackyboiz.github.io/2021/01/06/fabu1ous/2021-01-06/</link>
      <guid>https://hackyboiz.github.io/2021/01/06/fabu1ous/2021-01-06/</guid>
      <pubDate>Wed, 06 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/bugbountywriteup/remote-code-execution</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/bugbountywriteup/remote-code-execution-through-cross-site-scripting-in-electron-f3b891ad637">zonote RCE through XSS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>zonote &lt;= 0.4.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>문서 작성 Electron App인 zonote에서 RCE 취약점이 공개되었습니다. zonote 문서에 마크다운과 html을 삽입해 XSS(Cross-Site-Script) 공격을 할 수 있는데 악용 범위를 RCE까지 확장할 수 있습니다. </p><blockquote><p>It is paramount that you do not enable Node.js integration in any renderer (<code>BrowserWindow</code>, <code>BrowserView</code>, or <code>&lt;webview&gt;</code>) that loads remote content.</p></blockquote><p><a href="https://www.electronjs.org/docs/tutorial/security#2-do-not-enable-nodejs-integration-for-remote-content">Electron의 공식문서</a>에 따르면 원격 콘텐츠에 접근하는 모든 renderer는 Node.js intergration이 비활성화되어있어야 합니다. XSS 취약점이 존재해도 그 악용 범위를 renderer 내부로 제한하기 위해 Electron 5.0.0부터 권장해온 기본 설정입니다. </p><ul><li>다음은 zonote의 main.js코드 일부입니다.</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> browserWindowsOptions = &#123;    ...    webPreference: &#123;        nodeIntergration : <span class="hljs-literal">true</span>,        enableRemoteModule : <span class="hljs-literal">true</span>    &#125;&#125;</code></pre><p>Node.js intergration이 활성화되어있으므로 XSS를 통한 RCE 취약점이 존재합니다.</p><ul><li>PoC</li></ul><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onemouseover</span>=<span class="hljs-string">&quot;</span></span></span><span class="xml">try&#123;</span><span class="xml">const &#123;shell&#125; = require(&#x27;electron&#x27;);</span><span class="xml">shell.openExternal(&#x27;file:C:/Windows/System32/calc.exe&#x27;)</span><span class="xml">&#125;catch(e)&#123;</span><span class="xml">console.error(e)</span><span class="xml">&#125;&quot;&gt;</span>Hover Me<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span></code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/xss/">xss</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/06/fabu1ous/2021-01-06/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-35489 : Unrestricted File Upload Vulnerability in WordPress Plugin</title>
      <link>https://hackyboiz.github.io/2021/01/05/l0ch/2021-01-05/</link>
      <guid>https://hackyboiz.github.io/2021/01/05/l0ch/2021-01-05/</guid>
      <pubDate>Tue, 05 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.wpsec.com/contact-form-7-vulnerability/&quot;&gt;htt</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.wpsec.com/contact-form-7-vulnerability/">https://blog.wpsec.com/contact-form-7-vulnerability/</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Contact Form ≤ 7 5.3.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>WordPress 플러그인인 Contact Form 7은 폼메일 플러그인으로 폼메일 양식을 쉽게 생성할 수 있어 인기 있는 플러그인 중 하나입니다. 해당 플러그인에서 허용되지 않은 확장자 필터링을 우회해 업로드할 수 있는 취약점이 발견되었습니다.</p><p>취약점의 세부 정보는 다음과 같습니다.</p><ol><li>해커는 특수 문자가 포함된 이중 확장자 파일을 업로드할 수 있습니다. ex) <code>mal.php .jpg</code> (공백  = \t)</li><li>Contact Form 7은 업로드된 파일 이름에서 특수 문자를 제거하지 않아 첫 번째 확장자 이후 구분 문자로 인해 두 번째 파일 확장자를 버립니다.</li><li>결과적으로 업로드되는 파일 이름은 <code>mal.php</code>가 되고 업로드에 성공합니다.</li><li>해커는 임의 코드 실행을 통해 업로드된 파일에 접근 및 실행이 가능합니다.</li></ol><p>해커는 이를 악용해 서버에 웹쉘과 같은 파일을 제한 없이 업로드할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/dn9uy3n/Check-WP-CVE-2020-35489">https://github.com/dn9uy3n/Check-WP-CVE-2020-35489</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/unrestricted-file-upload/">unrestricted file upload</category>
      
      <category domain="https://hackyboiz.github.io/tags/wordpress/">wordpress</category>
      
      <category domain="https://hackyboiz.github.io/tags/plugin/">plugin</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/05/l0ch/2021-01-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-29583: Zyxel 방화벽, VPN 제품에서 백도어 계정 발견</title>
      <link>https://hackyboiz.github.io/2021/01/04/idioth/2021-01-04/</link>
      <guid>https://hackyboiz.github.io/2021/01/04/idioth/2021-01-04/</guid>
      <pubDate>Mon, 04 Jan 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://thehackernews.com/2021/01/secret-backdoor-account</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://thehackernews.com/2021/01/secret-backdoor-account-found-in.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+TheHackersNews+(The+Hackers+News+-+Cyber+Security+Blog)">Secret Backdoor Account Found in Several Zyxel Firewall, VPN Products</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>방화벽<ul><li>ZLD V4.60 펌웨어를 사용하는 ATP, USG, USG FLEX, VPN 시리즈</li></ul></li><li>AP 컨트롤러<ul><li>NXC 2500, NXC5500</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Zyxel은 해커가 펌웨어에 하드 코딩된 undocumented account(FTP를 통한 자동 펌웨어 업데이트 제공을 위한 계정)를 통해 관리자 권한으로 로그인하고 네트워크 장비를 손상시킬 수 있는 취약점에 대한 패치를 발표했습니다.</p><p>이 취약점은 CVE-2020-29583으로 undocumented account인 <code>zyfwp</code>와 수정할 수 없는 비밀번호 <code>PrOw! aN_fXp</code>가 평문으로 저장되어 있으며 해당 계정을 통해 해커가 SSH 서버나 웹 인터페이스에 관리자 권한으로 접근할 수 있습니다.</p><pre><code class="hljs routeros">$ ssh zyfwp@192.168.1.252Password: Pr*******XpRouter&gt; show<span class="hljs-built_in"> users </span>current<span class="hljs-literal">No</span>: 1  Name: zyfwp  Type: admin(<span class="hljs-built_in">..</span>.)Router&gt;</code></pre><p>이 취약점을 악용해 해커는 방화벽의 설정을 조작하여 특정 트래픽을 허용하거나 막을 수 있고, 트래픽을 가로채거나 VPN 계정을 생성하여 네트워크에 대한 접근 권한을 가질 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.eyecontrol.nl/blog/undocumented-user-account-in-zyxel-products.html">https://www.eyecontrol.nl/blog/undocumented-user-account-in-zyxel-products.html</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/zyxel/">zyxel</category>
      
      <category domain="https://hackyboiz.github.io/tags/backdoor/">backdoor</category>
      
      <category domain="https://hackyboiz.github.io/tags/undocumented-account/">undocumented account</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/04/idioth/2021-01-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Daily-Life] 크리스마스 CTF 2020 운영 후기</title>
      <link>https://hackyboiz.github.io/2021/01/03/idioth/christmasctf2020-review/</link>
      <guid>https://hackyboiz.github.io/2021/01/03/idioth/christmasctf2020-review/</guid>
      <pubDate>Sun, 03 Jan 2021 08:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;사건의-전말&quot;&gt;&lt;a href=&quot;#사건의-전말&quot; class=&quot;headerlink&quot; title=&quot;사건의 전말&quot;&gt;&lt;/a&gt;사건의 전말&lt;/h1&gt;&lt;p&gt;매년 크리스마스에 이벤트 형식으로 열리는 솔로들을 위한(?) 크리스마스 CTF의 주최를 이번에 세</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="사건의-전말"><a href="#사건의-전말" class="headerlink" title="사건의 전말"></a>사건의 전말</h1><p>매년 크리스마스에 이벤트 형식으로 열리는 솔로들을 위한(?) 크리스마스 CTF의 주최를 이번에 세종대학교 정보보안 동아리 SSG와 함께 맡았습니다. 사실 우리가 문제를 만들어야 된다는 이야기도 갑자기 들었죠. Fabu1ous는 맡게 된 과정을 눈 앞에서 목격했으나 idioth과 L0ch는 통보를 받았습니다…</p><blockquote><p>??? : 크리스마스 때 뭐하냐<br>idioth : 데이트요<br>??? : 여자 친구 없잖아<br>idioth : 그때는 있겠죠<br>??? : 문제나 만들어라<br>L0ch : 전 있는데용 ㅎㅎ<br>??? : 알 바 아니고</p></blockquote><p><img src="/2021/01/03/idioth/christmasctf2020-review/image0.png"></p><p>불안한 직감은 언제나 옳습니다. ‘우리 문제 만들어야 돼’를 듣자마자 직감했습니다. 아 크리스마스 CTF구나… 처음엔 인당 두 문제씩 만들기로 했습니다. 하지만 여기서 사건이 하나 벌어지는데…</p><p>데이터 챌린지를 나가기로 했었는데 팀장 녀석이 분야를 착각해서 신청을 못했습니다. 그로 인해 각 3문제를 만들기로…ㅋㅋㅋㅋ</p><blockquote><p>idioth : 얘들아 우리 세 문제씩 만들기로 했어 ㅎㅎ<br>L0ch, Fabu1ous : ???<br>idioth : 데이터 챌린지 신청 못함 ㅋㅋㅋㅋㅋㅋ</p></blockquote><p><img src="/2021/01/03/idioth/christmasctf2020-review/image1.png"></p><p>처음에 만들기로 한 문제에 대한 버그 클래스는 아래와 같습니다만…</p><ul><li>idioth<ul><li>rev : custom packer</li><li>web : cve-2020-9484 tomcat rce</li><li>misc : snake</li></ul></li><li>L0ch<ul><li>pwn : Windows pwnable uaf</li><li>pwn : Linux pwnable type confusion</li><li>rev : obfuscate</li></ul></li><li>Fabu1ous<ul><li>pwn : angr challenge</li><li>pwn : uninit stack</li><li>misc : 미정</li></ul></li></ul><p>여러 가지 이유로 많이 바뀌었습니다… 코로나 때문에 갑자기 학기가 1주일 당겨지면서 11월과 12월 초가 통째로 바빠질 줄은 그들은 몰랐습니다…</p><p>학기가 끝난 후 그들은 랩실에 갇혀서 근 1주일을 밤새며 문제를 만들기에 박차를 가하게 됩니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image2.png"></p><p>대회 전날 그들의 모습</p><h1 id="idioth"><a href="#idioth" class="headerlink" title="idioth"></a>idioth</h1><p>안녕하세요. idioth입니다. 뭐… 처음에 대회를 한다 했을 때는 좀 많이 당황했습니다.</p><p>일단 5월 중순에 소집 해제하고 이제 막 다시 공부를 시작한 참이라서… 출제하기 전까지 CTF를 2개 정도 나갔는데 문제를 baby-rev 정도밖에 못 풀었습니다. 뭔가 좀 많이 바뀐 것 같더라고요. 포너블을 내기에는 기억도 어렴풋하고…</p><p>암호 공부를 해야겠다는 생각은 늘 하고 있었는데 최근에 어떤 문제들이 많은가 봤더니 암호랑 접목을 많이 시켜서 나오더라고요. 일단 암호는 내가 할 줄 모르니 패스… 그럼 뭐 만들지? 하다가 복무 중에 했던 Custom Packer 스터디가 떠올랐습니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image3.png"></p><p>아! 이거다! 패커 딱 대!</p><p>문제 만들어야 된다는 소리를 들은 후 주제를 대충 정한 후 바로 다음 달부터 패커 개발에 들어갔습니다. 일단 패커 관련된 문제가 나오지 않았다는 것은… 다들 아시죠? (ㅎㅎ)</p><ol><li>64비트로 만들자</li><li>어 내가 그때 스터디했던 건 32비트네?</li><li>너무 옛날 거네? 게다가 게시글도 사라졌네?</li><li>…github에 올라와있는 걸 보고 어떤 흐름으로 가면 좋은 지 보자</li></ol><p>그리고 열심히 열심히 한 달에 걸쳐서 완성을 했습니다! 역시 난 한다면 하는 남자! 하지만…</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image4.png"></p><p>코드를 계속 보는데도 도대체 어디가 문제인지 모르겠습니다… 아 시간이 없는데 이제 과제 폭풍이 몰려오고 있는데… 어떡하지?</p><p>일단 tomcat부터 만들자… tomcat 자체에 취약점이 있으니 웹 사이트 구현하고 트리거할 수 있게 기능 구현만 하면 되니까 금방 하겠지? 웹 하는 애들이 도와준댔어.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image5.png"></p><p>응 그런거 없어~ 웹 만들어 본거라곤 공부 처음 시작할 때 html, php와 django를 통해 만들어 본 것이 전부라서 맨 땅에 헤딩을 하면서 구현을 시작했습니다. 게다가 학교에서 python 학부 수업 조교도 진행해서 뭔가 할 일이 굉장히 많았죠(핑계야)</p><blockquote><p>기상 - 하루 한 줄 - 조교 - 과제 - (블로그 글) - 문제 만들기</p></blockquote><p>위의 순환을 계속 돌았습니다. 겉으로의 구현도 끝나고 파일 업로드 등의 구현도 11월 말에 다 끝났습니다. 하지만 가장 큰 문제가 있었습니다.</p><p>버전은 어떻게 알려 줄 것이고 지금 상태에선 session 폴더와 모든 것이 게싱이다.</p><p>여러 가지 사람들과 이야기를 해본 끝에 LFI를 통해서 모든 파일을 다 읽을 수 있게 하도록 했습니다.</p><p>그 과정에서 path traversal 필터링을 거는 게 좋을까 말까에 대해서는 그래도 <code>../</code> 같은 기본적인 거는 걸어놓는 게 좋지 않을까?라는 생각을 했습니다.</p><p>근데 주변에서 어차피 그런 거 보이면 일단 때려 넣고 보니까 기본적인 거는 걸어놓는 게 좋아.라는 말을 듣고 <code>gift</code> 문제가 탄생하게 됩니다.</p><p>다 만들었을 때는 그래도 웹 처음 만든 것 치고 괜찮은 것 같은데?라는 생각을 했으나… 저의 오만함이었음을 깨달았습니다. 으으… 저는 게싱을 최대한 줄였다고 생각했지만 제가 만들었던 문제라서 그렇게 생각했던 것 같습니다 ㅜㅜ…</p><p>하지만 가장 큰 문제는 <code>gift</code> 하나 만들었는데 대회가 일주일 남았다.</p><p>일단 리버싱 문제를 하나 만들어야지… 그냥 간단한 것 내야겠다… crackme 하나 해야지~ 하고 만들었습니다. 근데 뭔가 너무 허전해서 고민을 했습니다. 아 뭔가 없나… 하다가 딱 생각이 났습니다.</p><p>오 이제 맥도 ARM으로 나오는데 ARM 리버싱 할까? ㄱㄱㄱㄱ arm 어셈 분석하는 걸로 내고~ ida hexrays를 막아놓자. 어차피 잘하시는 분들은 arm도 금방 보실 테고 하니까 anti-hexrays는 금방 푸시겠지?</p><p>ida에서는 깨져서 나오는데… 왜 ghidra에서는 제대로 나오는 걸까…?</p><p>??? : 야 그냥 핸드 레이로 내자</p><p>idioth : ㄱ 어차피 baby 용으로 낸 거니까 괜찮겠지?</p><p>-<code>lock</code> 끝-</p><p>아 이제 snake 하나만 남았네요 ㅎㅎ misc 문제라서 너무 부담이 없습니다~ 뱀 게임 재미나게 하나 만들어야지<del>~</del>하고 생각하는 와중에 앞을 보니까 절망의 구렁텅이에 빠진 한 남자가 있었습니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image6.png"></p><blockquote><p>L0ch : 나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼</p></blockquote><p>앞에서 보는데 진짜 너무 무섭더라고요. 그래서 그냥 제 misc 문제를 주고 reversing을 제가 내기로 했습니다. 참가한 대회 중 하나에서 angr로 푼 문제가 있어서 angr 문제를 내자. 근데 이것도 arm으로 내면 재밌겠당. 하고 후딱 만들었습니다.</p><p>근데 arm에서는 왜 simulation manager를 돌려도 값이 안 나오지? 그냥 x64로 완성하고 난 후 L0ch를 보니 뱀 게임을 완성하고 자기 type confusion 못 만들 것 같은데 baby pwnable 뭐 낼 지 물어보더라고요. 그래서 그냥 던져 줬습니다. arm rop 재밌을 듯? <code>baby_RudOlPh</code> 탄생~</p><p>근데 angr 문제를 검수하고 값을 연산하는 로직을 수정하고 나니까 이상하게 값이 밀려서 나왔습니다. 처음에 c++로 짰었고 전체적으로 계속 수정을 했는데 input이 이상하게 들어가거나 해서 코드가 전체적으로 꼬여버렸습니다. 결국 c로 옮기게 되었고 c로 옮겨서 나오는 값들을 확인해보자 byte 몇 개가 사라지더라고요.</p><p>대회는 당장 내일이고 급하니까 범위가 넘어가서 그런가 보다 생각하고 그냥 크게 연산하는 로직들을 지워버리고 만들었습니다. 그렇게 <code>angrforge</code> 탄생. 사실 이 문제는 욕먹을 거라 생각했습니다. 손으로 푸신 분 계시던데 진짜 죄송합니다… 다음에 문제 만들 일이 생긴다면 이런 *** 같은 의도 파악조차 안 되는 문제는 만들지 않겠습니다.</p><p>대회는 여차저차 잘 끝났지만 마음이 불편했습니다. 나는 나대로 열심히 했는데 결과물이 좋지 않았으니까요. 일단 내가 생각한 대로 만들어진 문제가 없었습니다. <code>lock</code>이나 <code>angrforge</code> 같은 경우는 시간에 쫓겨 로직에 대한 큰 고민 없이 만든 문제들이라서 마음에 들지 않았습니다.</p><p>거의 대부분의 문제 제작 시간을 <code>gift</code>에 쏟았고, 실제 이러한 서비스가 운영돼서 이 취약점이 존재한다면 이렇게 접근하면 재밌겠다.라는 시나리오도 잘 만들었다고 생각했습니다.</p><p>근데 이건 출제자의 생각이지 참여하신 분들이 그렇게 생각 안 하신다면 그게 맞는 거죠.</p><p>대회가 끝나고 나서 심야 버스를 타고 집으로 출발했습니다. 거의 40시간 넘게 깨어 있었던 것 같네요. 버스에서 잠도 안 오더군요. 그냥 현타가 세게 왔습니다.</p><p>아… 내가 진짜 못하는구나. 내가 생각했던 것이나 다른 문제들을 풀거나 분석하면서 봤던 로직들을 구현하지도 못하고, 생각의 넓이나 깊이도 부족하구나. 내가 생각한 것보다 사람들은 더 넓은 것을 보는구나.</p><p>돌이켜 생각해보니 사람들이 봤을 때 주제나 컨셉이 재밌고 신선한 것에만 너무 신경 쓰지 않았나? 내가 사람들에게 그 재미를 온전히 전달할 만큼의 기본 베이스가 되는가?라는 생각이 들었습니다.</p><p>집에 돌아와서 샤워하고 누웠는데 해가 뜰 때까지 잠을 못 잤습니다. 잡생각이 많아서 일단 지쳐서 잠들고 일어나니 상위권 팀들 라업이 기대가 되더군요. <code>lock</code>이랑 <code>angrforge</code>는 모르겠고 <code>gift</code>를 어떻게 푸셨고 어떻게 느끼셨는지에 대한 생각이 정말 컸습니다.</p><p>라업을 다 보고 나서 라업을 다 뜯어고쳤습니다. 좀 더 내가 생각했던 것과 고민했던 것이 무엇인지 그리고 2021년에는 어떤 식으로 공부하면 좋을지 이번 기회에 제가 부족했던 것, 부족함을 알고 있었지만 애써 외면하던 것들에 직면하게 되어서 좋은 경험이었던 것 같습니다.</p><p>다들 미천한(?) 문제 푸시느라 고생 많으셨습니다. 재밌게 즐기셨다면 정말 좋았을 텐데…! 다들 새해 복 많이 받으세요!</p><h1 id="L0ch"><a href="#L0ch" class="headerlink" title="L0ch"></a>L0ch</h1><p>안녕하세요. L0ch입니다! CTF 문제 출제 경험이라고는 동아리 내부 CTF 밖에 없던 저에게 크리스마스 CTF 문제를 만들어야 한다는 소식을 들었을 때..</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image7.png"></p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image8.png"></p><blockquote><p>??????? 문제를 만들라구요???</p></blockquote><p>진짜 딱 저 표정이었습니다. 거짓말 아니고 진짜로요.</p><p>국방의 의무를 수행하느라 백지가 된 머리로 열심히 따라가고 있던 와중에 (대한민국 군인들 화이팅 ㅠㅠ) CTF 문제를 그것도 세 문제나 만들라니요.. 아무튼 데이터 챌린지 신청 못한 팀장 탓임 @idioth @idioth @idioth</p><p>그렇게 열심히 최근 CTF 트렌드를 찾아보고 어느 정도 틀을 잡아가기 시작했습니다.</p><p>첫 번째 문제였던 address_book 이 나오게 된 배경입니다.</p><p>때는 하루 한 줄을 쓰기 위해 떠돌아다니던 중 Chrome의 공유 포인터 관련 UAF 취약점 정보를 보게 되었죠. </p><p>거기에 영감을 받아 공유 포인터를 커스텀으로 구현해서 거기에 취약점을 만들어볼까? </p><ul><li>MS tuesday patch의 diff 패치를 바이너리에 적용해 binary diffing으로 취약점을 찾을 수 있도록 해볼까? </li></ul><p>이렇게 해서 나온 문제입니다. 물론 사람 인생이 계획대로만 될 리가 있나요 ㅎㅎ</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image9.png"></p><p>문제는 제가 윈너블 경험이 부족하다는 점이었습니다. 버그헌팅을 하면서 원데이 몇 번 분석해본 게 전부인 저에게 취약점 설계부터 익스까지 한다? 멘탈이 아주 곱게 갈릴 거라는 걸 시작부터 예감했죠.</p><p>우선 C++의 공유 포인터를 구현하려면 당연히 C++을 써야 하는데 기본적인 OOP 개념이 부족했습니다. 문제를 만들던 중 코드 리뷰를 해보니까 진짜 개판 오 분 전이었는데 더한 문제는 어떻게 고쳐야 할지를 몰랐습니다..   분석하시면서 이거 왜 이렇게 짜 놨지 하는 부분이 있었을 텐데, 다 부족한 저의 개발실력 때문입니다.. </p><p>또 하나 문제는.. </p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image10.png"></p><blockquote><p>아니 다 만들어놓고 익스가 왜 안되는데!!!!!!!!!!!!!!!!!!!!!!!!!!</p></blockquote><p>원래 익스에 포함되는 과정 중 하나였던 <code>flag.txt</code> 파일 open을 함수가 계속 <code>응 파일 못 열었어 ㅋㅋ</code> 를 뱉는데 이게 무슨 경우지? 왜 파일을 못 여는 거지?? 혼잣말하면서 욕도 해보고 달래도 보고 열심히 삽질을 했지만 원인을 찾지 못해 결국 바이너리 내부에서 <code>flag.txt</code> 를 open만 하고 익스 과정 중 ROP 체인에서 open 과정을 빼고 file descriptor를 이용해 flag를 출력하는 것으로 타협을 볼 수밖에 없었습니다.</p><blockquote><p>후일담<br>idioth : ㅋㅋㅋㅋ 너 address book 익스 할 때 진짜 무서웠던 거 아냐<br>본인 : ??? 왜요 나 왜<br>idioth : 누구 하나 걸리면 진짜 죽는단 표정이었어<br>Fabu1ous : ㅇㅈ<br>본인 :</p></blockquote><p>취약점을 찾기 어렵게 만든 이유가 diff patch를 이용한 binary diffing으로 취약점을 찾을 수 있도록 의도한 거지만.. 계획에 차질이 생겨 diff patch도 적용을 못해 결과적으로 좋지 않은 퀄리티의 아쉬운 문제라고 생각합니다… </p><p>그렇게 한 문제를 마무리하고 보니,  왜 시작도 안 한 두 문제가 남아있고 저는 기말고사를 눈앞에 두고 있는 걸까요?</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image11.png"></p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image12.png"></p><blockquote><p>저는 그렇게.. 학점을 놓아주었습니다</p></blockquote><p>학점을 포기한 대가로 나머지 baby_RudOlPh와 picky_eater를 구상할 수 있었습니다. <em><del>등가교환의 법칙</del></em></p><p>picky_eater는 idioth 팀장님의 아이디어를 쏙 빼왔습니다. address book과 고군분투하고있던 저를 불쌍하게 봤었나봐요. “이거 네가 할래?” 라며 snake 게임 컨셉의 아이디어를 주더라고요. 그 정도로 불쌍해 보였나?;; 아무튼 감사합니다 ㅎㅎ<br>그래도 만들 땐 재밌게 만들었던 문제인 것 같습니다!</p><p>마지막 baby_RudOlPh는 두 줄로 설명하겠습니다. </p><blockquote><p>??? : (회의 도중) 님들 생각해보니까 뉴비용 포너블 문제가 없는데요?</p></blockquote><p>그래서 만들게 된 ARM(AArch64) ROP 문제입니다. 그냥 내면 재미없잖아요! 그래서 ARM을 끼얹었죠</p><p>(사실 기간 내에 원래 생각했던 type confusion 문제를 못 만들 것 같아서 뉴비문제 냈다는 건 안 비밀)</p><p>정리하고 보니까 더 잘할 수 있었음에도 그러지 못해 아쉬운 감정이 많이 남는 대회라고 생각이 드네요. 나중에 다른 CTF에 문제를 출제할 수 있는 기회가 올진 모르겠지만 기회가 된다면 더 많이, 철저하게 준비해서 좋은 퀄리티의 문제를 만들 수 있도록 노력하겠습니다. 부족한 제 문제를 풀어주신 모든 참가자 여러분들께 감사의 말씀드립니다..!</p><h1 id="Fabu1ous"><a href="#Fabu1ous" class="headerlink" title="Fabu1ous"></a>Fabu1ous</h1><ul><li>Oil-system &amp; Match-maker</li></ul><p><img src="/2021/01/03/idioth/christmasctf2020-review/image13.png"></p><p>버그 잡는 건 정말 힘든 작업이군요. 대회 때 oil-system의 풀이 수가 20이던데 아마 모두 언인텐디드일거라 생각합니다. Match-maker도 메모리 leak 중 언인텐디드가 한 개 있었습니다. 솔직히 아주 조금 억울한 부분이 있지만 그게 무슨 의미가 있겠습니까… 이런 상황이 발생한 이유를 적어보고 성찰의 시간이나 가져봅시다.</p><ol><li><p>뱁새가 황새를 따라가면 다리가 찢어진다</p><p> 문제를 만들 때까진 몰랐는데 지금 보니 정말 별거 없는 문제더군요. 큰 틀만 보면 리턴 값을 조작해 <code>win()</code> 함수를 실행하는 문제들과 크게 다를 게 없습니다. 흔히 아는 만큼 보인다고 하죠. 어려운 문제를 만들겠다는 의욕은 앞섰지만 실력은 안 따라주고 결국 쓸데없이 복잡한 동작을 하는 문제가 탄생한 거 같습니다.</p></li><li><p>돌다리도 두들겨 보고 건너라.</p><p> 최종 검사하세요. 두 번 하세요. 최종 검사의 검사도 하세요. 이번 사건 이후로 어떤 일이든 쉽게 확신을 갖진 않을 것 같습니다.</p></li></ol><ul><li>No g</li></ul><p>설문 조사에 의하면 이번 대회에서 호불호가 가장 심했던 문제네요. 셜록홈즈 암호( 춤추는 사람 그림 암호 )와 비슷한 느낌으로 crypto와 misc 그 사이 어딘가의 문제를 만들려고 해 봤습니다. No g라는 제목에서 힌트를 얻어 쉽게 푸신 분들도 있지만 그러지 못하고 기상천외한 삽질을 하신 분들도 있더군요. 가볍게 misc나 풀면서 머리 식히려고 봤다가 고통받으신 분들께 사죄하겠습니다. ㅎㅎ</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image14.png"></p><p>죄송해요 ㅠㅠㅠㅠㅠ</p><p>2년 연속 Christmas CTF에 대해 안 좋은 기억만 남네요. 올해는 꼭 여친 사귀어서 Christmas CTF 말고 데이트하러 가야겠습니다. </p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image15.png"></p><p><del>아이씨… 누가 여기다 양파를 가져다 놓은 거야!?</del></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Daily-Life/">Daily-Life</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/ctf/">ctf</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/christmas-ctf-2020/">christmas ctf 2020</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/review/">review</category>
      
      
      <comments>https://hackyboiz.github.io/2021/01/03/idioth/christmasctf2020-review/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
